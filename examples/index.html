<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="/img/favicon.ico">
        <meta name="keywords" content="Finite Element Library,Finite Element Code,Finite Element Method Library,Finite Element Method Code,Finite Element C++,Finite Element Method C++,Finite Element Library C++,Finite Element Code C++,FEM Code,FEM Library,FEM C++">
        <meta name="google-site-verification" content="45K56TawSdzbgy-uDtfJdYwp7zaVdL3fIAGYt869wwU" />
<!--	<title></title>  -->
        <title>MFEM - Finite Element Discretization Library</title>

        <link href="../css/bootstrap-mfem.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/highlight.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

	<!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-NS5XV5TFM6"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-NS5XV5TFM6');
        </script>

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="https://mfem.org">MFEM</a>
        </div>

        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
            
            
            
                <li >
                    <!-- Replace "nav_item.url|url" with "nav_item.url" for older mkdocs (before 1.0) -->
                    <a href="../features/">Features</a>
                </li>
            
            
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li class="active">
                                 <a href="./">Example Codes</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../electromagnetics/">Electromagnetics</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../fluids/">Fluid Dynamics</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../meshing-miniapps/">Meshing</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../nurbs/">NURBS Discretization</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../autodiff/">Automatic Differentiation</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../tools/">Tools</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../toys/">Toys</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li >
                                 <a href="../getting-started/">Getting Started</a>
                            </li>
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            <li >
                                 <a href="../howto/howto-index/">HowTo Articles</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../fem/">Finite Elements</a>
                            </li>
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            <li >
                                 <a href="../performance/">Performance</a>
                            </li>
                        
                    
                        
                    
                        
                            <li >
                                 <a href="../gpu-support/">GPU Support</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../mesh-formats/">Mesh Formats</a>
                            </li>
                        
                    
                        
                    
                        
                    
                        
                            <li >
                                 <a href="../dox/">Doxygen</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../publications/">Publications</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../about/">About</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../search/">ðŸ”Ž Search...</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Community <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        
                            <li >
                                 <a href="../news/">News</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../videos/">Videos</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../seminar/">Seminar</a>
                            </li>
                        
                    
                        
                            <li >
                                 <a href="../workshop/">Workshop</a>
                            </li>
                        
                    
                        
                    
                        
                    
                        
                    
                        
                            <li >
                                 <a href="../tutorial/">Tutorial</a>
                            </li>
                        
                    
                    </ul>
                </li>
            
            
            
            
            
                <li >
                    <!-- Replace "nav_item.url|url" with "nav_item.url" for older mkdocs (before 1.0) -->
                    <a href="../gallery/">Gallery</a>
                </li>
            
            
            
            
            
                <li >
                    <!-- Replace "nav_item.url|url" with "nav_item.url" for older mkdocs (before 1.0) -->
                    <a href="../download/">Download</a>
                </li>
            
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                
                
                <li>
                    <a href="https://github.com/mfem/mfem/">
                        
                            <i class="fa fa-github-square"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        
        <div class="container">
            
            <div class="col-md-12" role="main">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});
</script>

<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_HTML">
</script>

<h1 id="example-codes-and-miniapps">Example Codes and Miniapps</h1>
<p>This page provides a brief overview of MFEM's example codes and miniapps. For
detailed documentation of the MFEM sources, including the examples, see the
<a href="https://docs.mfem.org">online Doxygen documentation</a>,
or the <code>doc</code> directory in the distribution.</p>
<p>The goal of the example codes is to provide a step-by-step introduction to MFEM
in simple model settings. The miniapps are more complex, and are intended to be
more representative of the advanced usage of the library in physics/application
codes. We recommend that new users start with the example codes before moving to
the miniapps.</p>
<p>Select from the categories below to display examples and miniapps that contain the
respective feature. <em>All examples support (arbitrarily) high-order meshes and
finite element spaces</em>.
The numerical results from the example codes can be visualized using the
GLVis visualization tool (based on MFEM). See the
<a href="https://glvis.org">GLVis website</a> for more details.</p>
<p>Users are encouraged to submit any example codes and miniapps that they have created and
would like to share. <br>
<em>Contact a member of the MFEM team to report
<a href="https://github.com/mfem/mfem/issues/new?labels=bug">bugs</a>
or post <a href="https://github.com/mfem/mfem/issues/new?labels=question">questions</a> or <a href="https://github.com/mfem/mfem/issues/new?labels=comment">comments</a></em>.</p>
<div class="row">
<p><div class="col-sm-6 col-md-2 small" markdown="1">
   <h5><strong>Application (PDE)</strong></h5>
   <select id="group1" onchange="update()">
      <option id="all1">All</option>
      <option id="diffusion">Diffusion</option>
      <option id="convectiondiffusion">Convection-diffusion</option>
      <option id="elasticity">Elasticity</option>
      <option id="maxwell">Electromagnetics</option>
      <option id="acoustics">Acoustics</option>
      <option id="graddiv">grad-div</option>
      <option id="darcy">Darcy</option>
      <option id="advection">Advection</option>
      <option id="conduction">Conduction</option>
      <option id="wave">Wave</option>
      <option id="compressibleflow">Compressible flow</option>
      <option id="incompressibleflow">Incompressible flow</option>
      <option id="meshing">Meshing</option>
      <option id="nonlocal">Nonlocal</option>
      <option id="stochastic">Stochastic</option>
      <option id="freeboundary">Free boundary</option>
   </select>
</div>
<div class="col-sm-6 col-md-3 small" markdown="1">
   <h5><strong>Finite Elements</strong></h5>
   <select id="group2" onchange="update()">
      <option id="all2">All</option>
      <option id="h1">H1 nodal elements</option>
      <option id="l2">L2 discontinuous elements</option>
      <option id="hcurl">H(curl) Nedelec elements</option>
      <option id="hdiv">H(div) Raviart-Thomas elements</option>
      <option id="h12">H^{1/2} interfacial elements</option>
      <option id="hminus12">H^{-1/2} interfacial elements</option>
   </select>
</div>
<div class="clearfix hidden-md hidden-lg"></div>
<div class="col-sm-6 col-md-3 small" markdown="1">
   <h5><strong>Discretization</strong></h5>
   <select id="group3" onchange="update()">
      <option id="all3">All</option>
      <option id="galerkin">Galerkin FEM</option>
      <option id="mixed">Mixed FEM</option>
      <option id="dg">Discontinuous Galerkin (DG)</option>
      <option id="dpg">Discont. Petrov-Galerkin (DPG)</option>
      <option id="hybr">Hybridization</option>
      <option id="staticcond">Static condensation</option>
      <option id="nurbs">Isogeometric analysis (NURBS)</option>
      <option id="amr">Adaptive mesh refinement (AMR)</option>
      <option id="pa">Partial assembly</option>
   </select>
</div>
<div class="col-sm-6 col-md-4 small" markdown="1">
   <h5><strong>Solver</strong></h5>
   <select id="group4" onchange="update()">
      <option id="all4">All</option>
      <option id="jacobi">Jacobi</option>
      <option id="gs">Gauss-Seidel</option>
      <option id="pcg">PCG</option>
      <option id="minres">MINRES</option>
      <option id="gmres">GMRES</option>
      <option id="amg">Algebraic Multigrid (BoomerAMG)</option>
      <option id="ams">Auxiliary-space Maxwell Solver (AMS)</option>
      <option id="ads">Auxiliary-space Divergence Solver (ADS)</option>
      <option id="superlu">SuperLU/STRUMPACK (parallel direct)</option>
      <option id="umfpack">UMFPACK (serial direct)</option>
      <option id="newton">Newton method (nonlinear solver)</option>
      <option id="rk">Explicit Runge-Kutta (ODE integration)</option>
      <option id="sdirk">Implicit Runge-Kutta (ODE integration)</option>
      <option id="newmark">Newmark (ODE Integration)</option>
      <option id="symplectic">Symplectic Algorithm (ODE Integration)</option>
      <option id="lobpcg">LOBPCG, AME (eigensolvers)</option>
      <option id="sundials">SUNDIALS solvers</option>
      <option id="petsc">PETSc solvers</option>
      <option id="slepc">SLEPc eigensolvers</option>
      <option id="hiop">HiOp solvers</option>
      <option id="none">None</option>
   </select>
</div></p>
</div>
<p><br>
<hr></p>
<!-- ------------------------------------------------------------------------- -->

<div id="ex0">
<h2 id="example-0-simplest-laplace-problem">Example 0: Simplest Laplace Problem</h2>
<p><img class="floatright" src="../img/examples/ex0.png"></p>
<p>This is the simplest MFEM example and a good starting point for new users.
The example demonstrates the use of MFEM to define and solve an $H^1$ finite
element discretization of the Laplace problem
$$-\Delta u = 1 \quad\text{in } \Omega$$
with homogeneous Dirichlet boundary conditions
$$ u = 0 \quad\text{on } \partial\Omega$$</p>
<p>The example illustrates the use of the basic MFEM classes for defining the mesh,
finite element space, as well as linear and bilinear forms corresponding to the
left-hand side and right-hand side of the discrete linear system.</p>
<p><em>The example has serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex0.cpp">ex0.cpp</a>)
and parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex0p.cpp">ex0p.cpp</a>)
versions.</em>
<div style="clear:both;"></div>
<br></p>
</div>
<div id="ex1">
<h2 id="example-1-laplace-problem">Example 1: Laplace Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex1.saved" target="_blank">
<img class="floatright" src="../img/examples/ex1.png">
</a></p>
<p>This example code demonstrates the use of MFEM to define a simple isoparametric
finite element discretization of the Laplace problem $$-\Delta u = 1$$ with
homogeneous Dirichlet boundary conditions. Specifically, we discretize with the
finite element space coming from the mesh (linear by default, quadratic for
quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The problem solved in
this example is the same as <a href="#ex0">ex0</a>, but with more sophisticated options and
features.</p>
<p>The example highlights the use of mesh refinement, finite element grid
functions, as well as linear and bilinear forms corresponding to the left-hand
side and right-hand side of the discrete linear system. We also cover the
explicit elimination of essential boundary conditions, static condensation, and
the optional connection to the <a href="https://glvis.org">GLVis</a> tool for visualization.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex1.cpp">ex1.cpp</a>),
a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex1p.cpp">ex1p.cpp</a>),
and HPC versions: <a href="https://github.com/mfem/mfem/blob/master/miniapps/performance/ex1.cpp">performance/ex1.cpp</a>,
<a href="https://github.com/mfem/mfem/blob/master/miniapps/performance/ex1p.cpp">performance/ex1p.cpp</a>.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>
, a PUMI modification in <a href="https://github.com/mfem/mfem/blob/master/examples/pumi">examples/pumi</a> and a Ginkgo modification
in <a href="https://github.com/mfem/mfem/tree/master/examples/ginkgo">examples/ginkgo</a>.
Partial assembly and <a href="../gpu-support/">GPU devices</a> are supported.</em>
<div style="clear:both;"></div>
<br></p>
</div>
<div id="ex2">
<h2 id="example-2-linear-elasticity">Example 2: Linear Elasticity</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex2.saved" target="_blank">
<img class="floatright" src="../img/examples/ex2.png">
</a></p>
<p>This example code solves a simple linear elasticity problem
describing a multi-material cantilever beam.
Specifically, we approximate the weak form of
$$-{\rm div}({\sigma}({\bf u})) = 0$$
where
$${\sigma}({\bf u}) = \lambda\, {\rm div}({\bf u})\,I + \mu\,(\nabla{\bf u} + \nabla{\bf u}^T)$$
is the stress tensor corresponding to displacement field ${\bf u}$, and $\lambda$ and $\mu$
are the material Lame constants. The boundary conditions are
${\bf u}=0$ on the fixed part of the boundary with attribute 1, and
${\sigma}({\bf u})\cdot n = f$ on the remainder with $f$ being
a constant pull down vector on boundary elements with attribute 2, and zero
otherwise. The geometry of the domain is assumed to be as follows:</p>
<p><img alt="" src="../img/examples/ex2-domain.png" /></p>
<p>The example demonstrates the use of high-order and NURBS vector
finite element spaces with the linear elasticity bilinear form,
meshes with curved elements, and the definition of piece-wise
constant and vector coefficient objects. Static condensation is
also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex2.cpp">ex2.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex2p.cpp">ex2p.cpp</a>) version.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>
and a PUMI modification in <a href="https://github.com/mfem/mfem/blob/master/examples/pumi">examples/pumi</a>.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex3">
<h2 id="example-3-definite-maxwell-problem">Example 3: Definite Maxwell Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex3.saved" target="_blank">
<img class="floatright" src="../img/examples/ex3.png">
</a></p>
<p>This example code solves a simple 3D electromagnetic diffusion
problem corresponding to the second order definite Maxwell
equation $$\nabla\times\nabla\times\, E + E = f$$
with boundary condition $ E \times n $ = "given tangential field".
Here, we use a given exact solution $E$ and compute the corresponding r.h.s.
$f$. We discretize with Nedelec finite elements in 2D or 3D.</p>
<p>The example demonstrates the use of $H(curl)$ finite element
spaces with the curl-curl and the (vector finite element) mass
bilinear form, as well as the computation of discretization
error when the exact solution is known. Static condensation is
also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex3.cpp">ex3.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex3p.cpp">ex3p.cpp</a>) version.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>.
Partial assembly and <a href="../gpu-support/">GPU devices</a> are supported.
We recommend viewing examples 1-2 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex4">
<h2 id="example-4-grad-div-problem">Example 4: Grad-div Problem</h2>
<p><img class="floatright" src="../img/examples/ex4.png"></p>
<p>This example code solves a simple 2D/3D $H(div)$
diffusion problem corresponding to the second order definite equation
$$-{\rm grad}(\alpha\,{\rm div}(F)) + \beta F = f$$
with boundary condition $F \cdot n$ = "given normal field".
Here we use a given exact solution $F$ and compute the corresponding
right hand side $f$.  We discretize with the Raviart-Thomas finite elements.</p>
<p>The example demonstrates the use of $H(div)$
finite element spaces with the grad-div and $H(div)$
vector finite element mass bilinear form, as well as the computation of discretization
error when the exact solution is known.
Bilinear form hybridization and static condensation are also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex4.cpp">ex4.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex4p.cpp">ex4p.cpp</a>) version.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>.
Partial assembly and <a href="../gpu-support/">GPU devices</a> are supported.
We recommend viewing examples 1-3 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex5">
<h2 id="example-5-darcy-problem">Example 5: Darcy Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex5.saved" target="_blank">
<img class="floatright" src="../img/examples/ex5.png">
</a></p>
<p>This example code solves a simple 2D/3D mixed Darcy problem
corresponding to the saddle point system
$$ \begin{array}{rcl}
   k\,{\bf u} + {\rm grad}\,p &amp;=&amp; f \\
   -{\rm div}\,{\bf u} &amp;=&amp; g
\end{array} $$
with natural boundary condition $-p = $ "given pressure".
Here we use a given exact solution $({\bf u},p)$ and compute the
corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas
finite elements (velocity $\bf u$) and piecewise discontinuous
polynomials (pressure $p$).</p>
<p>The example demonstrates the use of the BlockMatrix and BlockOperator
classes, as well as the collective saving of several grid functions in
<a href="https://visit.llnl.gov">VisIt</a> and <a href="https://www.paraview.org">ParaView</a>
formats.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex5.cpp">ex5.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex5p.cpp">ex5p.cpp</a>) version.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>.
Partial assembly is supported.
We recommend viewing examples 1-4 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex6">
<h2 id="example-6-laplace-problem-with-amr">Example 6: Laplace Problem with AMR</h2>
<p><img class="floatright" src="../img/examples/ex6.png"></p>
<p>This is a version of Example 1 with a simple adaptive mesh
refinement loop. The problem being solved is again the Laplace
equation $$-\Delta u = 1$$ with homogeneous Dirichlet boundary
conditions. The problem is solved on a sequence of meshes which
are locally refined in a conforming (triangles, tetrahedrons)
or non-conforming (quadrilaterals, hexahedra) manner according
to a simple ZZ error estimator.</p>
<p>The example demonstrates MFEM's capability to work with both
conforming and nonconforming refinements, in 2D and 3D, on
linear, curved and surface meshes. Interpolation of functions
from coarse to fine meshes, as well as persistent <a href="https://glvis.org">GLVis</a>
visualization are also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex6.cpp">ex6.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex6p.cpp">ex6p.cpp</a>) version.
It also has a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>
and a PUMI modification in <a href="https://github.com/mfem/mfem/blob/master/examples/pumi">examples/pumi</a>.
Partial assembly and <a href="../gpu-support/">GPU devices</a> are supported.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex7">
<h2 id="example-7-surface-meshes">Example 7: Surface Meshes</h2>
<p><img class="floatright" src="../img/examples/ex7.png"></p>
<p>This example code demonstrates the use of MFEM to define a
triangulation of a unit sphere and a simple isoparametric
finite element discretization of the Laplace problem with mass
term, $$-\Delta u + u = f.$$</p>
<p>The example highlights mesh generation, the use of mesh
refinement, high-order meshes and finite elements, as well as
surface-based linear and bilinear forms corresponding to the
left-hand side and right-hand side of the discrete linear
system. Simple local mesh refinement is also demonstrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex7.cpp">ex7.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex7p.cpp">ex7p.cpp</a>) version.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex8">
<h2 id="example-8-dpg-for-the-laplace-problem">Example 8: DPG for the Laplace Problem</h2>
<p><img class="floatright" src="../img/examples/ex8.png"></p>
<p>This example code demonstrates the use of the Discontinuous
Petrov-Galerkin (DPG) method in its primal 2x2 block form as a
simple finite element discretization of the Laplace problem
$$-\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We
use high-order continuous trial space, a high-order interfacial
(trace) space, and a high-order discontinuous test space
defining a local dual ($H^{-1}$) norm.
We use the primal form of DPG, see
<a href="https://dx.doi.org/10.1016/j.camwa.2013.06.029">"A primal DPG method without a first-order reformulation"</a>,
Demkowicz and Gopalakrishnan, CAM 2013.</p>
<p>The example highlights the use of interfacial (trace) finite
elements and spaces, trace face integrators and the definition
of block operators and preconditioners.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex8.cpp">ex8.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex8p.cpp">ex8p.cpp</a>) version.
We recommend viewing examples 1-5 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex9">
<h2 id="example-9-dg-advection">Example 9: DG Advection</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex9.saved" target="_blank">
<img class="floatright" src="../img/examples/ex9.png">
</a></p>
<p>This example code solves the time-dependent advection equation
$$\frac{\partial u}{\partial t} + v \cdot \nabla u = 0,$$ where $v$ is a given fluid
velocity, and $u_0(x)=u(0,x)$ is a given initial condition.</p>
<p>The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms
in MFEM (face integrators), the use of explicit and implicit (with block ILU
preconditioning) ODE time integrators, the definition of periodic boundary
conditions through periodic meshes, as well as the use of
<a href="https://glvis.org">GLVis</a> for persistent visualization of a time-evolving
solution. The saving of time-dependent data files for external visualization
with <a href="https://visit.llnl.gov">VisIt</a> and <a href="https://www.paraview.org">ParaView</a> is also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex9.cpp">ex9.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex9p.cpp">ex9p.cpp</a>) version.
It also has a SUNDIALS modification in <a href="https://github.com/mfem/mfem/blob/master/examples/sundials">examples/sundials</a>
, a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>,
and a HiOp modification in <a href="https://github.com/mfem/mfem/blob/master/examples/hiop">examples/hiop</a>.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex10">
<h2 id="example-10-nonlinear-elasticity">Example 10: Nonlinear Elasticity</h2>
<p><img class="floatright" src="../img/examples/ex10.png"></p>
<p>This example solves a time dependent nonlinear elasticity problem of the form
$$ \frac{dv}{dt} = H(x) + S v\,,\qquad \frac{dx}{dt} = v\,, $$
where $H$ is a hyperelastic model and $S$ is a viscosity operator of
Laplacian type. The geometry of the domain is assumed to be as follows:</p>
<p><img alt="" src="../img/examples/ex10-domain.png" /></p>
<p>The example demonstrates the use of nonlinear operators, as well as their
implicit time integration using a Newton method for solving an associated
reduced backward-Euler type nonlinear equation. Each Newton step requires the
inversion of a Jacobian matrix, which is done through a (preconditioned) inner
solver.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex10.cpp">ex10.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex10p.cpp">ex10p.cpp</a>) version.
It also has a SUNDIALS modification in <a href="https://github.com/mfem/mfem/blob/master/examples/sundials">examples/sundials</a>
and a PETSc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>.
We recommend viewing examples 2 and 9 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex11">
<h2 id="example-11-laplace-eigenproblem">Example 11: Laplace Eigenproblem</h2>
<p><img class="floatright" src="../img/examples/ex11.png"></p>
<p>This example code demonstrates the use of MFEM to solve the eigenvalue problem
$$-\Delta u = \lambda u$$ with homogeneous Dirichlet boundary conditions.</p>
<p>We compute a number of the lowest eigenmodes by discretizing the Laplacian and
Mass operators using a finite element space of the specified order, or an
isoparametric/isogeometric space if order &lt; 1 (quadratic for quadratic
curvilinear mesh, NURBS for NURBS mesh, etc.)</p>
<p>The example highlights the use of the LOBPCG eigenvalue solver together with the
BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or
STRUMPACK parallel direct solvers. Reusing a single <a href="https://glvis.org">GLVis</a>
visualization window for multiple eigenfunctions is also illustrated.</p>
<p><em>The example has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/examples/ex11p.cpp">ex11p.cpp</a>) version.
It also has a SLEPc modification in <a href="https://github.com/mfem/mfem/blob/master/examples/petsc">examples/petsc</a>.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex12">
<h2 id="example-12-linear-elasticity-eigenproblem">Example 12: Linear Elasticity Eigenproblem</h2>
<p><img class="floatright" src="../img/examples/ex12.png"></p>
<p>This example code solves the linear elasticity eigenvalue
problem for a multi-material cantilever beam.
Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of
$$-{\rm div}({\sigma}({\bf u})) = \lambda {\bf u} \,,$$
where
$${\sigma}({\bf u}) = \lambda\, {\rm div}({\bf u})\,I + \mu\,(\nabla{\bf u} + \nabla{\bf u}^T)$$
is the stress tensor corresponding to displacement field $\bf u$, and $\lambda$ and $\mu$
are the material Lame constants. The boundary conditions are
${\bf u}=0$ on the fixed part of the boundary with attribute 1, and
${\sigma}({\bf u})\cdot n = f$ on the remainder.
The geometry of the domain is assumed to be as follows:</p>
<p><img alt="" src="../img/examples/ex12-domain.png" /></p>
<p>The example highlights the use of the LOBPCG eigenvalue solver together with the
BoomerAMG preconditioner in HYPRE.
Reusing a single <a href="https://glvis.org">GLVis</a> visualization window for multiple
eigenfunctions is also illustrated.</p>
<p><em>The example has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/examples/ex12p.cpp">ex12p.cpp</a>) version.
We recommend viewing examples 2 and 11 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex13">
<h2 id="example-13-maxwell-eigenproblem">Example 13: Maxwell Eigenproblem</h2>
<p><img class="floatright" src="../img/examples/ex13.png"></p>
<p>This example code solves the Maxwell (electromagnetic)
eigenvalue problem
$$\nabla\times\nabla\times\, E = \lambda\, E $$
with  homogeneous Dirichlet boundary conditions $E \times n = 0$.</p>
<p>We compute a number of the lowest nonzero eigenmodes by
discretizing the curl curl operator using a Nedelec finite element space of
the specified order in 2D or 3D.</p>
<p>The example highlights the use of the AME subspace eigenvalue
solver from HYPRE, which uses LOBPCG and AMS internally.
Reusing a single <a href="https://glvis.org">GLVis</a> visualization window for multiple
eigenfunctions is also illustrated.</p>
<p><em>The example has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/examples/ex13p.cpp">ex13p.cpp</a>) version.
We recommend viewing examples 3 and 11 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex14">
<h2 id="example-14-dg-diffusion">Example 14: DG Diffusion</h2>
<p><img class="floatright" src="../img/examples/ex14.png"></p>
<p>This example code demonstrates the use of MFEM to define a
discontinuous Galerkin (DG) finite element discretization of
the Laplace problem  $$-\Delta u = 1$$ with homogeneous Dirichlet
boundary conditions. Finite element spaces of any order,
including zero on regular grids, are supported. The example highlights the use
of discontinuous spaces and DG-specific face integrators.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex14.cpp">ex14.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex14p.cpp">ex14p.cpp</a>) version.
We recommend viewing examples 1 and 9 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex15">
<h2 id="example-15-dynamic-amr">Example 15: Dynamic AMR</h2>
<p><img class="floatright" src="../img/examples/ex15.png"></p>
<p>Building on <a href="#ex6">Example 6</a>, this example demonstrates dynamic adaptive mesh refinement.
The mesh is adapted to a time-dependent solution by refinement
as well as by derefinement. For simplicity, the solution is
prescribed and no time integration is done. However, the error
estimation and refinement/derefinement decisions are realistic.</p>
<p>At each outer iteration the right hand side function is changed
to mimic a time dependent problem.  Within each inner iteration
the problem is solved on a sequence of meshes which are locally
refined according to a simple ZZ error estimator.  At the end
of the inner iteration the error estimates are also used to
identify any elements which may be over-refined and a single
derefinement step is performed.  After each refinement or
derefinement step a rebalance operation is performed to keep
the mesh evenly distributed among the available processors.</p>
<p>The example demonstrates MFEM's capability to refine, derefine
and load balance nonconforming meshes, in 2D and 3D, and on
linear, curved and surface meshes. Interpolation of functions
between coarse and fine meshes, persistent <a href="https://glvis.org">GLVis</a> visualization,
and saving of time-dependent fields for external visualization
with <a href="https://visit.llnl.gov">VisIt</a> are also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex15.cpp">ex15.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex15p.cpp">ex15p.cpp</a>) version.
We recommend viewing examples 1, 6 and 9 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex16">
<h2 id="example-16-time-dependent-heat-conduction">Example 16: Time Dependent Heat Conduction</h2>
<p><img class="floatright" src="../img/examples/ex16.png"></p>
<p>This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem
$$\frac{du}{dt} = \nabla \cdot \left( \kappa + \alpha u \right) \nabla u$$
with a natural insulating boundary condition $\frac{du}{dn} = 0$.
We linearize the problem by using the temperature field $u$ from the previous time
step to compute the conductivity coefficient.</p>
<p>This example demonstrates both implicit and explicit time integration as well as a single
Picard step method for linearization. The saving of time dependent data files for external
visualization with <a href="https://visit.llnl.gov">VisIt</a> is also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex16.cpp">ex16.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex16p.cpp">ex16p.cpp</a>) version.
We recommend viewing examples 2, 9, and 10 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex17">
<h2 id="example-17-dg-linear-elasticity">Example 17: DG Linear Elasticity</h2>
<p><img class="floatright" src="../img/examples/ex17.png"></p>
<p>This example code solves a simple linear elasticity problem
describing a multi-material cantilever beam using symmetric or
non-symmetric discontinuous Galerkin (DG) formulation.</p>
<p>Specifically, we approximate the weak form of
$$-{\rm div}({\sigma}({\bf u})) = 0$$
where
$${\sigma}({\bf u}) = \lambda\, {\rm div}({\bf u})\,I + \mu\,(\nabla{\bf u} + \nabla{\bf u}^T)$$
is the stress tensor corresponding to displacement field ${\bf u}$, and $\lambda$ and $\mu$
are the material Lame constants. The boundary conditions are
Dirichlet, $\bf{u}=\bf{u_D}$, on the fixed part of the boundary, namely
boundary attributes 1 and 2; on the rest of the boundary we use
${\sigma}({\bf u})\cdot n = {\bf 0}$. The geometry of the domain is assumed to be
as follows:</p>
<p><img alt="" src="../img/examples/ex17-domain.png" /></p>
<p>The example demonstrates the use of high-order DG vector finite
element spaces with the linear DG elasticity bilinear form,
meshes with curved elements, and the definition of piece-wise
constant and function vector-coefficient objects. The use of
non-homogeneous Dirichlet b.c. imposed weakly, is also
illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex17.cpp">ex17.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex17p.cpp">ex17p.cpp</a>) version.
We recommend viewing examples 2 and 14 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex18">
<h2 id="example-18-dg-euler-equations">Example 18: DG Euler Equations</h2>
<p><img class="floatright" src="../img/examples/ex18.png"></p>
<p>This example code solves the compressible Euler system of equations, a model
nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The
primary purpose is to show how a transient system of nonlinear equations can be
formulated in MFEM. The equations are solved in conservative form</p>
<p>$$\frac{\partial u}{\partial t} + \nabla \cdot {\bf F}(u) = 0$$</p>
<p>with a state vector $u = [ \rho, \rho v_0, \rho v_1, \rho E ]$, where $\rho$ is
the density, $v_i$ is the velocity in the $i^{\rm th}$ direction, $E$ is the
total specific energy, and $H = E + p / \rho$ is the total specific enthalpy.
The pressure, $p$ is computed through a simple equation of state (EOS) call.
The conservative hydrodynamic flux ${\bf F}$ in each direction $i$ is</p>
<p>$${\bf F_{\it i}} = [ \rho v_i, \rho v_0 v_i + p \delta_{i,0}, \rho v_1 v_i + p \delta_{i,1}, \rho v_i H ]$$</p>
<p>Specifically, the example solves for an exact solution of the equations whereby
a vortex is transported by a uniform flow. Since all boundaries are periodic
here, the method's accuracy can be assessed by measuring the difference between
the solution and the initial condition at a later time when the vortex returns
to its initial location.</p>
<p>Note that as the order of the spatial discretization increases, the timestep
must become smaller. This example currently uses a simple estimate derived by
<a href="https://link.springer.com/article/10.1023/A:1012873910884">Cockburn and Shu</a>
for the 1D RKDG method. An additional factor can be tuned by passing the <code>--cfl</code>
(or <code>-c</code> shorter) flag.</p>
<p>The example demonstrates user-defined nonlinear form with hyperbolic form
integrator for systems of equations that are defined with block vectors,
and how these are used with an operator for explicit time integrators.
In this case the system also involves an external approximate Riemann
solver for the DG interface flux. It also demonstrates how to use GLVis
for in-situ visualization of vector grid functions.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex18.cpp">ex18.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex18p.cpp">ex18p.cpp</a>) version.
We recommend viewing examples 9, 14 and 17 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex19">
<h2 id="example-19-incompressible-nonlinear-elasticity">Example 19: Incompressible Nonlinear Elasticity</h2>
<p><img class="floatright" src="../img/examples/ex19.png"></p>
<p>This example code solves the quasi-static incompressible nonlinear
hyperelasticity equations. Specifically, it solves the nonlinear equation
$$
\nabla \cdot \sigma(F) = 0
$$
subject to the constraint
$$
\text{det } F = 1
$$
where $\sigma$ is the Cauchy stress and $F_{ij} = \delta_{ij} + u_{i,j}$ is the deformation
gradient. To handle the incompressibility constraint, pressure is included as
an independent unknown $p$ and the stress response is modeled as an <a href="http://solidmechanics.org/text/Chapter3_5/Chapter3_5.htm">incompressible
neo-Hookean hyperelastic solid</a>.
The geometry of the domain is assumed to be as follows:</p>
<p><img alt="" src="../img/examples/ex19-domain.png" /></p>
<p>This formulation requires solving the saddle point system
$$ \left[ \begin{array}{cc}
   K &amp;B^T \\
   B &amp; 0
\end{array} \right]
\left[\begin{array}{c} \Delta u \\ \Delta p \end{array} \right] =
\left[\begin{array}{c} R_u \\ R_p \end{array} \right]
$$
at each Newton step. To solve this linear system, we implement a specialized block
preconditioner of the form
$$
P^{-1} =
\left[\begin{array}{cc} I &amp; -\tilde{K}^{-1}B^T \\ 0 &amp; I \end{array} \right]
\left[\begin{array}{cc} \tilde{K}^{-1} &amp; 0 \\ 0 &amp; -\gamma \tilde{S}^{-1} \end{array} \right]
$$
where $\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and
$\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$.
To approximate the Schur complement, we use the mass matrix for the pressure variable $p$.</p>
<p>The example demonstrates how to solve nonlinear systems of equations that are defined with
block vectors as well as how to implement specialized block preconditioners for use in
iterative solvers.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex19.cpp">ex19.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex19p.cpp">ex19p.cpp</a>) version.
We recommend viewing examples 2, 5 and 10 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex20">
<h2 id="example-20-symplectic-integration-of-hamiltonian-systems">Example 20: Symplectic Integration of Hamiltonian Systems</h2>
<p><img class="floatright" src="../img/examples/ex20.png"></p>
<p>This example demonstrates the use of the variable order, symplectic time
integration algorithm. Symplectic integration algorithms are designed to
conserve energy when integrating systems of ODEs which are derived from
Hamiltonian systems.</p>
<p>Hamiltonian systems define the energy of a system as a function of
time (t), a set of generalized coordinates (q), and their corresponding
generalized momenta (p).
$$
H(q,p,t) = T(p) + V(q,t)
$$
Hamilton's equations then specify how q and p evolve in time:
$$
\frac{dq}{dt} =  \frac{dH}{dp}\,,\qquad
\frac{dp}{dt} = -\frac{dH}{dq}
$$</p>
<p>To use the symplectic integration classes we need to define an <code>mfem::Operator</code>
${\bf P}$ which evaluates the action of dH/dp, and an
<code>mfem::TimeDependentOperator</code> ${\bf F}$ which computes -dH/dq.</p>
<p>This example visualizes its results as an evolution in phase space by defining
the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$.  In this space
we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we
plot the energy as a function of time as a scalar field on this ribbon-like
mesh.  This scheme highlights any variations in the energy of the system.</p>
<p>This example offers five simple 1D Hamiltonians:</p>
<ul>
<li>Simple Harmonic Oscillator (mass on a spring)
  $$H = \frac{1}{2}\left( \frac{p^2}{m} + \frac{q^2}{k} \right)$$</li>
<li>Pendulum
  $$H = \frac{1}{2}\left[ \frac{p^2}{m} - k \left( 1 - cos(q) \right) \right]$$</li>
<li>Gaussian Potential Well
  $$H = \frac{p^2}{2m} - k e^{-q^2 / 2}$$</li>
<li>Quartic Potential
  $$H = \frac{1}{2}\left[ \frac{p^2}{m} + k \left( 1 + q^2 \right) q^2 \right]$$</li>
<li>Negative Quartic Potential
  $$H = \frac{1}{2}\left[ \frac{p^2}{m} + k \left( 1 - \frac{q^2}{8} \right) q^2 \right]$$</li>
</ul>
<p>In all cases these Hamiltonians are shifted by constant values so that the
energy will remain positive. The mean and standard deviation of the computed
energies at each time step are displayed upon completion.</p>
<p>When run in parallel, each processor integrates the same Hamiltonian
system but starting from different initial conditions.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex20.cpp">ex20.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex20p.cpp">ex20p.cpp</a>) version.
See the <a href="#maxwell-miniapp-transient-full-wave-electromagnetics">Maxwell</a> miniapp for another
application of symplectic integration.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex21">
<h2 id="example-21-adaptive-mesh-refinement-for-linear-elasticity">Example 21: Adaptive mesh refinement for linear elasticity</h2>
<p><img class="floatright" src="../img/examples/ex21.png"></p>
<p>This is a version of Example 2 with a simple adaptive mesh
refinement loop. The problem being solved is again linear
elasticity describing a multi-material cantilever beam.
The problem is solved on a sequence of meshes which
are locally refined in a conforming (triangles, tetrahedrons)
or non-conforming (quadrilaterals, hexahedra) manner according
to a simple ZZ error estimator.</p>
<p>The example demonstrates MFEM's capability to work with both
conforming and nonconforming refinements, in 2D and 3D, on
linear and curved meshes. Interpolation of functions from
coarse to fine meshes, as well as persistent GLVis
visualization are also illustrated.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex21.cpp">ex21.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex21p.cpp">ex21p.cpp</a>) version.
We recommend viewing Examples 2 and 6 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex22">
<h2 id="example-22-complex-linear-systems">Example 22: Complex Linear Systems</h2>
<p><img class="floatright" src="../img/examples/ex22.gif"></p>
<p>This example code demonstrates the use of MFEM to define and
solve a complex-valued linear system. It implements three variants
of a damped harmonic oscillator:</p>
<ul>
<li>
<p>A scalar $H^1$ field:
  $$-\nabla\cdot\left(a \nabla u\right) - \omega^2 b\,u + i\,\omega\,c\,u = 0$$</p>
</li>
<li>
<p>A vector $H(curl)$ field:
  $$\nabla\times\left(a\nabla\times\vec{u}\right) - \omega^2 b\,\vec{u} + i\,\omega\,c\,\vec{u} = 0$$</p>
</li>
<li>
<p>A vector $H(div)$ field:
  $$-\nabla\left(a \nabla\cdot\vec{u}\right) - \omega^2 b\,\vec{u} + i\,\omega\,c\,\vec{u} = 0$$</p>
</li>
</ul>
<p>In each case the field is driven by a forced oscillation, with
angular frequency $\omega$, imposed at the boundary or a portion
of the boundary.</p>
<p>The example also demonstrates how to display a time-varying solution as
a sequence of fields sent to a single GLVis socket.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex22.cpp">ex22.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex22p.cpp">ex22p.cpp</a>) version.
We recommend viewing examples 1, 3, and 4 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex23">
<h2 id="example-23-wave-problem">Example 23: Wave Problem</h2>
<p><img class="floatright" src="../img/examples/ex23.png"></p>
<p>This example code solves a simple 2D/3D  wave
equation with a second order time derivative:
$$\frac{\partial^2 u}{\partial t^2} - c^2\Delta u = 0$$
The boundary conditions are either Dirichlet or Neumann.</p>
<p>The example demonstrates the use of time dependent operators,
implicit solvers and second order time integration.</p>
<p><em>The example has only a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex23.cpp">ex23.cpp</a>) version.
We recommend viewing examples 9 and 10 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex24">
<h2 id="example-24-mixed-finite-element-spaces">Example 24: Mixed finite element spaces</h2>
<p><img class="floatright" src="../img/examples/ex24.png"></p>
<p>This example code illustrates usage of mixed finite element
spaces, with three variants:</p>
<ul>
<li>$H^1 \times H(curl)$</li>
<li>$H(curl) \times H(div)$</li>
<li>$H(div) \times L_2$</li>
</ul>
<p>Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or
divergence in the appropriate spaces, comparing the errors in each case.</p>
<p>Partial assembly and <a href="../gpu-support/">GPU devices</a> are supported.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex24.cpp">ex24.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex24p.cpp">ex24p.cpp</a>) version.
We recommend viewing examples 1 and 3 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex25">
<h2 id="example-25-perfectly-matched-layers">Example 25: Perfectly Matched Layers</h2>
<p><img class="floatright" src="../img/examples/ex25.gif"></p>
<p>The example illustrates the use of a Perfectly Matched Layer (PML) for the
simulation of time-harmonic electromagnetic waves propagating in unbounded
domains.</p>
<p>PML was originally introduced by Berenger in <a href="https://doi.org/10.1006/jcph.1994.1159">"A Perfectly Matched Layer for the
Absorption of Electromagnetic Waves"</a>.
It is a technique used to solve wave propagation problems posed in infinite
domains. The implementation involves the introduction of an artificial absorbing
layer that minimizes undesired reflections. Inside this layer a complex
coordinate stretching map is used which forces the wave modes to decay
exponentially.</p>
<p>The example solves the indefinite Maxwell equations
$$\nabla \times (a \nabla \times E) - \omega^2 b E = f.$$
where $a = \mu^{-1} |J|^{-1} J^T J$, $b= \epsilon |J| J^{-1} J^{-T}$ and $J$ is
the Jacobian matrix of the coordinate transformation.</p>
<p>The example demonstrates discretization with Nedelec finite elements in 2D or
3D, as well as the use of complex-valued bilinear and linear forms. Several
test problems are included, with known exact solutions.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex25.cpp">ex25.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex25p.cpp">ex25p.cpp</a>) version.
We recommend viewing Example 22 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex26">
<h2 id="example-26-multigrid-preconditioner">Example 26: Multigrid Preconditioner</h2>
<p><img class="floatright" src="../img/examples/ex26.png"></p>
<p>This example code demonstrates the use of MFEM to define a
simple isoparametric finite element discretization of the
Laplace problem $$-\Delta u = 1$$ with homogeneous Dirichlet
boundary conditions and how to solve it efficiently using a
matrix-free multigrid preconditioner.</p>
<p>The example highlights on the creation of a hierarchy of
discretization spaces and diffusion bilinear forms using
partial assembly. The levels in the hierarchy of finite
element spaces maybe constructed through geometric or
order refinements. Moreover, the construction of a multigrid
preconditioner for the PCG solver is shown. The multigrid
uses a PCG solver on the coarsest level and second order
Chebyshev accelerated smoothers on the other levels.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex26.cpp">ex26.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex26p.cpp">ex26p.cpp</a>) version.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex27">
<h2 id="example-27-laplace-boundary-conditions">Example 27: Laplace Boundary Conditions</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex27.saved" target="_blank">
<img class="floatright" src="../img/examples/ex27.png">
</a></p>
<p>This example code demonstrates the use of MFEM to define a
simple finite element discretization of the Laplace problem:
$$
-\Delta u = 0
$$
with a variety of boundary conditions.</p>
<p>Specifically, we discretize
using a FE space of the specified order using a continuous or
discontinuous space.  We then apply Dirichlet, Neumann (both
homogeneous and inhomogeneous), Robin, and Periodic boundary
conditions on different portions of a predefined mesh.</p>
<table>
<thead>
<tr>
<th>Boundary conditions:</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>$u = u_{dbc}$</td>
<td>on $\Gamma_{dbc}$</td>
</tr>
<tr>
<td>$\hat{n}\cdot\nabla u = g_{nbc}$</td>
<td>on $\Gamma_{nbc}$</td>
</tr>
<tr>
<td>$\hat{n}\cdot\nabla u = 0$</td>
<td>on $\Gamma_{nbc_0}$</td>
</tr>
<tr>
<td>$\hat{n}\cdot\nabla u + a u = b$</td>
<td>on $\Gamma_{rbc}$</td>
</tr>
</tbody>
</table>
<p>as well as periodic boundary conditions which are enforced topologically.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex27.cpp">ex27.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex27p.cpp">ex27p.cpp</a>) version.
We recommend viewing examples 1 and 14 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex28">
<h2 id="example-28-constraints-and-sliding-boundary-conditions">Example 28: Constraints and Sliding Boundary Conditions</h2>
<p><img class="floatright" src="../img/examples/ex28.png"></p>
<p>This example code illustrates the use of constraints in linear solvers by
solving an elasticity problem where the normal component of the displacement
is constrained to zero on two boundaries but tangential displacement is
allowed.</p>
<p>The constraints can be enforced in several different ways, including
eliminating them from the linear system or solving a saddle-point
system that explicitly includes constraint conditions.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex28.cpp">ex28.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex28p.cpp">ex28p.cpp</a>) version.
We recommend viewing example 2 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex29">
<h2 id="example-29-solving-pdes-on-embedded-surfaces">Example 29: Solving PDEs on embedded surfaces</h2>
<p><img class="floatright" src="../img/examples/ex29.png"></p>
<p>This example demonstrates setting up and solving an anisotropic Laplace problem
$$-\nabla\cdot(\sigma\nabla u) = 1 \quad\text{in } \Omega$$
with homogeneous Dirichlet boundary conditions
$$ u = 0 \quad\text{on } \partial\Omega$$
where $\Omega$ is a two dimensional curved surface embedded in three
dimensions and $\sigma$ is an anisotropic diffusion tensor.</p>
<p>The example demonstrates and validates our <code>DiffusionIntegrator</code>'s ability to
properly integrate three dimensional fluxes on a two dimensional domain. Not
all of our integrators currently support such cases but the
<code>DiffusionIntegrator</code> can be used as a simple example of how extend other
integrators when necessary.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex29.cpp">ex29.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex29p.cpp">ex29p.cpp</a>) version.
We recommend viewing examples 1 and 7 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex30">
<h2 id="example-30-resolving-rough-and-fine-scale-problem-data">Example 30: Resolving rough and fine-scale problem data</h2>
<p><img class="floatright" src="../img/examples/ex30.png"></p>
<p>Unresolved problem data will affect the accuracy of a discretized PDE solution as
well as a posteriori estimates of the solution error.
This example uses a <code>CoefficientRefiner</code> object to preprocess an input mesh until
the resolution of the prescribed problem data $f \in L^2$ is below a prescribed
tolerance. In this example, the resolution is identified with a data oscillation
function on the mesh $\mathcal{T}$, defined
$$ \mathrm{osc}(f) = \Big( \sum_{T\in\mathcal{T}} \| h \cdot (I - \Pi)\, f \|^2_{L^2(T)} \Big)^{1/2}, $$
where $h$ is the local element size function and $\Pi$ is a finite element projection
operator, and the sum is taken over all elements $T$ in the mesh.</p>
<p>In this example, the coarse initial mesh is adaptively refined until $\mathrm{osc}(f)$ is below a
prescribed tolerance for various candidate functions $f \in L^2$. When using rough problem data,
it is recommended to perform this type of preprocessing before a posteriori error estimation.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex30.cpp">ex30.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex30p.cpp">ex30p.cpp</a>) version.
We recommend viewing examples 1 and 6 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex31">
<h2 id="example-31-anisotropic-definite-maxwell-problem">Example 31: Anisotropic Definite Maxwell Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex31.saved" target="_blank">
<img class="floatright" src="../img/examples/ex31.png">
</a></p>
<p>This example code solves a simple electromagnetic diffusion
problem corresponding to the second order definite Maxwell
equation $$\nabla\times\nabla\times\, E + \sigma E = f$$
with boundary condition $ E \times n $ = "given tangential field".
In this example $\sigma$ is an anisotropic 3x3 tensor. Here, we use a
given exact solution $E$ and compute the corresponding r.h.s.
$f$. We discretize with Nedelec finite elements in 1D, 2D, or 3D.</p>
<p>The example demonstrates the use of restricted $H(curl)$ finite element
spaces with the curl-curl and the (vector finite element) mass
bilinear form, as well as the computation of discretization
error when the exact solution is known. These restricted spaces allow
the solution of 1D or 2D electromagnetic problems which involve 3D
field vectors. Such problems arise in plasma physics and crystallography.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex31.cpp">ex31.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex31p.cpp">ex31p.cpp</a>) version.
We recommend viewing example 3 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex32">
<h2 id="example-32-anisotropic-maxwell-eigenproblem">Example 32: Anisotropic Maxwell Eigenproblem</h2>
<p><img class="floatright" src="../img/examples/ex32.png"></p>
<p>This example code solves the Maxwell (electromagnetic)
eigenvalue problem with anisotropic permittivity, $\epsilon$
$$\nabla\times\nabla\times\, E = \lambda\, \epsilon E $$
with  homogeneous Dirichlet boundary conditions $E \times n = 0$.</p>
<p>We compute a number of the lowest nonzero eigenmodes by
discretizing the curl curl operator using a Nedelec finite element space of
the specified order in 1D, 2D, or 3D.</p>
<p>The example demonstrates the use of restricted $H(curl)$ finite element
spaces in an eigenmode context. These restricted spaces allow
the solution of 1D or 2D electromagnetic problems which involve 3D
field vectors. Such problems arise in plasma physics and crystallography.
The example highlights the use of the AME subspace eigenvalue
solver from HYPRE, which uses LOBPCG and AMS internally.
Reusing multiple <a href="https://glvis.org">GLVis</a> visualization windows for multiple
eigenfunctions is also illustrated.</p>
<p><em>The example has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/examples/ex32p.cpp">ex32p.cpp</a>) version.
We recommend viewing examples 13 and 31 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex33">
<h2 id="example-33-spectral-fractional-laplacian">Example 33: Spectral fractional Laplacian</h2>
<p><img class="floatright" width="280pt" src="../img/examples/ex33.png"></p>
<p>This example code demonstrates the use of MFEM to solve the fractional Laplacian problem
$$ (-\Delta)^\alpha u = 1, \quad \alpha &gt; 0, $$
with homogeneous Dirichlet boundary conditions. The problem solved in this example is similar to
<a href="#ex1">ex1</a>, but involves a fractional-order diffusion operator whose inverse can be approximated
by a series of inverses of integer-order diffusion operators. Solving each of these independent
integer-order PDEs with MFEM and summing their solutions results in a discrete solution to the
fractional Laplacian problem above.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex33.cpp">ex33.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex33p.cpp">ex33p.cpp</a>) version.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex34">
<h2 id="example-34-source-function-using-a-submesh-transfer">Example 34: Source Function using a SubMesh Transfer</h2>
<p><img class="floatright" width="500pt" src="../img/examples/ex34.png"></p>
<p>This example demonstrates the use of a SubMesh object to transfer solution
data from a sub-domain and use this as a source function on the full domain.
In this case we compute a volumetric current density $\vec{J}$ as the gradient
of a scalar potential $\varphi$ on a portion of the domain.</p>
<p>$$\nabla\cdot(\sigma\nabla\varphi)=0$$
$$\vec{J} = -\sigma\nabla\varphi$$</p>
<p>Where a voltage difference is applied on surfaces of the sub-domain (shown on
the left) to generate the current density restricted to this sub-domain. The
current density is then transferred to the full domain (shown on the right)
using a SubMesh object.</p>
<p>We then use this current density on the full domain as a source term in a
magnetostatic solve for a vector potential $\vec{A}$.</p>
<p>$$\nabla\times(\mu^{-1}\nabla\times\vec{A})=\vec{J}$$
$$\vec{B} = \nabla\times\vec{A}$$</p>
<p>This example verifies the recreation of boundary attributes on a sub-domain
mesh as well as transfer of Raviart-Thomas vector fields between the SubMesh
and the full Mesh. Note that the data transfer in this particular example
involves arbitrary order Raviart-Thomas degrees of freedom on a mixture of
tetrahedral and triangular prism elements.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex34.cpp">ex34.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex34p.cpp">ex34p.cpp</a>) version.
We recommend viewing Examples 1 and 3 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex35">
<h2 id="example-35-port-boundary-conditions-using-submesh-transfers">Example 35: Port Boundary Conditions using SubMesh Transfers</h2>
<p><img class="floatright" width="500pt" src="../img/examples/ex35p1.gif"></p>
<p>This example demonstrates the use of a SubMesh object to transfer a <code>port
boundary condition</code> from a portion of the boundary to the corresponding portion
of the full domain.</p>
<p>Just as in Example 22 this example implements three variants of a damped
harmonic oscillator:</p>
<ul>
<li>
<p>A scalar $H^1$ field:
  $$-\nabla\cdot\left(a \nabla u\right) - \omega^2 b\,u + i\,\omega\,c\,u = 0\mbox{ with }u|_\Gamma=v$$</p>
</li>
<li>
<p>A vector $H(curl)$ field:
  $$\nabla\times\left(a\nabla\times\vec{u}\right) - \omega^2 b\,\vec{u} + i\,\omega\,c\,\vec{u} = 0\mbox{ with }\hat{n}\times(\vec{u}\times\hat{n})|_\Gamma=\vec{v}$$</p>
</li>
<li>
<p>A vector $H(div)$ field:
  $$-\nabla\left(a \nabla\cdot\vec{u}\right) - \omega^2 b\,\vec{u} + i\,\omega\,c\,\vec{u} = 0\mbox{ with }\hat{n}\cdot\vec{u}|_\Gamma=v$$</p>
</li>
</ul>
<p>Where $\Gamma$ is a portion of the boundary called the <code>port</code>. In each case the
field is driven by a forced oscillation, with angular frequency $\omega$,
imposed at the boundary or a portion of the boundary.
<img class="floatright" width="500pt" src="../img/examples/ex35p2.gif">
In Example 22 this boundary condition was simply a constant in space. In this
example the boundary condition is an eigenmode of a lower dimensional
eigenvalue problem defined on a portion of the boundary as follows:</p>
<ul>
<li>
<p>For the scalar $H^1$ field:
  $$-\nabla\cdot\left(\nabla v\right) = \lambda\,v\mbox{ with }v|_{\partial\Gamma}=0$$</p>
</li>
<li>
<p>For the vector $H(curl)$ field:
  $$\nabla\times\left(\nabla\times\vec{v}\right) = \lambda\,\vec{v}\mbox{ with }\hat{n}_{\partial\Gamma}\times\vec{v}|_{\partial\Gamma}=0$$</p>
</li>
<li>
<p>For the vector $H(div)$ field:
  $$-\nabla\cdot\left(\nabla v\right) = \lambda\,v\mbox{ with }\hat{n}_{\partial\Gamma}\cdot\nabla v|_{\partial\Gamma}=0$$</p>
</li>
</ul>
<p>The different cases implemented in this example can be used to verify the
transfer of an $H^1$ scalar field, the tangential components of an $H(curl)$
vector field, and the normal component of an $H(div)$ vector field (as a scalar
$L^2$ field in this case) between a SubMesh and its parent mesh.</p>
<p><em>The example has only a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex35p.cpp">ex35p.cpp</a>)
version because the eigenmode solver used to compute the field on the port is
only implemented in parallel. We recommend viewing Examples 11, 13, and 22
before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex36">
<h2 id="example-36-obstacle-problem">Example 36: Obstacle Problem</h2>
<p><img class="floatright" width="280pt" src="../img/examples/ex36.png"></p>
<p>This example code solves the pointwise bound-constrained energy minimization problem
$$ \text{minimize } \frac{1}{2}\|\nabla u\|^2 \text{ in } H^1_0(\Omega)\, \text{ subject to } u \ge \varphi\,.$$
This is known as the obstacle problem, and it is a classical motivating example in the
study of variational inequalities and free boundary problems. In this example, the obstacle $\varphi$
is the graph of a half-sphere centered at the origin of a circular domain $\Omega$. After solving to
a specified tolerance, the numerical solution is compared to a closed-form exact solution to assess
its accuracy.</p>
<p>The problem is solved using the Proximal Galerkin finite element method, which is a nonlinear,
structure-preserving mixed method for pointwise bound constraints proposed by
<a href="https://arxiv.org/abs/2307.12444">Keith and Surowiec</a>. In turn, this example highlights
MFEM's ability to deliver high-order solutions to variational inequalities and showcases how to
set up and solve nonlinear mixed methods.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex36.cpp">ex36.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex36p.cpp">ex36p.cpp</a>) version.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex37">
<h2 id="example-37-topology-optimization">Example 37: Topology Optimization</h2>
<p><div class="parent" style="float:right">
  <center> Density field $\rho$ <center>
  <img class="img" width="280pt" src="../img/examples/ex37a.gif">
  <center> Problem set-up and domain $\Omega$ <center>
  <img class="img" width="300pt" src="../img/examples/ex37b.png">
</div></p>
<p>This example code solves a classical cantilever beam topology optimization problem.
The aim is to find an optimal material density field $\rho$ in $L^1(\Omega)$ to minimize the elastic compliance; i.e.,
$$\begin{align}
  &amp;\text{minimize} \int_\Omega \mathbf{f} \cdot \mathbf{u}(\rho)\, \mathrm{d}x\,
  \text{ over }\, \rho \in L^1(\Omega)
  \\
  &amp;\text{subject to }\, 0 \leq \rho \leq 1\, \text{ and } \int_\Omega \rho\, \mathrm{d}x = \theta\, \mathrm{vol}(\Omega) \,.
\end{align}$$
In this problem, $\mathbf{f}$ is a localized force and the linearly elastic displacement field $\mathbf{u} = \mathbf{u}(\rho)$ is determined by a material density field $\rho$ with total volume fraction $0&lt;\theta&lt;1$.</p>
<p>The problem is solved using a mirror descent algorithm proposed by <a href="https://arxiv.org/abs/2307.12444">Keith and Surowiec</a>.
For further details, see the more elaborate description of this PDE-constrained optimization problem given in the example code and the aforementioned paper.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex37.cpp">ex37.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex37p.cpp">ex37p.cpp</a>) version.
We recommend viewing Example 2 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex38">
<h2 id="example-38-cut-volume-and-cut-surface-integration">Example 38: Cut-Volume and Cut-Surface Integration</h2>
<p><img class="floatright" width="285pt" src="../img/examples/ex38.png"></p>
<p>This example code demonstrates construction of cut-surface and cut-volume IntegrationRules.
The cut is specified by the zero level set of a given Coefficient $\phi$.
The resulting IntegrationRules are combined with standard LinearFormIntegrators to demonstrate
integration of a function $u$ over an implicit interface, and a subdomain bounded by an implicit interface:
$$ S = \int_{\phi = 0} u(x) ~ ds, \quad V = \int_{\phi &gt; 0} u(x) ~ dx. $$</p>
<p>The IntegrationRules are constructed by the moment-fitting algorithm introduced by
<a href="https://doi.org/10.1002/nme.4569">MÃ¼ller, Kummer and Oberlack</a>. Through a set of basis functions,
for each element the method defines and solves a local under-determined system for the vector of quadrature weights.
All surface and volume integrals, which are required to form the system, are reduced to 1D integration over intersected segments.</p>
<p><em>The example has only a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex38.cpp">ex38.cpp</a>)
version, because the  construction of the integration rules is an element-local procedure.
It requires MFEM to be built with LAPACK, which is used to find the optimal solution of an under-determined system of equations.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex39">
<h2 id="example-39-named-attribute-sets">Example 39: Named Attribute Sets</h2>
<p><img class="floatright" width="285pt" src="../img/examples/ex39.png">
<img class="floatright" width="240pt" src="../img/compass.png"></p>
<p>This example uses the Poisson equation to demonstrate the use of named attribute sets in MFEM to specify material regions, boundary regions, or source regions by name rather than attribute numbers.
It also demonstrates how new named attribute sets may be created from arbitrary groupings of attribute numbers and used as a convenient shorthand to refer to those groupings in other portions of the application or through the command line.</p>
<p>Named attribute sets also required changes to MFEM's mesh file formats.
This example makes use of a custom input mesh file (<a href="https://github.com/mfem/mfem/blob/master/data/compass.msh">compass.msh</a>) produced using Gmsh which includes named regions and boundaries.
A related mesh file (<a href="https://github.com/mfem/mfem/blob/master/data/compass.mesh">compass.mesh</a>) illustrates MFEM's representation of the new named attribute sets.
See <a href="../mesh-format-v1.0/">file formats</a> for details of the augmented mesh file format.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex39.cpp">ex39.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex39p.cpp">ex39p.cpp</a>) version.
We recommend viewing Example 1 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="ex40">
<h2 id="example-40-eikonal-equation">Example 40: Eikonal Equation</h2>
<p><img class="floatright" width="280pt" src="../img/examples/ex40.png"></p>
<p>This example highlights MFEM's ability to solve a fully-nonlinear, first-order PDE with high-order finite elements.
In particular this example uses the <a href="https://arxiv.org/abs/2307.12444">proximal Galerkin</a> method to solve the eikonal equation,
$$ |\nabla u| = 1 \text{ in } \Omega,  \quad u = 0 \text{ on } \partial \Omega. $$
At each point $x$ in the domain $\Omega$, the solution of this PDE provides the Euclidean distance to the domain boundary, $u(x) = \min \{ | x - y| : y \in \partial \Omega\}$.
The problem is solved by recasting $u$ as the solution of the nonlinear program
$$ \text{maximize } \int_\Omega u\, \mathrm{d} x\, \text{ in } W^{1,\infty}_0(\Omega)\, \text{ subject to } |\nabla u | \leq 1 \text{ a.e. in } \Omega.$$
A solution is then obtained by discretizing and solving a sequence of nonlinear saddle-point problems.
See the example code for a more detailed description of the method.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/examples/ex40.cpp">ex40.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/examples/ex40p.cpp">ex40p.cpp</a>) version.
We recommend viewing Example 5 and Example 36 before viewing this example.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="nurbs_ex1">
<h2 id="nurbs-example-1-laplace-problem">NURBS Example 1: Laplace Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex1.saved" target="_blank">
<img class="floatright" src="../img/examples/ex1.png">
</a></p>
<p>This example code demonstrates the use of MFEM to define a simple isogeometric NURBS discretization of
the Laplace problem $$-\Delta u = 1$$ with
homogeneous Dirichlet boundary conditions. The problem solved in
this example is the same as <a href="#ex1">Example 1</a>.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex1.cpp">nurbs_ex1.cpp</a>)
and a parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex1p.cpp">nurbs_ex1p.cpp</a>) version.
There is also a version that demonstrates efficient patchwise quadrature
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_patch_ex1.cpp">nurbs_ex1 patch.cpp</a>).</em>
<div style="clear:both;"></div>
<br></p>
</div>
<div id="nurbs_ex3">
<h2 id="nurbs-example-3-definite-maxwell-problem">NURBS Example 3: Definite Maxwell Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex3.saved" target="_blank">
<img class="floatright" src="../img/examples/ex3.png">
</a></p>
<p>This example code solves a simple electromagnetic diffusion
problem corresponding to the second order definite Maxwell
equation $$\nabla\times\nabla\times\, E + E = f$$
with boundary condition $ E \times n $ = "given tangential field".
Here, we use a given exact solution $E$ and compute the corresponding r.h.s.
$f$. We discretize with NURBS-based $H(curl)$elements in 2D or 3D.
The problem solved in this example is the same as <a href="#ex3">Ezample 3</a>.</p>
<p><em>The example has only a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex3.cpp">nurbs_ex1.cpp</a>) version.</em>
<div style="clear:both;"></div>
<br></p>
</div>
<div id="nurbs_ex5">
<h2 id="nurbs-example-5-darcy-problem">NURBS Example 5: Darcy Problem</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/ex5.saved" target="_blank">
<img class="floatright" src="../img/examples/ex5.png">
</a></p>
<p>This example code solves a simple 2D/3D mixed Darcy problem
corresponding to the saddle point system
$$ \begin{array}{rcl}
   k\,{\bf u} + {\rm grad}\,p &amp;=&amp; f \\
   -{\rm div}\,{\bf u} &amp;=&amp; g
\end{array} $$
with natural boundary condition $-p = $ "given pressure".
Here we use a given exact solution $({\bf u},p)$ and compute the
corresponding right hand side $(f, g)$. We discretize  the velocity ($\bf u$) with NURBS-based $H(div)$ elements and
 the pressure ($p$) with a compatible NURBS-based $H_1$ elements.
The problem solved in this example is the same as <a href="#ex5">Example 5</a>.</p>
<p><em>The example only has a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex5.cpp">nurbs_ex5.cpp</a>).</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="nurbs_ex11">
<h2 id="nurbs-example-11-laplace-eigenproblem">NURBS Example 11: Laplace Eigenproblem</h2>
<p><img class="floatright" src="../img/examples/ex11.png"></p>
<p>This example code demonstrates the use of MFEM to solve the eigenvalue problem
$$-\Delta u = \lambda u$$ with homogeneous Dirichlet boundary conditions.</p>
<p>We compute a number of the lowest eigenmodes by discretizing the Laplacian and
Mass operators using a finite element space of the specified order, or an
isoparametric/isogeometric space if order &lt; 1 (quadratic for quadratic
curvilinear mesh, NURBS for NURBS mesh, etc.)</p>
<p>The example highlights the use of the LOBPCG eigenvalue solver together with the
BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or
STRUMPACK parallel direct solvers. Reusing a single <a href="https://glvis.org">GLVis</a>
visualization window for multiple eigenfunctions is also illustrated.</p>
<p>The problem solved in this example is the same as <a href="#ex11">Example 11</a>.</p>
<p><em>The example has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex11p.cpp">nurbs_ex11p.cpp</a>) version.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="nurbs_ex24">
<h2 id="nurbs-example-24-mixed-finite-element-spaces">NURBS Example 24: Mixed finite element spaces</h2>
<p><img class="floatright" src="../img/examples/ex24.png"></p>
<p>The problem solved in this example is the same as <a href="#ex24">Example 24</a>, but NURBS-based elements are also supported.</p>
<p>This example code illustrates usage of mixed finite element
spaces, with three variants:</p>
<ul>
<li>$H^1 \times H(curl)$</li>
<li>$H(curl) \times H(div)$</li>
<li>$H(div) \times L_2$</li>
</ul>
<p>Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or
divergence in the appropriate spaces, comparing the errors in each case.</p>
<p><em>The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/nurbs/nurbs_ex24.cpp">nurbs_ex24.cpp</a>).</em></p>
<div id="volta">
<h2 id="volta-miniapp-electrostatics">Volta Miniapp: Electrostatics</h2>
<p><img class="floatright" src="../img/examples/volta.png"></p>
<p>This miniapp demonstrates the use of MFEM to solve realistic problems
in the field of linear electrostatics.  Its features include:</p>
<ul>
<li>dielectric materials</li>
<li>charge densities</li>
<li>surface charge densities</li>
<li>prescribed voltages</li>
<li>applied polarizations</li>
<li>high order meshes</li>
<li>high order basis functions</li>
<li>adaptive mesh refinement</li>
<li>advanced visualization</li>
</ul>
<p>For more details, please see the <a href="../electromagnetics/">documentation</a> in the
<code>miniapps/electromagnetics</code> dire</p>
</div>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/electromagnetics/volta.cpp">volta.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="tesla">
<h2 id="tesla-miniapp-magnetostatics">Tesla Miniapp: Magnetostatics</h2>
<p><img class="floatright" src="../img/examples/tesla.png"></p>
<p>This miniapp showcases many of MFEM's features while solving a variety
of realistic magnetostatics problems.  Its features include:</p>
<ul>
<li>diamagnetic and/or paramagnetic materials</li>
<li>ferromagnetic materials</li>
<li>volumetric current densities</li>
<li>surface current densities</li>
<li>external fields</li>
<li>high order meshes</li>
<li>high order basis functions</li>
<li>adaptive mesh refinement</li>
<li>advanced visualization</li>
</ul>
<p>For more details, please see the <a href="../electromagnetics/">documentation</a> in the
<code>miniapps/electromagnetics</code> dire</p>
</div>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/electromagnetics/tesla.cpp">tesla.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="maxwell">
<h2 id="maxwell-miniapp-transient-full-wave-electromagnetics">Maxwell Miniapp: Transient Full-Wave Electromagnetics</h2>
<p><img class="floatright" src="../img/examples/maxwell.png"></p>
<p>This miniapp solves the equations of transient full-wave electromagnetics.</p>
<p>Its features include:</p>
<ul>
<li>mixed formulation of the coupled first-order Maxwell equations</li>
<li>$H(\mathrm{curl})$ discretization of the electric field</li>
<li>$H(\mathrm{div})$ discretization of the magnetic flux</li>
<li>energy conserving, variable order, implicit time integration</li>
<li>dielectric materials</li>
<li>diamagnetic and/or paramagnetic materials</li>
<li>conductive materials</li>
<li>volumetric current densities</li>
<li>Sommerfeld absorbing boundary conditions</li>
<li>high order meshes</li>
<li>high order basis functions</li>
<li>advanced visualization</li>
</ul>
<p>For more details, please see the <a href="../electromagnetics/">documentation</a> in the
<code>miniapps/electromagnetics</code> dire</p>
</div>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/electromagnetics/maxwell.cpp">maxwell.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="joule">
<h2 id="joule-miniapp-transient-magnetics-and-joule-heating">Joule Miniapp: Transient Magnetics and Joule Heating</h2>
<p><img class="floatright" src="../img/examples/joule.png" ></p>
<p>This miniapp solves the equations of transient low-frequency (a.k.a. eddy current)
electromagnetics, and simultaneously computes transient heat transfer with the heat source given
by the electromagnetic Joule heating.</p>
<p>Its features include:</p>
<ul>
<li>$H^1$ discretization of the electrostatic potential</li>
<li>$H(\mathrm{curl})$ discretization of the electric field</li>
<li>$H(\mathrm{div})$ discretization of the magnetic field</li>
<li>$H(\mathrm{div})$ discretization of the heat flux</li>
<li>$L^2$ discretization of the temperature</li>
<li>implicit transient time integration</li>
<li>high order meshes</li>
<li>high order basis functions</li>
<li>adaptive mesh refinement</li>
<li>advanced visualization</li>
</ul>
<p>For more details, please see the <a href="../electromagnetics/">documentation</a> in the
<code>miniapps/electromagnetics</code> dire</p>
</div>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/electromagnetics/joule.cpp">joule.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="mobius-strip">
<h2 id="mobius-strip-miniapp">Mobius Strip Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/mobius-strip.saved" target="_blank">
<img class="floatright" src="../img/examples/mobius-strip.png">
</a></p>
<p>This miniapp generates various Mobius strip-like surface meshes. It is a good
way to generate complex surface meshes.</p>
<p>Manipulating the mesh topology and performing mesh transformation are demonstrated.</p>
<p>The <code>mobius-strip</code> mesh in the <code>data</code> directory was generated with this miniapp.</p>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the
<code>miniapps/meshing</code> dire</p>
</div>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/mobius-strip.cpp">mobius-strip.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="klein-bottle">
<h2 id="klein-bottle-miniapp">Klein Bottle Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/klein-bottle.saved" target="_blank">
<img class="floatright" src="../img/examples/klein-bottle.png">
</a></p>
<p>This miniapp generates three types of Klein bottle surfaces. It is similar to
the mobius-strip miniapp.</p>
<p>Manipulating the mesh topology and performing mesh transformation are demonstrated.</p>
<p>The <code>klein-bottle</code> and <code>klein-donut</code> meshes in the <code>data</code> directory were generated with this miniapp.</p>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the
<code>miniapps/meshing</code> directory.</p>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/klein-bottle.cpp">klein-bottle.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="toroid">
<h2 id="toroid-miniapp">Toroid Miniapp</h2>
<p><img class="floatright" src="../img/examples/toroid-wedge.png"></p>
<p>This miniapp generates two types of toroidal volume meshes; one with
triangular cross sections and one with square cross sections.  It
works by defining a stack of individual elements and bending them so
that the bottom and top of the stack can be joined to form a torus. It
supports various options including:</p>
<ul>
<li>The element type: 0 - Wedge, 1 - Hexahedron</li>
<li>The geometric order of the elements</li>
<li>The major and minor radii</li>
<li>The number of elements in the azimuthal direction</li>
<li>The number of nodes to offset by before rejoining the stack</li>
<li>The initial angle of the cross sectional shape</li>
<li>The number of uniform refinement steps to apply</li>
</ul>
<p>Along with producing some visually interesting meshes, this miniapp
demonstrates how simple 3D meshes can be constructed and transformed
in MFEM.  It also produces a family of meshes with simple but
non-trivial topology for testing various features in MFEM.</p>
<p><em>This miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/toroid.cpp">toroid.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="twist">
<h2 id="twist-miniapp">Twist Miniapp</h2>
<p><img class="floatright" src="../img/examples/twist-wedge.png"></p>
<p>This miniapp generates simple periodic meshes to demonstrate MFEM's handling
of periodic domains. MFEM's strategy is to use a discontinuous vector field
to define the mesh coordinates on a topologically periodic mesh. It works by
defining a stack of individual elements and stitching together the top and
bottom of the mesh. The stack can also be twisted so that the vertices of the
bottom and top can be joined with any integer offset (for tetrahedral and
wedge meshes only even offsets are supported).</p>
<p>The Twist miniapp supports various options including:</p>
<ul>
<li>The element type: 4 - Tetrahedron, 6 - Wedge, 8 - Hexahedron</li>
<li>The geometric order of the elements</li>
<li>The dimensions of the initial brick-shaped stack of elements</li>
<li>The number of elements in the z direction</li>
<li>The number of nodes to offset by before rejoining the stack</li>
<li>The number of uniform refinement steps to apply</li>
</ul>
<p>Along with producing some visually interesting meshes, this miniapp
demonstrates how simple 3D meshes can be constructed and transformed
in MFEM.  It also produces a family of meshes with simple but
non-trivial topology for testing various features in MFEM.</p>
<p><em>This miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/twist.cpp">twist.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="extruder">
<h2 id="extruder-miniapp">Extruder Miniapp</h2>
<p><img class="floatright" src="../img/examples/extruded-star.png"></p>
<p>This miniapp creates higher dimensional meshes from lower dimensional meshes
by extrusion.  Simple coordinate transformations can also be applied if desired.</p>
<ul>
<li>The initial mesh can be 1D or 2D</li>
<li>1D meshes can be extruded in both the y and z directions</li>
<li>2D meshes can be triangular, quadrilateral, or contain both element types</li>
<li>Meshes with high order geometry are supported</li>
<li>User can specify the number of elements and the distance to extrude</li>
<li>Geometric order of the transformed mesh can be user selected or automatic</li>
</ul>
<p>This miniapp provides another demonstration of how simple meshes can be
constructed and transformed in MFEM.</p>
<p><em>This miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/extruder.cpp">extruder.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="trimmer">
<h2 id="trimmer-miniapp">Trimmer Miniapp</h2>
<p><img class="floatright" src="../img/examples/trimmer-small.png"></p>
<p>This miniapp creates a new mesh file from an existing mesh by trimming away
elements with selected attributes. Newly exposed boundary elements will be
assigned new or user specified boundary attributes.</p>
<ul>
<li>The initial mesh can be 2D or 3D</li>
<li>Meshes with high order geometry are supported</li>
<li>Periodic meshes are supported</li>
<li>NURBS meshes are <em>not</em> supported</li>
</ul>
<p>This miniapp provides another demonstration of how simple meshes can be
constructed in</p>
</div>
<p><em>This miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/trimmer.cpp">trimmer.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="polar-nc">
<h2 id="polar-nc-miniapp">Polar-NC Miniapp</h2>
<p><img class="floatright" src="../img/examples/polar-nc.png"></p>
<p>This miniapp generates a circular sector mesh that consist of quadrilaterals
and triangles of similar sizes. The 3D version of the mesh is made of prisms
and tetrahedra.</p>
<p>The mesh is non-conforming by design, and can optionally be made curvilinear.
The elements are ordered along a space-filling curve by default, which makes
the mesh ready for parallel non-conforming AMR in MFEM.</p>
<p>The implementation also demonstrates how to initialize a non-conforming mesh
on the fly by marking hanging nodes with <code>Mesh::AddVertexParents</code>.</p>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the
<code>miniapps/meshing</code> directory.</p>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/polar-nc.cpp">polar-nc.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="shaper">
<h2 id="shaper-miniapp">Shaper Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/shaper.saved" target="_blank">
<img class="floatright" src="../img/examples/shaper.png">
</a></p>
<p>This miniapp performs multiple levels of adaptive mesh refinement to resolve the
interfaces between different "materials" in the mesh, as specified by a given
material function.</p>
<p>It can be used as a simple initial mesh generator, for example in the case when
the interface is too complex to describe without local refinement. Both
conforming and non-conforming refinements are supported.</p>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the
<code>miniapps/meshing</code> directory.</p>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/shaper.cpp">shaper.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="mesh-explorer">
<h2 id="mesh-explorer-miniapp">Mesh Explorer Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/mesh-explorer.saved" target="_blank">
<img class="floatright" src="../img/examples/mesh-explorer.png">
</a></p>
<p>This miniapp is a handy tool to examine, visualize and manipulate a given
mesh. Some of its features are:</p>
<ul>
<li>visualizing of mesh materials and individual mesh elements</li>
<li>mesh scaling, randomization, and general transformation</li>
<li>manipulation of the mesh curvature</li>
<li>the ability to simulate parallel partitioning</li>
<li>quantitative and visual reports of mesh quality</li>
</ul>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the
<code>miniapps/meshing</code> dire</p>
</div>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/mesh-explorer.cpp">mesh-explorer.cpp</a>) version.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="mesh-optimizer">
<h2 id="mesh-optimizer-miniapp">Mesh Optimizer Miniapp</h2>
<p><img class="floatright" src="../img/examples/mesh-optimizer.png"></p>
<p>This miniapp performs mesh optimization using the Target-Matrix Optimization
Paradigm (TMOP) by  <a href="https://link.springer.com/article/10.1007/s00366-011-0230-1">P. Knupp</a>,
and a global variational minimization approach
(<a href="https://epubs.siam.org/doi/abs/10.1137/18M1167206">Dobrev et al.</a>).
It minimizes the quantity</p>
<p>$$\sum_T \int_T \mu(J(x)),$$</p>
<p>where $T$ are the target (ideal) elements, $J$ is the Jacobian of the
transformation from the target to the physical element, and $\mu$ is the mesh
quality metric.</p>
<p>This metric can measure shape, size or alignment of the region around each
quadrature point. The combination of targets and quality metrics is used to
optimize the physical node positions, i.e., they must be as close as possible to
the shape / size / alignment of their targets.</p>
<p>This code also demonstrates a possible use of nonlinear operators, as well as
their coupling to Newton methods for solving minimization problems. Note that
the utilized Newton methods are oriented towards avoiding invalid meshes with
negative Jacobian determinants. Each Newton step requires the inversion of a
Jacobian matrix, which is done through an inner linear solver.</p>
<p><em>The miniapp has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/mesh-optimizer.cpp">mesh-optimizer.cpp</a>) and a
parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/pmesh-optimizer.cpp">pmesh-optimizer.cpp</a>)
version.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="mesh-fitting">
<h2 id="mesh-fitting-miniapp">Mesh Fitting Miniapp</h2>
<p><a href="https://mfem.org/img/gallery/workshop23/MBBBeam2D.mp4" target="_blank">
<img class="floatright" width="350" src="../img/gallery/workshop23/MBBBeam2D.png">
</a></p>
<p>This miniapp builds upon the mesh optimizer miniapp to enable mesh
alignment with the zero isosurface of a discrete level-set. The approach
is based on <a href="https://www.internationalmeshingroundtable.com/assets/papers/2021/11-Knupp.pdf">Dobrev et al.</a>
and <a href="https://www.sciencedirect.com/science/article/abs/pii/S0010448523000313">Mittal et al.</a>,
where we minimize the quantity</p>
<p>$$\sum_T \int_T \mu(J(x)) + \sum_{s \in S} w \,\, \sigma^2(x_s).$$</p>
<p>Here, the first term controls mesh quality and the second term enforces
weak alignment of a selected subset of mesh-nodes ($s \in S$) with the zero
isosurface of the discrete level-set function ($\sigma$).</p>
<p>Click on the image on the right to see a demonstration of this method for
generating body-fitted meshes for topology optimization in LiDO to maximize beam
stiffness under a downward force on the right</p>
</div>
<p><em>The miniapp has a parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/pmesh-fitting.cpp">pmesh-fitting.cpp</a>)
version.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="minimal-surface">
<h2 id="minimal-surface-miniapp">Minimal Surface Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/minimal-surface.saved" target="_blank">
<img class="floatright" width="350" src="../img/examples/min-surf-costa-amr-small.png">
</a></p>
<p>This miniapp solves Plateau's problem: the Dirichlet problem for the minimal surface equation.</p>
<p>Options to solve the minimal surface equations of both parametric surfaces as well as
surfaces restricted to be graphs of the form $z=f(x,y)$ are supported, including a
number of examples such as the Catenoid, Helicoid, Costa and Scherk surfaces.</p>
<p>For more details, please see the <a href="../meshing-miniapps/">documentation</a> in the <code>miniapps/meshing</code> dire</p>
</div>
<p><em>The miniapp has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/minimal-surface.cpp">minimal-surface.cpp</a>) and a
parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/meshing/pminimal-surface.cpp">pminimal-surface.cpp</a>)
version.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="lor-transfer">
<h2 id="low-order-refined-transfer-miniapp">Low-Order Refined Transfer Miniapp</h2>
<p><img class="floatright"  width="450" src="../img/examples/lor-transfer.png"></p>
<p>The <code>lor-transfer</code> miniapp, found under <code>miniapps/tools</code> demonstrates the
capability to generate a <em>low-order refined</em> mesh from a high-order mesh, and to
transfer solutions between these meshes.</p>
<p>Grid functions can be transferred between the coarse, high-order mesh and the
low-order refined mesh using either $L^2$ projection or pointwise evaluation.
These transfer operators can be designed to discretely conserve mass and to
recover the original high-order solution when transferring a low-order grid
function that was obtained by restricting a high-order grid function to the
low-order refined </p>
</div>
<p><em>The miniapp has only a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/tools/lor-transfer.cpp">lor-transfer.cpp</a>) version.</em>
<em><strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="gslib-interpolation">
<h2 id="interpolation-miniapps">Interpolation Miniapps</h2>
<p><img class="floatright"  width="450" src="../img/examples/gslib.png"></p>
<p>The interpolation miniapp, found under <code>miniapps/gslib</code>, demonstrate the
capability to interpolate high-order finite element functions at given set of
points in physical space.
These miniapps utilize the <a href="https://github.com/gslib/gslib"><code>gslib</code></a> library's
high-order  interpolation utility for quad and hex meshes:</p>
<ul>
<li><em>Find Points</em> miniapp has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/findpts.cpp">findpts.cpp</a>)
and a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/pfindpts.cpp">pfindpts.cpp</a>)
version that demonstrate the basic procedures for point search and evaluation
of grid functions.</li>
<li><em>Field Interp</em> miniapp
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/field-interp.cpp">field-interp.cpp</a>)
demonstrates how grid functions can be transferred between meshes.</li>
<li><em>Field Diff</em> miniapp
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/field-diff.cpp">field-diff.cpp</a>)
demonstrates how grid functions on two different meshes can be compared with
each other.</li>
</ul>
<p><em><strong>These miniapps require installation of the <a href="https://github.com/gslib/gslib"><code>gslib</code></a> library. We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="extrapolate">
<h2 id="extrapolation-miniapp">Extrapolation Miniapp</h2>
<p><img class="floatright"  width="450" src="../img/examples/extrapolate.png"></p>
<p>The <code>extrapolate</code> miniapp, found in the <code>miniapps/shifted</code> directory,
extrapolates a finite element function from a set of elements (known values) to
the rest of the domain. The set of elements that contains the known values is
specified by the positive values of a level set Coefficient. The known values
are not modified. The miniapp supports two PDE-based approaches
(<a href="https://www.sciencedirect.com/science/article/pii/S0021999103004170?via%3Dihub">Aslam</a>, <a href="https://epubs.siam.org/doi/10.1137/19M1307883">Bochkov &amp; Gibou</a>),
both of which rely on solving a sequence of advection problems in the
direction of the unknown parts of the domain. The extrapolation can be constant
(1st order), linear (2nd order), or quadratic (3rd order). These formal orders
hold for a limited band around the zero level set, see the above references for
further information.</p>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/shifted/extrapolate.cpp">extrapolate.cpp</a>) version.</em>
<em><strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em></p>
<div style="clear:both;"/></div>
<br>

</div>
<div id="distance">
<h2 id="distance-solver-miniapp">Distance Solver Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/distance.saved" target="_blank">
<img class="floatright" width="250" src="../img/examples/distance.png">
</a></p>
<p>The <code>distance</code> miniapp, found in the <code>miniapps/shifted</code> directory demonstrates the
capability to compute the "distance" to a given point source or to the zero
level set of a given function.
Here "distance" refers to the length of the shortest path through the mesh.
The input can be a <code>DeltaCoefficient</code> (representing a point source),
or any <code>Coefficient</code> (for the case of a level set).
The output is a <code>ParGridFunction</code> that can be scalar (representing the scalar
distance), or a vector (its magnitude is the distance, and its direction is
the starting direction of the shortest path).</p>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/shifted/distance.cpp">distance.cpp</a>) version.</em>
<em><strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="shifted">
<h2 id="shifted-diffusion-miniapp">Shifted Diffusion Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/shifted.saved" target="_blank">
<img class="floatright"  width="500" src="../img/examples/shifted.png">
</a></p>
<p>The <code>diffusion</code> miniapp, found in the <code>miniapps/shifted</code> directory, demonstrates
the capability to formulate a boundary value problem using a surrogate
computational domain. The method uses a distance function to the true boundary
to enforce Dirichlet boundary conditions on the (non-aligned) mesh faces,
therefore "shifting" the location where boundary conditions are imposed. The
implementation in the miniapp is a high-order extension of the
second-generation
[shifted boundary method](https://www.sciencedirect.com/science/article/pii/S004578252030</p>
</div>
<p><em>The miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/shifted/distance.cpp">diffusion.cpp</a>) version.</em>
<em><strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="laghos">
<h2 id="laghos-miniapp">Laghos Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/laghos.saved" target="_blank">
<img class="floatright" src="../img/examples/laghos.png">
</a></p>
<p><strong>Laghos</strong> (LAGrangian High-Order Solver) is a miniapp that solves the
time-dependent Euler equations of compressible gas dynamics in a moving
Lagrangian frame using unstructured high-order finite element spatial
discretization and explicit high-order time-stepping.</p>
<p>The computational motives captured in Laghos include:</p>
<ul>
<li>Support for unstructured meshes, in 2D and 3D, with quadrilateral and
  hexahedral elements (triangular and tetrahedral elements can also be used, but
  with the less efficient full assembly option). Serial and parallel mesh
  refinement options can be set via a command-line flag.</li>
<li>Explicit time-stepping loop with a variety of time integrator options. Laghos
  supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6.</li>
<li>Continuous and discontinuous high-order finite element discretization spaces
  of runtime-specified order.</li>
<li>Moving (high-order) meshes.</li>
<li>Separation between the assembly and the quadrature point-based computations.</li>
<li>Point-wise definition of mesh size, time-step estimate and artificial
  viscosity coefficient.</li>
<li>Constant-in-time velocity mass operator that is inverted iteratively on
  each time step. This is an example of an operator that is prepared once (fully
  or partially assembled), but is applied many times. The application cost is
  dominant for this operator.</li>
<li>Time-dependent force matrix that is prepared every time step (fully or
  partially assembled) and is applied just twice per "assembly". Both the
  preparation and the application costs are important for this operator.</li>
<li>Domain-decomposed MPI parallelism.</li>
<li>Optional in-situ visualization with <a href="https://glvis.org">GLVis</a> and data output
  for visualization / data analysis with <a href="https://visit.llnl.gov">VisIt</a>.</li>
</ul>
<p>The Laghos miniapp is part of the <a href="https://ceed.exascaleproject.org/software">CEED software suite</a>,
a collection of software benchmarks, miniapps, libraries and APIs for
efficient exascale discretizations based on high-order finite element
and spectral element methods. See https://github.com/ceed for more
information and source code availability.</p>
<p><em>This is an external miniapp, available at <a href="https://github.com/CEED/Laghos">https://github.com/CEED/Laghos</a>.</em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="remhos">
<h2 id="remhos-miniapp">Remhos Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/remhos.saved" target="_blank">
<img class="floatright" width="450" src="../img/examples/remhos.png">
</a></p>
<p><strong>Remhos</strong> (REMap High-Order Solver) is a miniapp that solves the pure advection
equations that are used to perform monotonic and conservative discontinuous
field interpolation (remap) as part of the Eulerian phase in Arbitrary
Lagrangian Eulerian (ALE) simulations.</p>
<p>The computational motives captured in Remhos include:</p>
<ul>
<li>Support for unstructured meshes, in 2D and 3D, with quadrilateral and
  hexahedral elements. Serial and parallel mesh refinement options can be
  set via a command-line flag.</li>
<li>Explicit time-stepping loop with a variety of time integrator options. Remhos
  supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6.</li>
<li>Discontinuous high-order finite element discretization spaces
  of runtime-specified order.</li>
<li>Moving (high-order) meshes.</li>
<li>Mass operator that is local per each zone. It is inverted by iterative or exact
  methods at each time step. This operator is constant in time (transport mode)
  or changing in time (remap mode). Options for full or partial assembly.</li>
<li>Advection operator that couples neighboring zones. It is applied once at each
  time step. This operator is constant in time (transport mode) or
  changing in time (remap mode). Options for full or partial assembly.</li>
<li>Domain-decomposed MPI parallelism.</li>
<li>Optional in-situ visualization with <a href="https://glvis.org">GLVis</a> and data output
  for visualization and data analysis with <a href="https://visit.llnl.gov">VisIt</a>.</li>
</ul>
<p>The Remhos miniapp is part of the <a href="https://ceed.exascaleproject.org/software">CEED software suite</a>,
a collection of software benchmarks, miniapps, libraries and APIs for
efficient exascale discretizations based on high-order finite element
and spectral element methods. See https://github.com/ceed for more
information and source code availab</p>
</div>
<p><em>This is an external miniapp, available at <a href="https://github.com/CEED/Remhos">https://github.com/CEED/Remhos</a>.</em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="navier">
<h2 id="navier-miniapp">Navier Miniapp</h2>
<p><a href="https://glvis.org/live/?stream=../data/streams/navier.saved" target="_blank">
<img class="floatright" width="300" style="border:1px solid black" src="../img/examples/navier_shear4.png">
</a></p>
<p>Navier is a miniapp that solves the time-dependent Navier-Stokes equations of
incompressible fluid dynamics
\begin{align}
\frac{\partial u}{\partial t} + (u \cdot \nabla) u - \frac{1}{Re} \nabla^2 u - \nabla p &amp;= f \\
\nabla \cdot u &amp;= 0
\end{align}
using a spatially high-order finite element discretization.</p>
<p>The time-dependent problem is solved using a (up to) third order
implicit-explicit method which leverages an extrapolation scheme for the
convective parts and a backward-difference formulation for the viscous parts of
the equation.</p>
<p>The miniapp supports:</p>
<ul>
<li>Arbitrary order H1 elements</li>
<li>High order mesh elements</li>
<li>IMEX (EXTk-BDFk) time-stepping up to third order</li>
<li>Convenient interface for new users</li>
<li>A variety of test cases and benc</li>
</ul>
</div>
<p><em>This miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/navier/navier_solver.cpp">navier_solver.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="block-solvers">
<h2 id="block-solvers-miniapp">Block Solvers Miniapp</h2>
<p><img class="floatright" width="400" src="../img/examples/block-solvers.png"></p>
<p>The Block Solvers miniapp, found under <code>miniapps/solvers</code>, compares various linear solvers for the saddle
point system obtained from mixed finite element discretization of the Darcy's flow problem
\begin{array}{rcl}
      k{\bf u}        &amp; + \nabla p &amp; = f \\
-\nabla \cdot {\bf u} &amp;            &amp; = g
\end{array}</p>
<p>The solvers being compared include:</p>
<ul>
<li>The divergence-free solver (couple and decoupled modes), which is based on a multilevel decomposition of
the Raviart-Thomas finite element space and its divergence-free subspace.</li>
<li>MINRES preconditioned by the block diagonal preconditioner in
<a href="https://github.com/mfem/mfem/blob/master/examples/ex5p.cpp">ex5p.cpp</a>.</li>
</ul>
<p>For more details, please see the
<a href="https://github.com/mfem/mfem/blob/master/miniapps/solvers/README">documentation</a> in the <code>miniapps/solvers</code>
directory.</p>
<p>The miniapp supports:</p>
<ul>
<li>Arbitrary order mixed finite element pair (Raviart-Thomas elements + piecewise discontinuous polynomials)</li>
<li>Various combination of essential and natural boundary conditions</li>
<li>Homogeneous or heterogeneous scalar coeffic</li>
</ul>
</div>
<p><em>This miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/solvers/block-solvers.cpp">block-solvers.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="overlapping">
<h2 id="overlapping-grids-miniapps">Overlapping Grids Miniapps</h2>
<p><img class="floatright"  width="450" src="../img/examples/overlapping.png"></p>
<p>Overlapping grids-based frameworks can often make problems tractable that are
otherwise inaccessible with a single conforming grid. The following
<code>gslib</code>-based miniapps in MFEM demonstrate how to set up and use overlapping grids:</p>
<ul>
<li>
<p>The <em>Schwarz Example 1</em> miniapp in <code>miniapps/gslib</code> has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/schwarz_ex1.cpp">schwarz_ex1.cpp</a>)
a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/gslib/schwarz_ex1p.cpp">schwarz_ex1p.cpp</a>)
version that solves the
Poisson problem on overlapping grids. The serial version is restricted to use
two overlapping grids, while the parallel version supports arbitrary number of
overlapping grids.</p>
</li>
<li>
<p>The <em>Navier Conjugate Heat Transfer</em> miniapp in <code>miniapps/navier</code>
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/navier/navier_cht.cpp">navier_cht.cpp</a>)
demonstrates how a conjugate heat transfer problem can be solved with the fluid
dynamics (incompressible Navier-Stokes equations) and heat transfer
(advection-diffusion equation) PDEs modeled on different m</p>
</li>
</ul>
</div>
<p><em>These miniapps require installation of the <a href="https://github.com/gslib/gslib"><code>gslib</code></a> library.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="parelag">
<h2 id="parelag-amge-for-hcurl-and-hdiv-miniapp">ParELAG AMGe for H(curl) and H(div) Miniapp</h2>
<p><img class="floatright" width="250" style="border:1px solid black" src="../img/examples/amge-2d-aes.png"></p>
<p>This is a miniapp that exhibits the <strong>ParELAG</strong> library and part of its
capabilities. The miniapp employs MFEM and ParELAG to solve $H(\mathrm{curl})$-
and $H(\mathrm{div})$-elliptic forms by an element based algebraic multigrid
(AMGe).</p>
<p><a href="https://github.com/LLNL/parelag">ParELAG</a> is a library mostly developed at the
Center for Applied Scientific Computing of Lawrence Livermore National
Laboratory, California, USA.</p>
<p>The miniapp uses:</p>
<ul>
<li>
<p>A multilevel hierarchy of de Rham complexes of finite element spaces, built by
ParELAG;</p>
</li>
<li>
<p>Hiptmair-type (hybrid) smoothers, implemented in ParELAG;</p>
</li>
<li>
<p>AMS (Auxiliary-space Maxwell Solver) or ADS (Auxiliary-space Divergence
Solver), from HYPRE, for preconditioning or solving on the coarsest levels.</p>
</li>
</ul>
<p>Alternatively, it is possible to precondition or solve the $H(\mathrm{div})$
form on the coarsest level via a <a href="https://docs.mfem.org/html/classmfem_1_1Hybridization.html">hybridization</a>
approach. However, this is not yet implemented in ParELAG for the coarse levels.
Only the hybridization solver that is directly applicable to an
$H(\mathrm{div})$-$L^2$ mixed (saddle-point) system is currently available in
ParELAG.</p>
<p>We recommend viewing <a href="https://github.com/mfem/mfem/blob/master/examples/ex3p.cpp">ex3p.cpp</a>
and <a href="https://github.com/mfem/mfem/blob/master/examples/ex4p.cpp">ex4p.cpp</a>
before viewing this miniapp.</p>
<p>For more details, please see the
<a href="https://github.com/mfem/mfem/blob/master/miniapps/parelag/README">documentation</a> in the <code>miniapps/parelag</code>
directory.</p>
<p><em>This miniapp has only a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/parelag/MultilevelHcurlHdivSolver.cpp">MultilevelHcurlHdivSolver.cpp</a>) version.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="spde">
<h2 id="generating-gaussian-random-fields-via-the-spde-method">Generating Gaussian Random Fields via the SPDE Method</h2>
<p><img class="floatright" width="300" src="../img/examples/spde.png"></p>
<p>This miniapp generates Gaussian random fields on meshed domains $\Omega \subset \mathbb{R}^n$ via the SPDE
method. The method exploits a stochastic, fractional PDE whose full-space solutions yield Gaussian
random fields with a MatÃ©rn covariance. The method was introduced and popularized
by <a href="https://doi.org/10.1111/j.1467-9868.2011.00777.x">Lindgren et. al</a> in 2010.
In this miniapp, we use a slightly modified representation following
<a href="https://doi.org/10.1137/19M1259286">Khristenko et. al</a>.
More specifically, we solve the equation
\begin{equation}
  \left(
  -\frac{1}{2\nu} \nabla \cdot
  \left( \Theta \nabla \right)
  + \mathbf{1}
  \right)^{\frac{2\nu+n}{4}}
  u(x,w) = \eta W(x,w)
  \ \ \ \text{in} \ \ \Omega,
\end{equation}
with various boundary conditions.
Solving this equation on $\Omega = \mathbb{R}^n$ delivers a homogeneous Gaussian random field with zero mean and MatÃ©rn covariance,
\begin{align}\label{eq:MaternCovariance}
  C(x,y) &amp;= \sigma^2M_\nu \left(\sqrt{2\nu}\, \| x-y \|_{\Theta} \right)
  ,
\end{align}
where
$M_\nu(z) =
  \frac{2^{1-\nu}}{\Gamma(\nu)}
  z ^{\nu}
  K_\nu \left( z \right)$
  and $\| x-y \|_{\Theta}^2 = (x-y)^\top\Theta (x-y)$.
The MatÃ©rn model provides the regularity parameter $\nu &gt; 0$ and the
anisotropic diffusion tensor
$\Theta \in \mathbb{R}^{n\times n}$, which determines the spatial structure (correlation
lengths).
However, applying boundary conditions to the SPDE above provides the ability to model a significantly larger class of inhomogeneous random fields on complex domains.
For further details, see the miniapp
<a href="https://github.com/mfem/mfem/blob/master/miniapps/spde/README.md">README</a>.</p>
<p>We recommend viewing <a href="https://github.com/mfem/mfem/blob/master/examples/ex33p.cpp">ex33p.cpp</a>
before viewing this miniapp.</p>
<p><em>This miniapp (<a href="https://github.com/mfem/mfem/blob/master/miniapps/spde/generate_random_field.cpp">generate_random_field.cpp</a>) has only a parallel implementation. It further requires MFEM to be
built with LAPACK, otherwise you may only use predefined values for $\nu$.
<strong>We recommend that new users start with the example codes before
moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></p>
</div>
<div id="multidomain">
<h2 id="multidomain-and-submesh-demonstration-miniapp">Multidomain and SubMesh demonstration Miniapp</h2>
<p><img class="floatright" width="300" style="border:0px solid black" src="../img/examples/multidomain.png"></p>
<p>This
<a href="https://github.com/mfem/mfem/blob/master/miniapps/multidomain/multidomain.cpp">miniapp</a>
aims to demonstrate how to solve two PDEs, that represent different physics, on
the same domain. MFEM's SubMesh interface is used to compute on and transfer
between the spaces of predefined parts of the domain. For the sake of
simplicity, the spaces on each domain are using the same order H1 finite
elements. This does not mean that the approach is limited to this configuration.</p>
<p>A 3D domain comprised of an outer box with a cylinder shaped inside is used.</p>
<p>A heat equation is described on the outer box domain</p>
<p>\begin{align}
   \frac{\partial T}{\partial t} &amp;= \kappa \Delta T &amp;&amp;\mbox{in outer box}\\
   T &amp;= T_{wall} &amp;&amp;\mbox{on outside wall}\\
   \nabla T \cdot \vec{n} &amp;= 0 &amp;&amp;\mbox{on inside (cylinder) wall}
\end{align}</p>
<p>with temperature $T$ and coefficient $\kappa$ (non-physical in this example).
A convection-diffusion equation is described inside the cylinder domain</p>
<p>\begin{align}
   \frac{\partial T}{\partial t} &amp;= \kappa \Delta T - \alpha \nabla \cdot (\vec{b} T) &amp; &amp;\mbox{in inner cylinder}\\
   T &amp;= T_{wall} &amp; &amp;\mbox{on cylinder wall}\\
   \nabla T \cdot \vec{n} &amp;= 0 &amp; &amp;\mbox{else}
\end{align}</p>
<p>with temperature $T$, coefficients $\kappa$, $\alpha$ and prescribed velocity profile $\vec{b}$, and
$T_{wall}$ obtained from the heat equation.</p>
<p>To couple the solutions of both equations, a segregated solve with one way
coupling approach is used. The heat equation of the outer box is solved from the
timestep $T_{box}(t)$ to $T_{box}(t+dt)$. Then for the convection-diffusion
equation $T_{wall}$ is set to $T_{box}(t+dt)$ and the equation is solved for
$T(t+dt)$ which results in a first-order one way cou</p>
</div>
<p><em>This miniapp has only a parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/multidomain/multidomain.cpp">multidomain.cpp</a>) implementation.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em>
<div style="clear:both;"/></div>
<br></div></p>
<div id="dpgminiapp">
<h2 id="dpg-miniapp">DPG miniapp</h2>
<p>This <a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg">miniapp</a> demonstrates how to discretize and solve various PDEs using the Discontinuous Petrov-Galerkin (DPG) method.
It utilizes a new user-friendly interface to assemble the block DPG systems arising from the discretization of any DPG formulation (such as Ultraweak or Primal). In addition, the miniapp supports complex-valued systems, static condensation for block systems, and AMR using the built-in DPG residual-based error indicator. This capability is showcased in the following DPG examples in <a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg">miniapps/dpg</a>.</p>
<ul>
<li>
<p><strong>Ultraweak DPG formulation for diffusion</strong>.
<img class="floatright"  width="122" src="../img/examples/dpg-diffusion.png">
<!--  -->
This example solves the simple Poisson equation $$-Î” u = f$$ and computes rates of convergence under successive uniform h-refinements for a smooth manufactured solution. The parallel version  also includes an AMR implementation for the L-shape benchmark problem. This example has a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/diffusion.cpp">diffusion.cpp</a>) and a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/pdiffusion.cpp">pdiffusion.cpp</a>) version.</p>
</li>
<li>
<p><strong>Ultraweak DPG formulation for convection-diffusion</strong>.
<img class="floatright"  width="122" src="../img/examples/dpg-convection-diffusion.png">
This example solves the
 convection-diffusion problem:
\begin{align}
   -\epsilon \Delta u + \nabla \cdot (\beta u) &amp;= f\\
\end{align}
using AMR. The example demonstrates the use of <em>mesh-dependent test norms</em> which are suitable for problems with solutions that exhibit large gradients present in <em>internal</em> or <em>boundary layers</em>. The example has a serial (<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/convection-diffusion.cpp">convection-diffusion.cpp</a>) and a parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/pconvection-diffusion.cpp">pconvection-diffusion.cpp</a>) version.</p>
</li>
<li>
<p><strong>Ultraweak DPG formulation for time-harmonic linear acoustics</strong>.
<img class="floatright"  width="122" src="../img/examples/dpg-acoustics.gif">
This example solves the indefinite Helmholtz equation
\begin{align}
   -\Delta u - \omega^2 u &amp;= f\\
\end{align}
The example includes formulations with manufactured plane-wave solutions as well as high-frequency scattering problems and the use of Perfectly Match Layers (PML). It also demonstrates how to set up complex-valued systems and preconditioners for their solutions.
The example has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/acoustics.cpp">acoustics.cpp</a>) and parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/pacoustics.cpp">pacoustics.cpp</a>) version.</p>
</li>
<li>
<p><strong>Ultraweak DPG formulation for time-harmonic Maxwell</strong>.
<img class="floatright"  width="122" src="../img/examples/dpg-maxwell.png">
  This example solves
the indefinite Maxwell problem
\begin{align}
   \nabla Ã— (\mu^{-1} \nabla \times E) - \omega^2 \epsilon E&amp;= J\\
\end{align}
The example includes formulations with smooth manufactured solutions, AMR formulations for high-frequency scattering problems as well as a problem with a singular solution. The example has a serial
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/maxwell.cpp">maxwell.cpp</a>) and a parallel
(<a href="https://github.com/mfem/mfem/blob/master/miniapps/dpg/pmaxwell.cpp">pmaxwell.cpp</a>) version.</p>
</li>
</ul>
<div style="clear:both;"/></div>
<br>

</div>
<div id="tribol">
<h2 id="tribol-miniapp">Tribol miniapp</h2>
<p><img class="floatright"  width="250" src="../img/examples/tribol.png"></p>
<p>This <a href="https://github.com/mfem/mfem/blob/master/miniapps/tribol/contact-patch-test.cpp">miniapp</a> demonstrates how to use <a href="https://github.com/LLNL/Tribol">Tribol's</a> mortar method to solve a contact patch test. A contact patch test places two aligned, linear elastic
cubes in contact, then verifies that the exact elasticity solution for this problem
is recovered. The exact solution requires transmission of a uniform pressure
field across a (not necessarily conforming) interface (i.e. the contact
surface). Mortar methods (including the one implemented in Tribol) are generally
able to pass the contact patch test. The test assumes small deformations and no
accelerations, so the relationship between forces/contact pressures and
deformations/contact gaps is linear and, therefore, the problem can be solved
exactly with a single linear solve. The mortar implementation is based on <a href="https://doi.org/10.1016/j.cma.2003.10.010">Puso
and Laursen (2004)</a>. A description of
the Tribol implementation is available in <a href="https://serac.readthedocs.io/en/latest/sphinx/theory_reference/solid.html#contact-mechanics">Serac
documentation</a>.
Lagrange multipliers are used to solve for the pressure required to prevent
violation of the contact constraints.</p>
<p><em>This miniapp has only a parallel (<a href="https://github.com/mfem/mfem/blob/master/miniapps/tribol/contact-patch-test.cpp">contact-patch-test.cpp</a>) implementation. For more details, please see the documentation in <a href="https://github.com/mfem/mfem/blob/master/miniapps/tribol/README.md">miniapps/tribol/README.md</a>.
<strong>We recommend that new users start with the example codes before moving to the miniapps.</strong></em></p>
<div style="clear:both;"/></div>
<br></div>

</div>
<!-- ------------------------------------------------------------------------- -->

<div id="nomatch">
<br/><br/><br/>
<center>
No examples or miniapps match your criteria.
</center>
<br/><br/><br/>
<hr>
</div>

<div style="clear:both;"/></div>
<script type="text/javascript"><!--

function showElement(id, show)
{
    //document.getElementById(id).style.display = show ? "block" : "none";

    // workaround because Doxygen splits and duplicates the divs for some reason
    var divs = document.getElementsByTagName("div");
    for (i = 0; i < divs.length; i++)
    {
       if (divs.item(i).id == id) {
          divs.item(i).style.display = show ? "block" : "none";
       }
    }
    return show ? 1 : 0;
}

function getBooleans(comboId)
{
   combo = document.getElementById(comboId);

   first_selected = false;
   for (i = 0; i < combo.options.length; i++)
   {
      opt = combo.options[i];
      selected = opt.selected || first_selected;
      if (!i) { first_selected = selected; }

      // create a boolean variable named after the option
      this[opt.id] = selected;
   }
}

function update()
{
   getBooleans("group1");
   getBooleans("group2");
   getBooleans("group3");
   getBooleans("group4");

   numShown = 0 // expression continued...

   // example codes
   + showElement("ex0",  (diffusion) && h1 && (galerkin) && (gs || pcg || amg))
   + showElement("ex1",  (diffusion) && h1 && (galerkin || nurbs || staticcond || pa) && (gs || pcg || umfpack || amg || petsc))
   + showElement("ex2",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc))
   + showElement("ex3",  (maxwell) && hcurl && (galerkin || staticcond || pa) && (gs || pcg || umfpack || ams || petsc))
   + showElement("ex4",  graddiv && (hdiv || hminus12) && (galerkin || hybr || staticcond || pa) && (gs || pcg || umfpack || amg || ads || ams || petsc))
   + showElement("ex5",  darcy && (l2 || hdiv) && (mixed || pa) && (gs || jacobi || minres || umfpack || amg  || petsc))
   + showElement("ex6",  (diffusion) && h1 && (galerkin || nurbs || amr || pa) && (gs || pcg || umfpack || amg || petsc))
   + showElement("ex7",  (diffusion || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg))
   + showElement("ex8",  diffusion && (l2 || h1 || hminus12) && dpg && (gs || pcg || umfpack || amg || ads || ams))
   + showElement("ex9",  (advection) && l2 && (dg || pa) && (pcg || rk || sundials || petsc || hiop || gmres || sdirk))
   + showElement("ex10", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc))
   + showElement("ex11", diffusion && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu || slepc))
   + showElement("ex12", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg))
   + showElement("ex13", maxwell && hcurl && galerkin && (lobpcg || ams))
   + showElement("ex14", diffusion && l2 && dg && (gs || pcg || gmres || umfpack || amg))
   + showElement("ex15", diffusion && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg))
   + showElement("ex16", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials))
   + showElement("ex17", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg))
   + showElement("ex18", compressibleflow && l2 && dg && (rk))
   + showElement("ex19", elasticity && h1 && mixed && (gs || gmres || newton || amg))
   + showElement("ex20", (elasticity || maxwell || conduction || compressibleflow) && h1 && mixed && symplectic)
   + showElement("ex21", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg))
   + showElement("ex22", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads))
   + showElement("ex23", (diffusion || wave) && h1 && (galerkin || nurbs) && newmark)
   + showElement("ex24", (graddiv) && (h1 || hcurl) && (galerkin || pa) && pcg)
   + showElement("ex25", (maxwell || wave) && hcurl && galerkin && (gmres || ams))
   + showElement("ex26", diffusion && h1 && (galerkin || pa) && (jacobi || pcg || amg))
   + showElement("ex27", (conduction || diffusion) && (h1 || l2) && (galerkin || dg) && (gs || pcg || gmres || amg || umfpack))
   + showElement("ex28", elasticity && h1 && galerkin && pcg)
   + showElement("ex29", diffusion && (h1 || hcurl) && (galerkin || staticcond) && (gs || pcg || amg))
   + showElement("ex30", meshing && (h1 || hcurl || hdiv || l2) && (galerkin || nurbs || amr) && none)
   + showElement("ex31",  maxwell && hcurl && galerkin && (gs || pcg || umfpack || ams))
   + showElement("ex32", maxwell && hcurl && galerkin && (lobpcg || ams))
   + showElement("ex33", (diffusion || nonlocal) && h1 && galerkin && amg)
   + showElement("ex34", maxwell && (hcurl || h1 || hdiv) && galerkin && (pcg || amg || ams))
   + showElement("ex35", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads || superlu || lobpcg))
   + showElement("ex36", (diffusion || freeboundary) && h1 && (galerkin || mixed) && (gmres || newton))
   + showElement("ex37", elasticity && (l2 || h1) && galerkin && (pcg || amg))
   + showElement("ex38", all1 && all2 && all3 && none)
   + showElement("ex39", diffusion && h1 && galerkin && all4)
   + showElement("ex40", darcy && (l2 || hdiv) && (galerkin || mixed) && (gmres || newton))

   // nurbs miniapps
   + showElement("nurbs_ex3", maxwell && nurbs && hcurl)
   + showElement("nurbs_ex5", darcy && nurbs && hdiv)
   + showElement("nurbs_ex11", diffusion && nurbs)
   + showElement("nurbs_ex24", nurbs && ( hcurl || hdiv))

   // electromagnetic miniapps
   + showElement("volta", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg))
   + showElement("tesla", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams))
   + showElement("maxwell", (maxwell || conduction || wave) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic))
   + showElement("joule", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk))

   // meshing miniapps
   + showElement("mobius-strip", meshing && all2 && all3 && all4)
   + showElement("klein-bottle", meshing && all2 && all3 && all4)
   + showElement("toroid", meshing && all2 && all3 && all4)
   + showElement("twist", meshing && all2 && all3 && all4)
   + showElement("extruder", meshing && all2 && all3 && all4)
   + showElement("trimmer", meshing && all2 && all3 && all4)
   + showElement("polar-nc", meshing && all2 && all3 && all4)
   + showElement("shaper", meshing && all2 && all3 && all4)
   + showElement("mesh-explorer", meshing && all2 && all3 && all4)
   + showElement("mesh-optimizer", meshing && all2 && all3 && all4)
   + showElement("mesh-fitting", meshing && all2 && all3 && all4)
   + showElement("minimal-surface", meshing && all2 && (galerkin || amr || pa) && all4)
   + showElement("lor-transfer", meshing && (l2 || h1) && all3 && all4)
   + showElement("gslib-interpolation", meshing && all2 && all3 && all4)
   + showElement("multidomain", meshing && all2 && all3 && all4)

   // shifted methods miniapps
   + showElement("extrapolate", advection && l2 && dg && rk)
   + showElement("distance", all1 && h1 && galerkin && (pcg || gmres || amg || newton))
   + showElement("shifted", all1 && h1 && galerkin && (pcg || gmres || amg || newton))

   // external miniapps
   + showElement("laghos", (compressibleflow) && (l2 || h1) && (galerkin || dg || pa) && (rk))
   + showElement("remhos", (advection) && (l2) && (galerkin || dg || pa) && (rk))
   + showElement("navier", (incompressibleflow) && (h1) && (galerkin || pa) && (gmres || pcg || amg))
   + showElement("block-solvers", darcy && (l2 || hdiv || hcurl) && mixed && (gmres || pcg || minres || amg))
   + showElement("overlapping", (incompressibleflow || diffusion || meshing) && (h1) && (galerkin) && (gmres || pcg))
   + showElement("parelag", (maxwell || graddiv) && (hdiv || hcurl) && (galerkin) && (ams || ads || pcg))

   // Misc miniapps
   + showElement("spde", (diffusion || nonlocal || stochastic) && h1 && galerkin && amg)
   + showElement("dpgminiapp", (diffusion || convectiondiffusion || maxwell || acoustics || wave) && (group2) && (dpg || amr) && (amg || ams || ads || pcg))
   + showElement("tribol", elasticity && h1 && galerkin && (superlu || minres || jacobi) )

   ; // ...end of expression

   // show/hide the message "No examples match your criteria"
   showElement("nomatch", numShown === 0);
}

function initCombos()
{
   var query = location.search.substr(1);
   query.split("&").forEach(function(id)
   {
      if (id) {
         opt = document.getElementById(id);
         if (opt) { opt.selected = true; }
      }
   });
}

// make sure "no match" div is not visible after page is loaded
window.onload = update;

// force vertical scrollbar
document.getElementsByTagName("body")[0].style = "overflow-y: scroll"

// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs
initCombos();

//--></script>


</div></div>

            
        </div>
        

        <footer class="footer">
           <div class="container">
              <p class="text-muted alignright">LLNL-WEB-676715</p>
              <p class="text-muted alignleft">
                  Developed by the <a href="/about/">MFEM team</a> at
                  <a href="https://computing.llnl.gov/casc/">CASC</a>,
                  <a href="https://www.llnl.gov/">LLNL</a></p>
           </div>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
        <script src="../js/retina.min.js"></script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../search/main.js"></script>
    </body>
</html>
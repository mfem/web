{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MFEM is a free , lightweight , scalable C++ library for finite element methods. Features Arbitrary high-order finite element meshes and spaces . Wide variety of finite element discretization approaches. Conforming and nonconforming adaptive mesh refinement . Scalable from laptops to GPU-accelerated supercomputers. ... and many more . MFEM is used in many projects, including BLAST , RF-SciDAC , VisIt , Cardioid , xSDK , SciDAC/ FASTMath , and the Center for Efficient Exascale Discretizations in the Exascale Computing Project . See also our Gallery , Publications and News pages. News Date Message Apr 22, 2021 MFEM featured on S&TR magazine cover . Mar 1, 2021 Logo featured throughout LLNL 2020 annual report . Feb 16, 2021 New page on GPU performance . Dec 19, 2020 PyMFEM available with pip install mfem . Latest Release New features \u250a Examples \u250a Code documentation \u250a Sources Download mfem-4.2.tgz Older releases \u250a Python wrapper Documentation Building MFEM \u250a Serial Tutorial \u250a Parallel Tutorial \u250a GPU tips Finite Elements \u250a Electromagnetics \u250a Fluids \u250a Meshing \u250a Performance \u250a Tools New users should start by examining the example codes . We also recommend using GLVis for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"#features","text":"Arbitrary high-order finite element meshes and spaces . Wide variety of finite element discretization approaches. Conforming and nonconforming adaptive mesh refinement . Scalable from laptops to GPU-accelerated supercomputers. ... and many more . MFEM is used in many projects, including BLAST , RF-SciDAC , VisIt , Cardioid , xSDK , SciDAC/ FASTMath , and the Center for Efficient Exascale Discretizations in the Exascale Computing Project . See also our Gallery , Publications and News pages.","title":"Features"},{"location":"#news","text":"Date Message Apr 22, 2021 MFEM featured on S&TR magazine cover . Mar 1, 2021 Logo featured throughout LLNL 2020 annual report . Feb 16, 2021 New page on GPU performance . Dec 19, 2020 PyMFEM available with pip install mfem .","title":"News"},{"location":"#latest-release","text":"New features \u250a Examples \u250a Code documentation \u250a Sources Download mfem-4.2.tgz Older releases \u250a Python wrapper","title":"Latest Release"},{"location":"#documentation","text":"Building MFEM \u250a Serial Tutorial \u250a Parallel Tutorial \u250a GPU tips Finite Elements \u250a Electromagnetics \u250a Fluids \u250a Meshing \u250a Performance \u250a Tools New users should start by examining the example codes . We also recommend using GLVis for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about/","text":"About MFEM MFEM originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @article{mfem, title = {{MFEM}: A Modular Finite Element Library}, author = {R. Anderson and J. Andrej and A. Barker and J. Bramwell and J.-S. Camier and J. Cerveny V. Dobrev and Y. Dudouit and A. Fisher and Tz. Kolev and W. Pazner and M. Stowell and V. Tomov and I. Akkerman and J. Dahm and D. Medina and S. Zampini}, journal = {Computers \\& Mathematics with Applications}, doi = {10.1016/j.camwa.2020.06.009}, volume = {81}, pages = {42-74}, year = {2021} } @misc{mfem-web, key = {mfem}, title = {{MFEM}: Modular Finite Element Methods {[Software]}}, howpublished = {\\url{mfem.org}}, doi = {10.11578/dc.20171025.1248} } Contributors Ido Akkerman Robert Anderson Thomas Anderson Julian Andrej Mikhail Artemyev Cody Balos Andrew Barker Thomas Benson Adrien Bernede Aaron Black Jamie Bramwell Thomas Brunner Jean-Sylvain Camier Robert Carson Jakub \u010cerven\u00fd Dylan Copeland Johann Dahm Veselin Dobrev Daniel Drzisga Yohann Dudouit Truman Ellis Aaron Fisher David Gardner Pieter Ghysels Hennes Hajduk Cyrus Harrison Stefan Henneking Milan Holec Kazem Kamran Patrick Knupp Tzanio Kolev \u2014 Project Leader Ilya Lashuk Boyan Lazarov Scott MacLachlan Peter Maginot David Medina Mark Miller Ketan Mittal Jan Nikl Geoffrey Oxberry Will Pazner Socratis Petrides Robert Rieben Joachim Sch\u00f6berl Jean Sexton Syun'ichi Shiraiwa Cameron Smith Thomas Stitt Mark Stowell Jeremy Thompson Stanimire Tomov Vladimir Tomov Jean-\u00c9tienne Tremblay Arturo Vargas Umberto Villa Chris Vogl Kenneth Weiss Daniel White Jonathan Wong Stefano Zampini License BSD This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-806117. DOI: 10.11578/dc.20171025.1248 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about/#about-mfem","text":"MFEM originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @article{mfem, title = {{MFEM}: A Modular Finite Element Library}, author = {R. Anderson and J. Andrej and A. Barker and J. Bramwell and J.-S. Camier and J. Cerveny V. Dobrev and Y. Dudouit and A. Fisher and Tz. Kolev and W. Pazner and M. Stowell and V. Tomov and I. Akkerman and J. Dahm and D. Medina and S. Zampini}, journal = {Computers \\& Mathematics with Applications}, doi = {10.1016/j.camwa.2020.06.009}, volume = {81}, pages = {42-74}, year = {2021} } @misc{mfem-web, key = {mfem}, title = {{MFEM}: Modular Finite Element Methods {[Software]}}, howpublished = {\\url{mfem.org}}, doi = {10.11578/dc.20171025.1248} }","title":"About MFEM"},{"location":"about/#contributors","text":"Ido Akkerman Robert Anderson Thomas Anderson Julian Andrej Mikhail Artemyev Cody Balos Andrew Barker Thomas Benson Adrien Bernede Aaron Black Jamie Bramwell Thomas Brunner Jean-Sylvain Camier Robert Carson Jakub \u010cerven\u00fd Dylan Copeland Johann Dahm Veselin Dobrev Daniel Drzisga Yohann Dudouit Truman Ellis Aaron Fisher David Gardner Pieter Ghysels Hennes Hajduk Cyrus Harrison Stefan Henneking Milan Holec Kazem Kamran Patrick Knupp Tzanio Kolev \u2014 Project Leader Ilya Lashuk Boyan Lazarov Scott MacLachlan Peter Maginot David Medina Mark Miller Ketan Mittal Jan Nikl Geoffrey Oxberry Will Pazner Socratis Petrides Robert Rieben Joachim Sch\u00f6berl Jean Sexton Syun'ichi Shiraiwa Cameron Smith Thomas Stitt Mark Stowell Jeremy Thompson Stanimire Tomov Vladimir Tomov Jean-\u00c9tienne Tremblay Arturo Vargas Umberto Villa Chris Vogl Kenneth Weiss Daniel White Jonathan Wong Stefano Zampini","title":"Contributors"},{"location":"about/#license","text":"BSD This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-806117. DOI: 10.11578/dc.20171025.1248 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"License"},{"location":"bilininteg/","text":"Bilinear Form Integrators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions of both the domain and range spaces, therefore bilinear integrators simultaneously compute the integrals of all combinations of the relevant basis functions from the domain and range spaces. This produces a two dimensional array of results that are arranged into a small dense matrix of integral values called a local element (stiffness) matrix . To put this another way, the BilinearForm class builds a global, sparse, finite element matrix, glb_mat , by performing the outer loop in the following pseudocode snippet whereas the BilinearFormIntegrator class performs the nested inner loops to compute the dense local element matrix, loc_mat . for each elem in elements loc_mat = 0.0 for each pt in quadrature_points for each u_j in elem for each v_i in elem loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt) end end end glb_mat += loc_mat end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$ Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$ Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$ The BilinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the BilinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type of Function Argument Type S Scalar Valued Function Coefficient V Vector Valued Function VectorCoefficient D Diagonal Matrix Function VectorCoefficient M General Matrix Function MatrixCoefficient Notation: The integrals performed by the various integrators listed below are shown using inner product notation, $(\\cdot,\\cdot)$, defined as follows. $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$ $$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$ Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$ or $\\vec{v}$ is in the range (or test) space. For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Note that any operators involving a derivative of the range function $v$ or $\\vec{v}$ are computed using integration by parts. This leads to a boundary integral which can be used to apply Neumann boundary conditions. Some of these operators are listed along with their boundary terms in section Weak Operators . Scalar Field Operators These operators require scalar-valued trial spaces. Many of these operators will work with either H1 or L2 basis functions but some that require a gradient operator should be used with H1. Square Operators These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension MassIntegrator H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D DiffusionIntegrator H1 S, M $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ 1D, 2D, 3D Mixed Operators These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedScalarMassIntegrator H1, L2 H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D MixedScalarWeakDivergenceIntegrator H1, L2 H1 V $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ 2D, 3D MixedScalarWeakDerivativeIntegrator H1, L2 H1 S $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ 1D MixedScalarWeakCurlIntegrator H1, L2 ND S $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ 2D MixedVectorProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda}u,\\vec{v})$ $\\vec{\\lambda}u$ 2D, 3D MixedScalarWeakCrossProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$ $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$ 2D MixedScalarWeakGradientIntegrator H1, L2 RT S $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ 2D, 3D MixedDirectionalDerivativeIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cdot\\grad u, v)$ $\\vec{\\lambda}\\cdot\\grad u$ 2D, 3D MixedScalarCrossGradIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cross\\grad u, v)$ $\\vec{\\lambda}\\cross\\grad u$ 2D MixedScalarDerivativeIntegrator H1 H1, L2 S $(\\lambda \\ddx{u}, v)$ $\\lambda\\ddx{u}\\;$ 1D MixedGradGradIntegrator H1 H1 S, D, M $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ 2D, 3D MixedCrossGradGradIntegrator H1 H1 V $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ 2D, 3D MixedVectorGradientIntegrator H1 ND, RT S, D, M $(\\lambda\\grad u,\\vec{v})$ $\\lambda\\grad u$ 2D, 3D MixedCrossGradIntegrator H1 ND, RT V $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$ $\\vec{\\lambda}\\cross\\grad u$ 3D MixedCrossGradCurlIntegrator H1 ND V $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\times\\grad u)$ 3D MixedGradDivIntegrator H1 RT V $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ 2D, 3D Other Scalar Operators Class Name Domain Range Coef. Dimension Operator Notes DerivativeIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$ The direction index \"i\" is passed by the user. See MixedDirectionalDerivativeIntegrator for a more general alternative. ConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\vec{\\lambda}\\cdot\\grad u, v)$ This is designed to be used with BilinearForm to produce a square matrix. See MixedDirectionalDerivativeIntegrator for a rectangular version. GroupConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$ Uses the \"group\" finite element formulation for advection due to Fletcher . BoundaryMassIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\,u,v)$ Computes a mass matrix on the exterior faces of a domain. See MassIntegrator above for a more general version. Vector Finite Element Operators These operators require vector-valued basis functions in the trial space. Many of these operators will work with either ND or RT basis functions but others require one or the other. Square Operators These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension VectorFEMassIntegrator ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D CurlCurlIntegrator ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 2D, 3D DivDivIntegrator RT S $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ 2D, 3D Mixed Operators These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedDotProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cdot\\vec{u},v)$ $\\vec{\\lambda}\\cdot\\vec{u}$ 2D, 3D MixedScalarCrossProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cross\\vec{u},v)$ $\\vec{\\lambda}\\cross\\vec{u}$ 2D MixedVectorWeakDivergenceIntegrator ND, RT H1 S, D, M $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ 2D, 3D MixedWeakDivCrossIntegrator ND, RT H1 V $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedVectorMassIntegrator ND, RT ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D MixedCrossProductIntegrator ND, RT ND, RT V $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\vec{u}$ 3D MixedVectorWeakCurlIntegrator ND, RT ND S, D, M $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ 3D MixedWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedScalarWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 2D MixedWeakGradDotIntegrator ND, RT RT V $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ 2D, 3D MixedScalarCurlIntegrator ND H1, L2 S $(\\lambda\\curl\\vec{u},v)$ $\\lambda\\curl\\vec{u}\\;$ 2D MixedCrossCurlGradIntegrator ND H1 V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedVectorCurlIntegrator ND ND, RT S, D, M $(\\lambda\\curl\\vec{u},\\vec{v})$ $\\lambda\\curl\\vec{u}$ 3D MixedCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\curl\\vec{u}$ 3D MixedScalarCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$ 2D MixedCurlCurlIntegrator ND ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 3D MixedCrossCurlCurlIntegrator ND ND V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedScalarDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ $\\lambda \\div\\vec{u}$ 2D, 3D MixedDivGradIntegrator RT H1 V $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ 2D, 3D MixedVectorDivergenceIntegrator RT ND, RT V $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$ $\\vec{\\lambda}\\div\\vec{u}$ 2D, 3D Other Vector Finite Element Operators Class Name Domain Range Coef. Operator Dimension Notes VectorFEDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ 2D, 3D Alternate implementation of MixedScalarDivergenceIntegrator. VectorFEWeakDivergenceIntegrator ND H1 S $(-\\lambda\\vec{u},\\grad v)$ 2D, 3D See MixedVectorWeakDivergenceIntegrator for a more general implementation. VectorFECurlIntegrator ND, RT ND, RT S $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$ 3D If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations. Vector Field Operators These operators require vector-valued basis functions constructed by using multiple copies of scalar fields. In each of these integrators the scalar basis function index increments most quickly followed by the vector index. This leads to local element matrices that have a block structure. Square Operators Class Name Spaces Coef. Dimension Operator Notes VectorMassIntegrator H1$^d$, L2$^d$ S, D, M 1D, 2D, 3D $(\\lambda\\vec{u},\\vec{v})$ VectorCurlCurlIntegrator H1$^d$, L2$^d$ S 2D, 3D $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ VectorDiffusionIntegrator H1$^d$, L2$^d$ S 1D, 2D, 3D $(\\lambda\\grad u_i,\\grad v_i)$ Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block ElasticityIntegrator H1$^d$, L2$^d$ $2\\times$S 1D, 2D, 3D $(c_{ikjl}\\grad u_j,\\grad v_i)$ Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix. The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$ Mixed Operators Class Name Domain Range Coef. Dimension Operator VectorDivergenceIntegrator H1$^d$, L2$^d$ H1, L2 S 1D, 2D, 3D $(\\lambda\\div\\vec{u},v)$ GradientIntegrator H1 H1$^d$ S 1D, 2D, 3D $(\\lambda\\grad u, \\vec{v})$ Discontinuous Galerkin Operators Class Name Domain Range Operator Notes DGTraceIntegrator H1, L2 H1, L2 $\\alpha \\left<\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right> \\\\ + \\beta \\left<\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right>$ DGDiffusionIntegrator H1, L2 H1, L2 $-\\left<\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right> \\\\ + \\sigma \\left<[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right> \\\\ + \\kappa \\left<\\{h^{-1}Q\\}[u],[v]\\right> $ DGElasticityIntegrator H1, L2 H1, L2 see $(\\ref{dg-elast})$ TraceJumpIntegrator $\\left< v, [w] \\right>$ NormalTraceJumpIntegrator $\\left< v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right>$ Integrator for the DG elasticity form, for the formulations see: PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09, p.3 $$ - \\left< \\{ \\tau(u) \\}, [v] \\right> + \\alpha \\left< \\{ \\tau(v) \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ where $ \\left< u, v\\right> = \\int_{F} u \\cdot v $, and $ F $ is a face which is either a boundary face $ F_b $ of an element $ K $ or an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $. In the bilinear form above $ \\tau(u) $ is traction, and it's also $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $. In other words, we have $$\\label{dg-elast} - \\left< \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right> + \\alpha \\left< \\{ \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ For isotropic media $$ \\begin{split} \\sigma(u) &= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\ &= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u + \\nabla u^T \\right) \\\\ &= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T \\right) \\end{split} $$ where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test functions, respectively. The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to use (when this integrator is added to the \"broken\" ElasticityIntegrator): IIPG , $\\alpha = 0$, C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004. SIPG , $\\alpha = -1$, M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006. NIPG , $\\alpha = 1$, B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite Element Methods Based on Discontinuous Approximation Spaces for Elliptic Problems, SINUM, 39(3), 902-931, 2001. This is a 'Vector' integrator, i.e. defined for FE spaces using multiple copies of a scalar FE space. Special Purpose Integrators These \"integrators\" do not actually perform integrations they merely alter the results of other integrators. As such they provide a convenient and easy way to reuse existing integrators in special situations rather than needing to reimplement their functionality. Class Name Description TransposeIntegrator Returns the transpose of the local matrix computed by another BilinearFormIntegrator LumpedIntegrator Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices) InverseIntegrator Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix SumIntegrator Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices) Weak Operators and Their Boundary Integrals Weak operators use integration by parts to move a spatial derivative onto the test function. This results in an implied boundary integral that is often assumed to be zero but can be used to apply a non-homogeneous Neumann boundary condition. Operator with Scalar Range The following weak operators require the range (or test) space to be $H_1$ i.e. a scalar basis function with a gradient operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an inhomogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DiffusionIntegrator one could provide a known function for $\\lambda\\,\\grad u$ to the BoundaryNormalLFIntegrator which would then integrate the normal component of this function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DiffusionIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedGradGradIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedCrossGradGradIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$ MixedScalarWeakDivergenceIntegrator $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$ MixedScalarWeakDerivativeIntegrator $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$ MixedVectorWeakDivergenceIntegrator $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$ MixedWeakDivCrossIntegrator $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ MixedCrossCurlGradIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedDivGradIntegrator $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$ Operator with Vector Range The following weak operators require the range (or test) space to be H(Curl) i.e. a vector basis function with a curl operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand a non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the CurlCurlIntegrator one could provide a known function for $\\lambda\\,\\curl\\vec{u}$ to the VectorFEBoundaryTangentLFIntegrator which would then integrate the product of the tangential portion of this function with that of the ND basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. CurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCrossCurlCurlIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedCrossGradCurlIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$ MixedVectorWeakCurlIntegrator $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\vec{u}$ MixedScalarWeakCurlIntegrator $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$ MixedWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ MixedScalarWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ The following weak operators require the range (or test) space to be H(Div) i.e. a vector basis function with a divergence operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand a non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DivDivIntegrator one could provide a known function for $\\lambda\\,\\div\\vec{u}$ to the VectorFEBoundaryFluxLFIntegrator which would then integrate the product of this function with the normal component of the RT basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DivDivIntegrator $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}\\,\\hat{n}$ MixedGradDivIntegrator $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$ MixedScalarWeakGradientIntegrator $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ $-\\lambda u\\,\\hat{n}$ MixedWeakGradDotIntegrator $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Bilinear Form Integrators"},{"location":"bilininteg/#bilinear-form-integrators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions of both the domain and range spaces, therefore bilinear integrators simultaneously compute the integrals of all combinations of the relevant basis functions from the domain and range spaces. This produces a two dimensional array of results that are arranged into a small dense matrix of integral values called a local element (stiffness) matrix . To put this another way, the BilinearForm class builds a global, sparse, finite element matrix, glb_mat , by performing the outer loop in the following pseudocode snippet whereas the BilinearFormIntegrator class performs the nested inner loops to compute the dense local element matrix, loc_mat . for each elem in elements loc_mat = 0.0 for each pt in quadrature_points for each u_j in elem for each v_i in elem loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt) end end end glb_mat += loc_mat end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$ Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$ Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$ The BilinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the BilinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type of Function Argument Type S Scalar Valued Function Coefficient V Vector Valued Function VectorCoefficient D Diagonal Matrix Function VectorCoefficient M General Matrix Function MatrixCoefficient Notation: The integrals performed by the various integrators listed below are shown using inner product notation, $(\\cdot,\\cdot)$, defined as follows. $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$ $$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$ Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$ or $\\vec{v}$ is in the range (or test) space. For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Note that any operators involving a derivative of the range function $v$ or $\\vec{v}$ are computed using integration by parts. This leads to a boundary integral which can be used to apply Neumann boundary conditions. Some of these operators are listed along with their boundary terms in section Weak Operators .","title":"Bilinear Form Integrators"},{"location":"bilininteg/#scalar-field-operators","text":"These operators require scalar-valued trial spaces. Many of these operators will work with either H1 or L2 basis functions but some that require a gradient operator should be used with H1.","title":"Scalar Field Operators"},{"location":"bilininteg/#square-operators","text":"These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension MassIntegrator H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D DiffusionIntegrator H1 S, M $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ 1D, 2D, 3D","title":"Square Operators"},{"location":"bilininteg/#mixed-operators","text":"These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedScalarMassIntegrator H1, L2 H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D MixedScalarWeakDivergenceIntegrator H1, L2 H1 V $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ 2D, 3D MixedScalarWeakDerivativeIntegrator H1, L2 H1 S $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ 1D MixedScalarWeakCurlIntegrator H1, L2 ND S $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ 2D MixedVectorProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda}u,\\vec{v})$ $\\vec{\\lambda}u$ 2D, 3D MixedScalarWeakCrossProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$ $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$ 2D MixedScalarWeakGradientIntegrator H1, L2 RT S $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ 2D, 3D MixedDirectionalDerivativeIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cdot\\grad u, v)$ $\\vec{\\lambda}\\cdot\\grad u$ 2D, 3D MixedScalarCrossGradIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cross\\grad u, v)$ $\\vec{\\lambda}\\cross\\grad u$ 2D MixedScalarDerivativeIntegrator H1 H1, L2 S $(\\lambda \\ddx{u}, v)$ $\\lambda\\ddx{u}\\;$ 1D MixedGradGradIntegrator H1 H1 S, D, M $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ 2D, 3D MixedCrossGradGradIntegrator H1 H1 V $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ 2D, 3D MixedVectorGradientIntegrator H1 ND, RT S, D, M $(\\lambda\\grad u,\\vec{v})$ $\\lambda\\grad u$ 2D, 3D MixedCrossGradIntegrator H1 ND, RT V $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$ $\\vec{\\lambda}\\cross\\grad u$ 3D MixedCrossGradCurlIntegrator H1 ND V $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\times\\grad u)$ 3D MixedGradDivIntegrator H1 RT V $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ 2D, 3D","title":"Mixed Operators"},{"location":"bilininteg/#other-scalar-operators","text":"Class Name Domain Range Coef. Dimension Operator Notes DerivativeIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$ The direction index \"i\" is passed by the user. See MixedDirectionalDerivativeIntegrator for a more general alternative. ConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\vec{\\lambda}\\cdot\\grad u, v)$ This is designed to be used with BilinearForm to produce a square matrix. See MixedDirectionalDerivativeIntegrator for a rectangular version. GroupConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$ Uses the \"group\" finite element formulation for advection due to Fletcher . BoundaryMassIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\,u,v)$ Computes a mass matrix on the exterior faces of a domain. See MassIntegrator above for a more general version.","title":"Other Scalar Operators"},{"location":"bilininteg/#vector-finite-element-operators","text":"These operators require vector-valued basis functions in the trial space. Many of these operators will work with either ND or RT basis functions but others require one or the other.","title":"Vector Finite Element Operators"},{"location":"bilininteg/#square-operators_1","text":"These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension VectorFEMassIntegrator ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D CurlCurlIntegrator ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 2D, 3D DivDivIntegrator RT S $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ 2D, 3D","title":"Square Operators"},{"location":"bilininteg/#mixed-operators_1","text":"These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedDotProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cdot\\vec{u},v)$ $\\vec{\\lambda}\\cdot\\vec{u}$ 2D, 3D MixedScalarCrossProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cross\\vec{u},v)$ $\\vec{\\lambda}\\cross\\vec{u}$ 2D MixedVectorWeakDivergenceIntegrator ND, RT H1 S, D, M $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ 2D, 3D MixedWeakDivCrossIntegrator ND, RT H1 V $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedVectorMassIntegrator ND, RT ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D MixedCrossProductIntegrator ND, RT ND, RT V $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\vec{u}$ 3D MixedVectorWeakCurlIntegrator ND, RT ND S, D, M $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ 3D MixedWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedScalarWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 2D MixedWeakGradDotIntegrator ND, RT RT V $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ 2D, 3D MixedScalarCurlIntegrator ND H1, L2 S $(\\lambda\\curl\\vec{u},v)$ $\\lambda\\curl\\vec{u}\\;$ 2D MixedCrossCurlGradIntegrator ND H1 V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedVectorCurlIntegrator ND ND, RT S, D, M $(\\lambda\\curl\\vec{u},\\vec{v})$ $\\lambda\\curl\\vec{u}$ 3D MixedCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\curl\\vec{u}$ 3D MixedScalarCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$ 2D MixedCurlCurlIntegrator ND ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 3D MixedCrossCurlCurlIntegrator ND ND V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedScalarDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ $\\lambda \\div\\vec{u}$ 2D, 3D MixedDivGradIntegrator RT H1 V $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ 2D, 3D MixedVectorDivergenceIntegrator RT ND, RT V $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$ $\\vec{\\lambda}\\div\\vec{u}$ 2D, 3D","title":"Mixed Operators"},{"location":"bilininteg/#other-vector-finite-element-operators","text":"Class Name Domain Range Coef. Operator Dimension Notes VectorFEDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ 2D, 3D Alternate implementation of MixedScalarDivergenceIntegrator. VectorFEWeakDivergenceIntegrator ND H1 S $(-\\lambda\\vec{u},\\grad v)$ 2D, 3D See MixedVectorWeakDivergenceIntegrator for a more general implementation. VectorFECurlIntegrator ND, RT ND, RT S $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$ 3D If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.","title":"Other Vector Finite Element Operators"},{"location":"bilininteg/#vector-field-operators","text":"These operators require vector-valued basis functions constructed by using multiple copies of scalar fields. In each of these integrators the scalar basis function index increments most quickly followed by the vector index. This leads to local element matrices that have a block structure.","title":"Vector Field Operators"},{"location":"bilininteg/#square-operators_2","text":"Class Name Spaces Coef. Dimension Operator Notes VectorMassIntegrator H1$^d$, L2$^d$ S, D, M 1D, 2D, 3D $(\\lambda\\vec{u},\\vec{v})$ VectorCurlCurlIntegrator H1$^d$, L2$^d$ S 2D, 3D $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ VectorDiffusionIntegrator H1$^d$, L2$^d$ S 1D, 2D, 3D $(\\lambda\\grad u_i,\\grad v_i)$ Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block ElasticityIntegrator H1$^d$, L2$^d$ $2\\times$S 1D, 2D, 3D $(c_{ikjl}\\grad u_j,\\grad v_i)$ Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix. The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$","title":"Square Operators"},{"location":"bilininteg/#mixed-operators_2","text":"Class Name Domain Range Coef. Dimension Operator VectorDivergenceIntegrator H1$^d$, L2$^d$ H1, L2 S 1D, 2D, 3D $(\\lambda\\div\\vec{u},v)$ GradientIntegrator H1 H1$^d$ S 1D, 2D, 3D $(\\lambda\\grad u, \\vec{v})$","title":"Mixed Operators"},{"location":"bilininteg/#discontinuous-galerkin-operators","text":"Class Name Domain Range Operator Notes DGTraceIntegrator H1, L2 H1, L2 $\\alpha \\left<\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right> \\\\ + \\beta \\left<\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right>$ DGDiffusionIntegrator H1, L2 H1, L2 $-\\left<\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right> \\\\ + \\sigma \\left<[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right> \\\\ + \\kappa \\left<\\{h^{-1}Q\\}[u],[v]\\right> $ DGElasticityIntegrator H1, L2 H1, L2 see $(\\ref{dg-elast})$ TraceJumpIntegrator $\\left< v, [w] \\right>$ NormalTraceJumpIntegrator $\\left< v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right>$ Integrator for the DG elasticity form, for the formulations see: PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09, p.3 $$ - \\left< \\{ \\tau(u) \\}, [v] \\right> + \\alpha \\left< \\{ \\tau(v) \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ where $ \\left< u, v\\right> = \\int_{F} u \\cdot v $, and $ F $ is a face which is either a boundary face $ F_b $ of an element $ K $ or an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $. In the bilinear form above $ \\tau(u) $ is traction, and it's also $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $. In other words, we have $$\\label{dg-elast} - \\left< \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right> + \\alpha \\left< \\{ \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ For isotropic media $$ \\begin{split} \\sigma(u) &= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\ &= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u + \\nabla u^T \\right) \\\\ &= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T \\right) \\end{split} $$ where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test functions, respectively. The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to use (when this integrator is added to the \"broken\" ElasticityIntegrator): IIPG , $\\alpha = 0$, C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004. SIPG , $\\alpha = -1$, M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006. NIPG , $\\alpha = 1$, B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite Element Methods Based on Discontinuous Approximation Spaces for Elliptic Problems, SINUM, 39(3), 902-931, 2001. This is a 'Vector' integrator, i.e. defined for FE spaces using multiple copies of a scalar FE space.","title":"Discontinuous Galerkin Operators"},{"location":"bilininteg/#special-purpose-integrators","text":"These \"integrators\" do not actually perform integrations they merely alter the results of other integrators. As such they provide a convenient and easy way to reuse existing integrators in special situations rather than needing to reimplement their functionality. Class Name Description TransposeIntegrator Returns the transpose of the local matrix computed by another BilinearFormIntegrator LumpedIntegrator Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices) InverseIntegrator Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix SumIntegrator Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)","title":"Special Purpose Integrators"},{"location":"bilininteg/#weak-operators-and-their-boundary-integrals","text":"Weak operators use integration by parts to move a spatial derivative onto the test function. This results in an implied boundary integral that is often assumed to be zero but can be used to apply a non-homogeneous Neumann boundary condition.","title":"Weak Operators and Their Boundary Integrals"},{"location":"bilininteg/#operator-with-scalar-range","text":"The following weak operators require the range (or test) space to be $H_1$ i.e. a scalar basis function with a gradient operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an inhomogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DiffusionIntegrator one could provide a known function for $\\lambda\\,\\grad u$ to the BoundaryNormalLFIntegrator which would then integrate the normal component of this function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DiffusionIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedGradGradIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedCrossGradGradIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$ MixedScalarWeakDivergenceIntegrator $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$ MixedScalarWeakDerivativeIntegrator $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$ MixedVectorWeakDivergenceIntegrator $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$ MixedWeakDivCrossIntegrator $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ MixedCrossCurlGradIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedDivGradIntegrator $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$","title":"Operator with Scalar Range"},{"location":"bilininteg/#operator-with-vector-range","text":"The following weak operators require the range (or test) space to be H(Curl) i.e. a vector basis function with a curl operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand a non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the CurlCurlIntegrator one could provide a known function for $\\lambda\\,\\curl\\vec{u}$ to the VectorFEBoundaryTangentLFIntegrator which would then integrate the product of the tangential portion of this function with that of the ND basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. CurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCrossCurlCurlIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedCrossGradCurlIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$ MixedVectorWeakCurlIntegrator $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\vec{u}$ MixedScalarWeakCurlIntegrator $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$ MixedWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ MixedScalarWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ The following weak operators require the range (or test) space to be H(Div) i.e. a vector basis function with a divergence operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand a non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DivDivIntegrator one could provide a known function for $\\lambda\\,\\div\\vec{u}$ to the VectorFEBoundaryFluxLFIntegrator which would then integrate the product of this function with the normal component of the RT basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DivDivIntegrator $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}\\,\\hat{n}$ MixedGradDivIntegrator $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$ MixedScalarWeakGradientIntegrator $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ $-\\lambda u\\,\\hat{n}$ MixedWeakGradDotIntegrator $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Operator with Vector Range"},{"location":"building/","text":"Building MFEM A simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the INSTALL file and make help . In addition to the native build system described below, MFEM packages are also available in the following package managers: Spack OpenHPC Homebrew/Science (deprecated) MFEM can also be installed as part of CEED xSDK E4S FASTMath RADIUSS Instructions Download MFEM and GLVis http://mfem.org http://glvis.org Below we assume that we are working with versions 3.4. Serial version of MFEM and GLVis Put everything in the same directory: ~> ls glvis-3.4.tgz mfem-3.4.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-3.4.tgz ~> cd mfem-3.4 ~/mfem-3.4> make serial -j Build GLVis: ~> tar -zxvf glvis-3.4.tgz ~> cd glvis-3.4 ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j That's it! The MFEM library can be found in mfem-3.4/libmfem.a , while the glvis executable will be in the glvis-3.4 directory. Note: as of version 4.0, GLVis has additional dependencies that need to be installed first, see its building documentation . To start a GLVis server, open a new terminal and type ~> cd glvis-3.4 ~/glvis-3.4> ./glvis The serial examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j All serial examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j Parallel MPI version of MFEM Download hypre and METIS from https://github.com/hypre-space/hypre/releases http://glaros.dtc.umn.edu/gkhome/metis/metis/download Below we assume that we are working with hypre version 2.16.0 and METIS version 4.0.3 (see below for METIS version 5 and later). We also assume that the serial version of MFEM and GLVis have been built as described above. Put everything in the same directory: ~> ls glvis-3.4/ hypre-2.16.0.tar.gz metis-4.0.3.tar.gz mfem-3.4/ Build hypre: ~> tar -zxvf hypre-2.16.0.tar.gz ~> cd hypre-2.16.0/src/ ~/hypre-2.16.0/src> ./configure --disable-fortran ~/hypre-2.16.0/src> make -j ~/hypre-2.16.0/src> cd ../.. ~> ln -s hypre-2.16.0 hypre Build METIS: ~> tar -zxvf metis-4.0.3.tar.gz ~> cd metis-4.0.3 ~/metis-4.0.3> make ~/metis-4.0.3> cd .. ~> ln -s metis-4.0.3 metis-4.0 (If you are using METIS 5, see the instructions below .) Build the parallel version of MFEM: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j Note that if hypre or METIS are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the config/defaults.mk file, or create you own config/user.mk , as described in the INSTALL file. The parallel examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j The serial examples can also be build with the parallel version of the library, e.g. ~/mfem-3.4/examples> make ex1 ex2 All parallel examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j One can also use the parallel library to optionally (re-)build GLVis: ~> cd glvis-3.4 ~/glvis-3.4> make clean ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j This, however, is generally not recommended , since the additional MPI thread can interfere with the other GLVis threads. Parallel build using METIS 5 Build METIS 5: ~> tar zvxf metis-5.1.0.tar.gz ~> cd metis-5.1.0 ~/metis-5.1.0> make config ; make ~/metis-5.1.0> mkdir lib ~/metis-5.1.0> ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib Build the parallel version of MFEM, setting the options MFEM_USE_METIS_5 and METIS_DIR , e.g.: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0 CUDA version of MFEM Build the serial CUDA version of MFEM: ~/mfem> make cuda -j Build the parallel CUDA version of MFEM: ~/mfem> make pcuda -j It can be useful to specify the compute capability , with the CUDA_ARCH flag, corresponding to your NVidia GPU. Build the parallel CUDA version of MFEM for sm_70 (NVidia V100): ~/mfem> make pcuda CUDA_ARCH=sm_70 -j HIP version of MFEM Build the serial HIP version of MFEM: ~/mfem> make hip -j Build the parallel HIP version of MFEM: ~/mfem> make phip -j Installing MFEM with Spack If Spack is already available on your system and is visible in your PATH , you can install the MFEM software simply with: spack install mfem To enable package testing during the build process, use instead: spack install -v --test=all mfem If you don't have Spack, you can download it and install MFEM with the following commands: git clone https://github.com/spack/spack.git cd spack ./bin/spack install -v mfem","title":"Building MFEM"},{"location":"building/#building-mfem","text":"A simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the INSTALL file and make help . In addition to the native build system described below, MFEM packages are also available in the following package managers: Spack OpenHPC Homebrew/Science (deprecated) MFEM can also be installed as part of CEED xSDK E4S FASTMath RADIUSS","title":"Building MFEM"},{"location":"building/#instructions","text":"Download MFEM and GLVis http://mfem.org http://glvis.org Below we assume that we are working with versions 3.4.","title":"Instructions"},{"location":"building/#serial-version-of-mfem-and-glvis","text":"Put everything in the same directory: ~> ls glvis-3.4.tgz mfem-3.4.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-3.4.tgz ~> cd mfem-3.4 ~/mfem-3.4> make serial -j Build GLVis: ~> tar -zxvf glvis-3.4.tgz ~> cd glvis-3.4 ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j That's it! The MFEM library can be found in mfem-3.4/libmfem.a , while the glvis executable will be in the glvis-3.4 directory. Note: as of version 4.0, GLVis has additional dependencies that need to be installed first, see its building documentation . To start a GLVis server, open a new terminal and type ~> cd glvis-3.4 ~/glvis-3.4> ./glvis The serial examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j All serial examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j","title":"Serial version of MFEM and GLVis"},{"location":"building/#parallel-mpi-version-of-mfem","text":"Download hypre and METIS from https://github.com/hypre-space/hypre/releases http://glaros.dtc.umn.edu/gkhome/metis/metis/download Below we assume that we are working with hypre version 2.16.0 and METIS version 4.0.3 (see below for METIS version 5 and later). We also assume that the serial version of MFEM and GLVis have been built as described above. Put everything in the same directory: ~> ls glvis-3.4/ hypre-2.16.0.tar.gz metis-4.0.3.tar.gz mfem-3.4/ Build hypre: ~> tar -zxvf hypre-2.16.0.tar.gz ~> cd hypre-2.16.0/src/ ~/hypre-2.16.0/src> ./configure --disable-fortran ~/hypre-2.16.0/src> make -j ~/hypre-2.16.0/src> cd ../.. ~> ln -s hypre-2.16.0 hypre Build METIS: ~> tar -zxvf metis-4.0.3.tar.gz ~> cd metis-4.0.3 ~/metis-4.0.3> make ~/metis-4.0.3> cd .. ~> ln -s metis-4.0.3 metis-4.0 (If you are using METIS 5, see the instructions below .) Build the parallel version of MFEM: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j Note that if hypre or METIS are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the config/defaults.mk file, or create you own config/user.mk , as described in the INSTALL file. The parallel examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j The serial examples can also be build with the parallel version of the library, e.g. ~/mfem-3.4/examples> make ex1 ex2 All parallel examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j One can also use the parallel library to optionally (re-)build GLVis: ~> cd glvis-3.4 ~/glvis-3.4> make clean ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j This, however, is generally not recommended , since the additional MPI thread can interfere with the other GLVis threads.","title":"Parallel MPI version of MFEM"},{"location":"building/#parallel-build-using-metis-5","text":"Build METIS 5: ~> tar zvxf metis-5.1.0.tar.gz ~> cd metis-5.1.0 ~/metis-5.1.0> make config ; make ~/metis-5.1.0> mkdir lib ~/metis-5.1.0> ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib Build the parallel version of MFEM, setting the options MFEM_USE_METIS_5 and METIS_DIR , e.g.: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0","title":"Parallel build using METIS 5"},{"location":"building/#cuda-version-of-mfem","text":"Build the serial CUDA version of MFEM: ~/mfem> make cuda -j Build the parallel CUDA version of MFEM: ~/mfem> make pcuda -j It can be useful to specify the compute capability , with the CUDA_ARCH flag, corresponding to your NVidia GPU. Build the parallel CUDA version of MFEM for sm_70 (NVidia V100): ~/mfem> make pcuda CUDA_ARCH=sm_70 -j","title":"CUDA version of MFEM"},{"location":"building/#hip-version-of-mfem","text":"Build the serial HIP version of MFEM: ~/mfem> make hip -j Build the parallel HIP version of MFEM: ~/mfem> make phip -j","title":"HIP version of MFEM"},{"location":"building/#installing-mfem-with-spack","text":"If Spack is already available on your system and is visible in your PATH , you can install the MFEM software simply with: spack install mfem To enable package testing during the build process, use instead: spack install -v --test=all mfem If you don't have Spack, you can download it and install MFEM with the following commands: git clone https://github.com/spack/spack.git cd spack ./bin/spack install -v mfem","title":"Installing MFEM with Spack"},{"location":"code-overview/","text":"Code Overview MFEM consists of the following closely interconnected modules: General - general data structures and algorithms. Linear Algebra - linear algebra, linear and nonlinear solvers, time steppers. Mesh - mesh class, mesh readers, mesh manipulation. FEM - finite elements, spaces, linear and bilinear forms, etc. General Array Class Array<T> . Similar to std::vector<T> in many respects. Can allocate and manage data or hold external data. Hash table Class HashTable<T> . Used in the NCMesh class. Table Class Table . Maps each row, {0,1,..,n-1} , to a list of integers (columns). This is CSR-like data structure without data, only the ' I ' and ' J ' arrays. Represents relations like vertex-to-element , element-to-dof , etc. Dynamic symmetric table Class DSTable is a dynamic symmetric version of the Table class. Used for building relations like vertex-to-vertex - mesh edges. Dynamic symmetric 3D table Class STable3D . Used for building vertex-to-vertex-to-vertex relations - mesh faces in 3D. Communication Classes GroupTopology , GroupCommunicator . Groups are sets of MPI ranks that need to exchange common data at processor boundaries. Reduce (gather) and broadcast (scatter) MPI communications within groups . Socket stream Class socketstream Two-way TCP sockets as c++ streams. Can be compiled with GnuTLS for security. Primarily used for sending data to GLVis. Timers Class StopWatch . Has various \"backends\" - std::clock , POSIX clocks, Windows' QueryPerformanceCounter etc. Options parser Class OptionsParser . Makes it easy to define and parse command line parameters. Used in all examples and miniapps. Linear Algebra Vector Class Vector - a vector of double s. Can allocate and manage data or warp external data. Defines a number of vector operations on the data. Operator Class Operator An abstract base class for all linear and non-linear operators. Virtual method Mult(const Vector &, Vector &) . Optional virtual method Operator &GetGradient(const Vector &x) . Dense matrix Class DenseMatrix - a matrix of double s. Can allocate and manage data or wrap external data. Uses column-major storage. Defines a number of matrix operations, matrix-vector, etc. Inherits from Operator . Dense tensor Class DenseTensor Can be viewed as an array of DenseMatrix (of the same size). Can be used in batched matrix operations. Sparse matrix Class SparseMatrix - int indices, double data. Compressed sparse row (CSR) or linked list (LIL) storage. Various operations: assembly, matrix-vector, smoothers, etc. Inherits from Operator . Parallel hypre vector Class HypreParVector - wraps hypre's data structure & operations. Parallel hypre matrix Class HypreParMatrix - wraps hypre's data structure & operations. Solvers Abstract base class Solver - extends (inherits) class Operator . Adds virtual method void SetOperator(const Operator &) . Direct dense solver Class DenseMatrixInverse - inherits Solver . Inverts dense matrices, class DenseMatrix . Uses standard LU factorization with pivoting. Iterative solvers Krylov methods, Newton method. Direct sparse solvers Classes UMFPackSolver , KLUSolver - wraps UMFPACK and KLU from SuiteSparse; can be used with SparseMatrix (serial). Class SuperLUSolver - wraps SuperLU_DIST; the parallel matrix needs to be converted to SuperLURowLocMatrix . Class STRUMPACKSolver - wraps STRUMPACK; the parallel matrix needs to be converted to STRUMPACKLURowLocMatrix . Hypre preconditioners and solvers Classes HypreBoomerAMG , HypreAMS , ect. Classes HyprePCG , HypreGMRES . Time dependent operator Class TimeDependentOperator , inherits from Operator . Implements basic virtual methods double GetTime() and void SetTime(const double) . Optional virtual method void ImplicitSolve(const double dt, const Vector &x, Vector &k) - solve backward Euler system; required for implicit time steppers. ODE solvers Abstract base class ODESolver . Has virtual method void Init(TimeDependentOperator &) . Has pure virtual method void Step(Vector &x, double &t, double &dt) . Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods. Symplectic Integrators for Hamiltonian Systems Abstract base class 'SIASolver'. Has virtual method void Init(Operator &, TimeDependentOperator &) . Has pure virtual method void Step(Vector &q, Vector &p, double &t, double &dt) . Derived classes for explicit first and second order integrators. Derived class supporting integration orders from 1 to 4. Constraint operator Class ConstrainedOperator , inherits from Operator . Impose essential boundary conditions on any Operator (matrix-free). Used by Operator::FormLinearSystem() . Block vector Class BlockVector , inherits from Vector . Holds a set of multiple contiguously allocated vectors. Useful for systems of equations with multiple components using different finite element spaces. Block operator Class BlockOperator , inherits from Operator . Each block is itself an Operator . Block matrix Class BlockMatrix , inherits AbstractSparseMatrix . Each block is a SparseMatrix . Supports more operations than BlockOperator . Block diagonal preconditioner Class BlockDiagonalPreconditioner , inherits Solver . Similar to BlockOperator but with diagonal block structure and square diagonal blocks. Mesh Mesh Class Mesh . The mesh topology/connectivity is given by element-to-vertex relation. Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and attribute ( int ). Boundary elements can be included allowing tagging of boundary subsets, e.g. for boundary conditions, by the boundary element attribute. Edges, faces, and other connectivity are derived automatically based on the element type. A high-order mesh uses a vector FE function, i.e. a vector GridFunction , to represent its high-order nodes . Hanging/slave vertices are regular vertices - the mesh is \"cut\" along non-conforming edges and faces. Conforming constraints and interpolation are added at the level of the FiniteElementSpace based on additional data from the Mesh and NCMesh objects. Local conforming refinement for triangles and tets. Local non-conforming refinement for triangles, quads, and hexes. De-refinement and parallel rebalancing for non-conforming meshes. Supports curve and surface meshes. Periodic meshes: periodic topology with a DG GridFunction as nodes, cut along the periodic edges/faces. Non-conforming mesh Class NCMesh . Used through class Mesh . Supports triangles, quads, and hexes including anisotropic refinement for quads and hexes. Arbitrary level of hanging nodes and full refinement hierarchy. Generates the \"cut\" Mesh from the leaf elements. NURBS mesh Class NURBSExtension . Used through class Mesh . The NURBS patch connectivity is itself a quad/hex Mesh . Supports knot insertion, degree elevation, (serial, uniform) h-refinement. Generates a quad/hex Mesh . Easy to convert to a polynomial high-order mesh. Mesh readers and writers Own formats, read and write, for: MFEM mesh v1.0 , MFEM mesh v1.1 (extension for non-conforming meshes), MFEM NURBS mesh v1.0 , and MFEM INLINE mesh v1.0 (boxes). Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files. Write linear and quadratic VTK meshes. Parallel mesh Classes ParMesh , ParNCMesh , ParNURBSExtension . Inherit and extend classes Mesh , NCMesh , NURBSExtension . ParMesh is constructed from a serial Mesh available on all tasks. Built-in mesh partitioning is based on METIS. Parallel conforming and non-conforming refinement. Mesh operators Classes ThresholdRefiner , ThresholdDerefiner , Rebalancer . Finite Elements Quadrature formulas Class IntegrationPoint - coordinates plus weights. Class IntegrationRule - an array of IntegrationPoint s. Class IntegrationRules - container for IntegrationRule s. Element transformation Class ElementTransformation , IsoparametricTransformation . Defined through a FiniteElement Transforms reference IntegrationPoint s into physical Vector s. On demand, computes and stores Jacobian matrix, and weight. Finite elements Abstract base class FiniteElement . Arbitrary order H1_* , L2_* , RT_* , and ND_* elements on segment, triangles, quads, tets, and hexes. Abstract method CalcShape , CalcDShape for scalar FE; CalcVShape , CalcDivShape , CalcCurlShape for vector H(div)/H(curl) FE. Other interpolation and projection methods. Finite element collections Base class FiniteElementCollection . Associates FiniteElement s with elements, faces, edges, vertices. Degrees of freedom on faces/edges/vertices are shared between adjacent elements. Derived classes for arbitrary order H1_* , L2_* , RT_* , and ND_* collections. Finite element space Class FiniteElementSpace . Constructed from a Mesh and a FiniteElementCollection . Defines the mappings elements-to-dofs , faces-to-dofs , etc. Defines, when necessary, a prolongation, P , and a restriction, R , matrices: R.P = I to constrain \"slave\" dofs. On non-conforming meshes, the space is \"cut\" or \"partially conforming\" (before applying P ). The domain of P defines the \"true\" or \"conforming\" dofs. The range of P is a sub-set of the \"partially conforming\" dofs. Grid function Class GridFunction , extends class Vector . A container Vector on the \"partially conforming\" dofs. Defines a number of useful operations like computing values, gradient, etc at quadrature points ( IntegrationPoint or IntegrationRule ). Methods for projecting (interpolating) Coefficient , VectorCoefficient . Methods for computing error norms with respect to a Coefficient . Linear form Class LinearForm , extends class Vector . Assembles r.h.s. vector. Uses a sum of local LinearFormIntegrator s. Bilinear form Class BilinearForm . Assembles linear system matrix. Uses a sum of local BilinearFormIntegrator s. Method FormLinearSystem applies necessary transformations, e.g. $P^T A P$. Mixed bilinear form Class MixedBilinearForm . Coefficients Abstract base classes: Coefficient , VectorCoefficient , and MatrixCoefficient . Derived classes include: ConstantCoefficient , FunctionCoefficient , GridFunctionCoefficient ; VectorFunctionCoefficient , VectorGridFunctionCoefficient , etc. Easy to derive new coefficient classes. Parallel versions ParFiniteElementSpace ParGridFunction ParLinearForm ParBilinearForm etc Error estimators Classes ZienkiewiczZhuEstimator , L2ZienkiewiczZhuEstimator . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Code Overview"},{"location":"code-overview/#code-overview","text":"MFEM consists of the following closely interconnected modules: General - general data structures and algorithms. Linear Algebra - linear algebra, linear and nonlinear solvers, time steppers. Mesh - mesh class, mesh readers, mesh manipulation. FEM - finite elements, spaces, linear and bilinear forms, etc.","title":"Code Overview"},{"location":"code-overview/#general","text":"","title":"General"},{"location":"code-overview/#array","text":"Class Array<T> . Similar to std::vector<T> in many respects. Can allocate and manage data or hold external data.","title":"Array"},{"location":"code-overview/#hash-table","text":"Class HashTable<T> . Used in the NCMesh class.","title":"Hash table"},{"location":"code-overview/#table","text":"Class Table . Maps each row, {0,1,..,n-1} , to a list of integers (columns). This is CSR-like data structure without data, only the ' I ' and ' J ' arrays. Represents relations like vertex-to-element , element-to-dof , etc.","title":"Table"},{"location":"code-overview/#dynamic-symmetric-table","text":"Class DSTable is a dynamic symmetric version of the Table class. Used for building relations like vertex-to-vertex - mesh edges.","title":"Dynamic symmetric table"},{"location":"code-overview/#dynamic-symmetric-3d-table","text":"Class STable3D . Used for building vertex-to-vertex-to-vertex relations - mesh faces in 3D.","title":"Dynamic symmetric 3D table"},{"location":"code-overview/#communication","text":"Classes GroupTopology , GroupCommunicator . Groups are sets of MPI ranks that need to exchange common data at processor boundaries. Reduce (gather) and broadcast (scatter) MPI communications within groups .","title":"Communication"},{"location":"code-overview/#socket-stream","text":"Class socketstream Two-way TCP sockets as c++ streams. Can be compiled with GnuTLS for security. Primarily used for sending data to GLVis.","title":"Socket stream"},{"location":"code-overview/#timers","text":"Class StopWatch . Has various \"backends\" - std::clock , POSIX clocks, Windows' QueryPerformanceCounter etc.","title":"Timers"},{"location":"code-overview/#options-parser","text":"Class OptionsParser . Makes it easy to define and parse command line parameters. Used in all examples and miniapps.","title":"Options parser"},{"location":"code-overview/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"code-overview/#vector","text":"Class Vector - a vector of double s. Can allocate and manage data or warp external data. Defines a number of vector operations on the data.","title":"Vector"},{"location":"code-overview/#operator","text":"Class Operator An abstract base class for all linear and non-linear operators. Virtual method Mult(const Vector &, Vector &) . Optional virtual method Operator &GetGradient(const Vector &x) .","title":"Operator"},{"location":"code-overview/#dense-matrix","text":"Class DenseMatrix - a matrix of double s. Can allocate and manage data or wrap external data. Uses column-major storage. Defines a number of matrix operations, matrix-vector, etc. Inherits from Operator .","title":"Dense matrix"},{"location":"code-overview/#dense-tensor","text":"Class DenseTensor Can be viewed as an array of DenseMatrix (of the same size). Can be used in batched matrix operations.","title":"Dense tensor"},{"location":"code-overview/#sparse-matrix","text":"Class SparseMatrix - int indices, double data. Compressed sparse row (CSR) or linked list (LIL) storage. Various operations: assembly, matrix-vector, smoothers, etc. Inherits from Operator .","title":"Sparse matrix"},{"location":"code-overview/#parallel-hypre-vector","text":"Class HypreParVector - wraps hypre's data structure & operations.","title":"Parallel hypre vector"},{"location":"code-overview/#parallel-hypre-matrix","text":"Class HypreParMatrix - wraps hypre's data structure & operations.","title":"Parallel hypre matrix"},{"location":"code-overview/#solvers","text":"Abstract base class Solver - extends (inherits) class Operator . Adds virtual method void SetOperator(const Operator &) .","title":"Solvers"},{"location":"code-overview/#direct-dense-solver","text":"Class DenseMatrixInverse - inherits Solver . Inverts dense matrices, class DenseMatrix . Uses standard LU factorization with pivoting.","title":"Direct dense solver"},{"location":"code-overview/#iterative-solvers","text":"Krylov methods, Newton method.","title":"Iterative solvers"},{"location":"code-overview/#direct-sparse-solvers","text":"Classes UMFPackSolver , KLUSolver - wraps UMFPACK and KLU from SuiteSparse; can be used with SparseMatrix (serial). Class SuperLUSolver - wraps SuperLU_DIST; the parallel matrix needs to be converted to SuperLURowLocMatrix . Class STRUMPACKSolver - wraps STRUMPACK; the parallel matrix needs to be converted to STRUMPACKLURowLocMatrix .","title":"Direct sparse solvers"},{"location":"code-overview/#hypre-preconditioners-and-solvers","text":"Classes HypreBoomerAMG , HypreAMS , ect. Classes HyprePCG , HypreGMRES .","title":"Hypre preconditioners and solvers"},{"location":"code-overview/#time-dependent-operator","text":"Class TimeDependentOperator , inherits from Operator . Implements basic virtual methods double GetTime() and void SetTime(const double) . Optional virtual method void ImplicitSolve(const double dt, const Vector &x, Vector &k) - solve backward Euler system; required for implicit time steppers.","title":"Time dependent operator"},{"location":"code-overview/#ode-solvers","text":"Abstract base class ODESolver . Has virtual method void Init(TimeDependentOperator &) . Has pure virtual method void Step(Vector &x, double &t, double &dt) . Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods.","title":"ODE solvers"},{"location":"code-overview/#symplectic-integrators-for-hamiltonian-systems","text":"Abstract base class 'SIASolver'. Has virtual method void Init(Operator &, TimeDependentOperator &) . Has pure virtual method void Step(Vector &q, Vector &p, double &t, double &dt) . Derived classes for explicit first and second order integrators. Derived class supporting integration orders from 1 to 4.","title":"Symplectic Integrators for Hamiltonian Systems"},{"location":"code-overview/#constraint-operator","text":"Class ConstrainedOperator , inherits from Operator . Impose essential boundary conditions on any Operator (matrix-free). Used by Operator::FormLinearSystem() .","title":"Constraint operator"},{"location":"code-overview/#block-vector","text":"Class BlockVector , inherits from Vector . Holds a set of multiple contiguously allocated vectors. Useful for systems of equations with multiple components using different finite element spaces.","title":"Block vector"},{"location":"code-overview/#block-operator","text":"Class BlockOperator , inherits from Operator . Each block is itself an Operator .","title":"Block operator"},{"location":"code-overview/#block-matrix","text":"Class BlockMatrix , inherits AbstractSparseMatrix . Each block is a SparseMatrix . Supports more operations than BlockOperator .","title":"Block matrix"},{"location":"code-overview/#block-diagonal-preconditioner","text":"Class BlockDiagonalPreconditioner , inherits Solver . Similar to BlockOperator but with diagonal block structure and square diagonal blocks.","title":"Block diagonal preconditioner"},{"location":"code-overview/#mesh","text":"","title":"Mesh"},{"location":"code-overview/#mesh_1","text":"Class Mesh . The mesh topology/connectivity is given by element-to-vertex relation. Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and attribute ( int ). Boundary elements can be included allowing tagging of boundary subsets, e.g. for boundary conditions, by the boundary element attribute. Edges, faces, and other connectivity are derived automatically based on the element type. A high-order mesh uses a vector FE function, i.e. a vector GridFunction , to represent its high-order nodes . Hanging/slave vertices are regular vertices - the mesh is \"cut\" along non-conforming edges and faces. Conforming constraints and interpolation are added at the level of the FiniteElementSpace based on additional data from the Mesh and NCMesh objects. Local conforming refinement for triangles and tets. Local non-conforming refinement for triangles, quads, and hexes. De-refinement and parallel rebalancing for non-conforming meshes. Supports curve and surface meshes. Periodic meshes: periodic topology with a DG GridFunction as nodes, cut along the periodic edges/faces.","title":"Mesh"},{"location":"code-overview/#non-conforming-mesh","text":"Class NCMesh . Used through class Mesh . Supports triangles, quads, and hexes including anisotropic refinement for quads and hexes. Arbitrary level of hanging nodes and full refinement hierarchy. Generates the \"cut\" Mesh from the leaf elements.","title":"Non-conforming mesh"},{"location":"code-overview/#nurbs-mesh","text":"Class NURBSExtension . Used through class Mesh . The NURBS patch connectivity is itself a quad/hex Mesh . Supports knot insertion, degree elevation, (serial, uniform) h-refinement. Generates a quad/hex Mesh . Easy to convert to a polynomial high-order mesh.","title":"NURBS mesh"},{"location":"code-overview/#mesh-readers-and-writers","text":"Own formats, read and write, for: MFEM mesh v1.0 , MFEM mesh v1.1 (extension for non-conforming meshes), MFEM NURBS mesh v1.0 , and MFEM INLINE mesh v1.0 (boxes). Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files. Write linear and quadratic VTK meshes.","title":"Mesh readers and writers"},{"location":"code-overview/#parallel-mesh","text":"Classes ParMesh , ParNCMesh , ParNURBSExtension . Inherit and extend classes Mesh , NCMesh , NURBSExtension . ParMesh is constructed from a serial Mesh available on all tasks. Built-in mesh partitioning is based on METIS. Parallel conforming and non-conforming refinement.","title":"Parallel mesh"},{"location":"code-overview/#mesh-operators","text":"Classes ThresholdRefiner , ThresholdDerefiner , Rebalancer .","title":"Mesh operators"},{"location":"code-overview/#finite-elements","text":"","title":"Finite Elements"},{"location":"code-overview/#quadrature-formulas","text":"Class IntegrationPoint - coordinates plus weights. Class IntegrationRule - an array of IntegrationPoint s. Class IntegrationRules - container for IntegrationRule s.","title":"Quadrature formulas"},{"location":"code-overview/#element-transformation","text":"Class ElementTransformation , IsoparametricTransformation . Defined through a FiniteElement Transforms reference IntegrationPoint s into physical Vector s. On demand, computes and stores Jacobian matrix, and weight.","title":"Element transformation"},{"location":"code-overview/#finite-elements_1","text":"Abstract base class FiniteElement . Arbitrary order H1_* , L2_* , RT_* , and ND_* elements on segment, triangles, quads, tets, and hexes. Abstract method CalcShape , CalcDShape for scalar FE; CalcVShape , CalcDivShape , CalcCurlShape for vector H(div)/H(curl) FE. Other interpolation and projection methods.","title":"Finite elements"},{"location":"code-overview/#finite-element-collections","text":"Base class FiniteElementCollection . Associates FiniteElement s with elements, faces, edges, vertices. Degrees of freedom on faces/edges/vertices are shared between adjacent elements. Derived classes for arbitrary order H1_* , L2_* , RT_* , and ND_* collections.","title":"Finite element collections"},{"location":"code-overview/#finite-element-space","text":"Class FiniteElementSpace . Constructed from a Mesh and a FiniteElementCollection . Defines the mappings elements-to-dofs , faces-to-dofs , etc. Defines, when necessary, a prolongation, P , and a restriction, R , matrices: R.P = I to constrain \"slave\" dofs. On non-conforming meshes, the space is \"cut\" or \"partially conforming\" (before applying P ). The domain of P defines the \"true\" or \"conforming\" dofs. The range of P is a sub-set of the \"partially conforming\" dofs.","title":"Finite element space"},{"location":"code-overview/#grid-function","text":"Class GridFunction , extends class Vector . A container Vector on the \"partially conforming\" dofs. Defines a number of useful operations like computing values, gradient, etc at quadrature points ( IntegrationPoint or IntegrationRule ). Methods for projecting (interpolating) Coefficient , VectorCoefficient . Methods for computing error norms with respect to a Coefficient .","title":"Grid function"},{"location":"code-overview/#linear-form","text":"Class LinearForm , extends class Vector . Assembles r.h.s. vector. Uses a sum of local LinearFormIntegrator s.","title":"Linear form"},{"location":"code-overview/#bilinear-form","text":"Class BilinearForm . Assembles linear system matrix. Uses a sum of local BilinearFormIntegrator s. Method FormLinearSystem applies necessary transformations, e.g. $P^T A P$.","title":"Bilinear form"},{"location":"code-overview/#mixed-bilinear-form","text":"Class MixedBilinearForm .","title":"Mixed bilinear form"},{"location":"code-overview/#coefficients","text":"Abstract base classes: Coefficient , VectorCoefficient , and MatrixCoefficient . Derived classes include: ConstantCoefficient , FunctionCoefficient , GridFunctionCoefficient ; VectorFunctionCoefficient , VectorGridFunctionCoefficient , etc. Easy to derive new coefficient classes.","title":"Coefficients"},{"location":"code-overview/#parallel-versions","text":"ParFiniteElementSpace ParGridFunction ParLinearForm ParBilinearForm etc","title":"Parallel versions"},{"location":"code-overview/#error-estimators","text":"Classes ZienkiewiczZhuEstimator , L2ZienkiewiczZhuEstimator . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Error estimators"},{"location":"coefficient/","text":"Coefficients Coefficient objects serve many purposes within MFEM. As the name suggests they often represent the material coefficients appearing in partial differential equations. However, Coefficients can also be used to specify initial conditions, boundary conditions, exact solutions, etc.. Coefficients come in three varieties; scalar-valued, vector-valued, and matrix-valued. The primary purpose of any Coefficient class is to define an Eval method which returns a scalar, vector, or matrix given an element and a location within that element expressed as a point in reference space i.e. an IntegrationPoint . Coefficients can also be time dependent. Time is treated as a parameter which changes infrequently by passing the current time though a SetTime(t) method. A Coefficient's Eval method depends on not only the position within an element but also on the element attribute number which allows the Coefficient to return different results from different regions of the domain or boundary. This can be a powerful feature but it can lead to unexpected results. As a rule domain integrals will have access to element attributes and boundary integrals will access the boundary attributes. This seems obvious but there may be cases where the outcome is not so clear cut and careful thought is required. It is important to know when a Coefficient will be accessed, particularly in the case of time-dependent or field-dependent coefficients. When used with GridFunction::Project , GridFunction::ComputeL2Error , and other GridFunction methods the Coefficient is used immediately. When used in BilinearForm and LinearForm objects the coefficients are only accessed during calls to the Assemble methods. An important side note is that GridFunction and LinearForm objects will overwrite their values during such calls but a BilinearForm will not. Consequently, when using a time-dependent coefficient with a BilinearForm object it is crucial that the user calls BilinearForm::Update to reset the internally stored matrix to zero before calling BilinearForm::Assemble . Otherwise the new matrix entries will be added to the previous values leading to odd behavior. Scalar Coefficients Basic Scalar Coefficients Class Name Description ConstantCoefficient Returns a constant value: $\\alpha$ FunctionCoefficient Computes a value from a standard function, $f(\\vec{x},t)$, or a lambda expression PWConstCoefficient Returns different constants based e.g. on element attribute GridFunctionCoefficient Returns values interpolated from a scalar-valued GridFunction : $u(\\vec{x})$ DivergenceGridFunctionCoefficient Returns the divergence of a vector-valued GridFunction : $\\nabla\\cdot\\vec{u}$ DeltaCoefficient A weighted Dirac delta function: $s\\,w(\\vec{x},t)\\,T(t)\\,\\delta(\\vec{x}-\\vec{x}_c)$ Derived Scalar Coefficients These classes provide a means of creating functions of existing coefficients. In performance critical situations it would clearly be preferable to write specialized Coefficient classes but these offer a quick and, hopefully, easy to use alternative. Class Name Formula TransformedCoefficient $T(Q_1(\\vec{x},t))\\mbox{ or }T(Q_1(\\vec{x},t),Q_2(\\vec{x},t))$ RestrictedCoefficient $Q(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ SumCoefficient $\\alpha\\,Q_1(\\vec{x}) + \\beta\\,Q_2(\\vec{x})$ ProductCoefficient $Q_1(\\vec{x})\\,Q_2(\\vec{x})$ PowerCoefficient $Q(\\vec{x})^p$ InnerProductCoefficient $\\vec{Q}_1\\cdot\\vec{Q}_2$ VectorRotProductCoefficient $\\vec{Q}_1\\times\\vec{Q}_2\\mbox{ in }\\mathbb{R}^2$ DeterminantCoefficient $|\\overleftrightarrow{Q}|$ Vector Coefficients Basic Vector Coefficients Class Name Description VectorConstantCoefficient Returns a constant vector value: $\\vec{\\alpha}$ VectorFunctionCoefficient Computes a value from a standard function, $\\vec{f}(\\vec{x})$, or a lambda expression VectorGridFunctionCoefficient Returns values interpolated from a vector-valued GridFunction : $\\vec{u}(\\vec{x})$ GradientGridFunctionCoefficient Returns the gradient of a scalar-valued GridFunction : $\\nabla u(\\vec{x})$ CurlGridFunctionCoefficient Returns the curl of a vector-valued GridFunction : $\\nabla\\times\\vec{u}(\\vec{x})$ VectorDeltaCoefficient $s\\,\\vec{\\alpha}\\,\\delta(\\vec{x}-\\vec{x}_c)$ Derived Vector Coefficients Again these classes provide a means of creating functions of existing coefficients. Class Name Formula VectorArrayCoefficient Construct a vector value from an array of scalar coefficients: $\\vec{Q}_a$ VectorRestrictedCoefficient $\\vec{Q}(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ VectorSumCoefficient $\\alpha\\,\\vec{Q}_1(\\vec{x}) + \\beta\\,\\vec{Q}_2(\\vec{x})$ ScalarVectorProductCoefficient $Q_1\\,\\vec{Q}_2$ VectorCrossProductCoefficient $\\vec{Q}_1\\times\\vec{Q}_2$ MatVecCoefficient $\\overleftrightarrow{Q}_1\\cdot\\vec{Q}_2$ Matrix Coefficients Basic Matrix Coefficients Class Name Description MatrixConstantCoefficient Returns a constant matrix value: $\\overleftrightarrow{\\alpha}$ MatrixFunctionCoefficient Computes a value from a standard function, $\\overleftrightarrow{f}$, or a lambda expression IdentityMatrixCoefficient Returns the identity matrix of the appropriate dimension: $\\overleftrightarrow{I}$ Derived Matrix Coefficients Again these classes provide a means of creating functions of existing coefficients. Class Name Formula MatrixArrayCoefficient Construct a matrix value from an array of scalar coefficients: $\\overleftrightarrow{Q}_a$ MatrixRestrictedCoefficient $\\overleftrightarrow{Q}(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ MatrixSumCoefficient $\\alpha\\,\\overleftrightarrow{Q}_1(\\vec{x}) + \\beta\\,\\overleftrightarrow{Q}_2(\\vec{x})$ ScalarMatrixProductCoefficient $Q_1\\,\\overleftrightarrow{Q}_2$ TransposeMatrixCoefficient $\\overleftrightarrow{Q}^T$ InverseMatrixCoefficient $\\overleftrightarrow{Q}^{-1}$ OuterProductCoefficient $\\vec{Q}_1\\otimes\\vec{Q}_2$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Coefficients"},{"location":"coefficient/#coefficients","text":"Coefficient objects serve many purposes within MFEM. As the name suggests they often represent the material coefficients appearing in partial differential equations. However, Coefficients can also be used to specify initial conditions, boundary conditions, exact solutions, etc.. Coefficients come in three varieties; scalar-valued, vector-valued, and matrix-valued. The primary purpose of any Coefficient class is to define an Eval method which returns a scalar, vector, or matrix given an element and a location within that element expressed as a point in reference space i.e. an IntegrationPoint . Coefficients can also be time dependent. Time is treated as a parameter which changes infrequently by passing the current time though a SetTime(t) method. A Coefficient's Eval method depends on not only the position within an element but also on the element attribute number which allows the Coefficient to return different results from different regions of the domain or boundary. This can be a powerful feature but it can lead to unexpected results. As a rule domain integrals will have access to element attributes and boundary integrals will access the boundary attributes. This seems obvious but there may be cases where the outcome is not so clear cut and careful thought is required. It is important to know when a Coefficient will be accessed, particularly in the case of time-dependent or field-dependent coefficients. When used with GridFunction::Project , GridFunction::ComputeL2Error , and other GridFunction methods the Coefficient is used immediately. When used in BilinearForm and LinearForm objects the coefficients are only accessed during calls to the Assemble methods. An important side note is that GridFunction and LinearForm objects will overwrite their values during such calls but a BilinearForm will not. Consequently, when using a time-dependent coefficient with a BilinearForm object it is crucial that the user calls BilinearForm::Update to reset the internally stored matrix to zero before calling BilinearForm::Assemble . Otherwise the new matrix entries will be added to the previous values leading to odd behavior.","title":"Coefficients"},{"location":"coefficient/#scalar-coefficients","text":"","title":"Scalar Coefficients"},{"location":"coefficient/#basic-scalar-coefficients","text":"Class Name Description ConstantCoefficient Returns a constant value: $\\alpha$ FunctionCoefficient Computes a value from a standard function, $f(\\vec{x},t)$, or a lambda expression PWConstCoefficient Returns different constants based e.g. on element attribute GridFunctionCoefficient Returns values interpolated from a scalar-valued GridFunction : $u(\\vec{x})$ DivergenceGridFunctionCoefficient Returns the divergence of a vector-valued GridFunction : $\\nabla\\cdot\\vec{u}$ DeltaCoefficient A weighted Dirac delta function: $s\\,w(\\vec{x},t)\\,T(t)\\,\\delta(\\vec{x}-\\vec{x}_c)$","title":"Basic Scalar Coefficients"},{"location":"coefficient/#derived-scalar-coefficients","text":"These classes provide a means of creating functions of existing coefficients. In performance critical situations it would clearly be preferable to write specialized Coefficient classes but these offer a quick and, hopefully, easy to use alternative. Class Name Formula TransformedCoefficient $T(Q_1(\\vec{x},t))\\mbox{ or }T(Q_1(\\vec{x},t),Q_2(\\vec{x},t))$ RestrictedCoefficient $Q(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ SumCoefficient $\\alpha\\,Q_1(\\vec{x}) + \\beta\\,Q_2(\\vec{x})$ ProductCoefficient $Q_1(\\vec{x})\\,Q_2(\\vec{x})$ PowerCoefficient $Q(\\vec{x})^p$ InnerProductCoefficient $\\vec{Q}_1\\cdot\\vec{Q}_2$ VectorRotProductCoefficient $\\vec{Q}_1\\times\\vec{Q}_2\\mbox{ in }\\mathbb{R}^2$ DeterminantCoefficient $|\\overleftrightarrow{Q}|$","title":"Derived Scalar Coefficients"},{"location":"coefficient/#vector-coefficients","text":"","title":"Vector Coefficients"},{"location":"coefficient/#basic-vector-coefficients","text":"Class Name Description VectorConstantCoefficient Returns a constant vector value: $\\vec{\\alpha}$ VectorFunctionCoefficient Computes a value from a standard function, $\\vec{f}(\\vec{x})$, or a lambda expression VectorGridFunctionCoefficient Returns values interpolated from a vector-valued GridFunction : $\\vec{u}(\\vec{x})$ GradientGridFunctionCoefficient Returns the gradient of a scalar-valued GridFunction : $\\nabla u(\\vec{x})$ CurlGridFunctionCoefficient Returns the curl of a vector-valued GridFunction : $\\nabla\\times\\vec{u}(\\vec{x})$ VectorDeltaCoefficient $s\\,\\vec{\\alpha}\\,\\delta(\\vec{x}-\\vec{x}_c)$","title":"Basic Vector Coefficients"},{"location":"coefficient/#derived-vector-coefficients","text":"Again these classes provide a means of creating functions of existing coefficients. Class Name Formula VectorArrayCoefficient Construct a vector value from an array of scalar coefficients: $\\vec{Q}_a$ VectorRestrictedCoefficient $\\vec{Q}(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ VectorSumCoefficient $\\alpha\\,\\vec{Q}_1(\\vec{x}) + \\beta\\,\\vec{Q}_2(\\vec{x})$ ScalarVectorProductCoefficient $Q_1\\,\\vec{Q}_2$ VectorCrossProductCoefficient $\\vec{Q}_1\\times\\vec{Q}_2$ MatVecCoefficient $\\overleftrightarrow{Q}_1\\cdot\\vec{Q}_2$","title":"Derived Vector Coefficients"},{"location":"coefficient/#matrix-coefficients","text":"","title":"Matrix Coefficients"},{"location":"coefficient/#basic-matrix-coefficients","text":"Class Name Description MatrixConstantCoefficient Returns a constant matrix value: $\\overleftrightarrow{\\alpha}$ MatrixFunctionCoefficient Computes a value from a standard function, $\\overleftrightarrow{f}$, or a lambda expression IdentityMatrixCoefficient Returns the identity matrix of the appropriate dimension: $\\overleftrightarrow{I}$","title":"Basic Matrix Coefficients"},{"location":"coefficient/#derived-matrix-coefficients","text":"Again these classes provide a means of creating functions of existing coefficients. Class Name Formula MatrixArrayCoefficient Construct a matrix value from an array of scalar coefficients: $\\overleftrightarrow{Q}_a$ MatrixRestrictedCoefficient $\\overleftrightarrow{Q}(\\vec{x})\\,\\forall a\\in A, 0\\mbox{ otherwise}$ MatrixSumCoefficient $\\alpha\\,\\overleftrightarrow{Q}_1(\\vec{x}) + \\beta\\,\\overleftrightarrow{Q}_2(\\vec{x})$ ScalarMatrixProductCoefficient $Q_1\\,\\overleftrightarrow{Q}_2$ TransposeMatrixCoefficient $\\overleftrightarrow{Q}^T$ InverseMatrixCoefficient $\\overleftrightarrow{Q}^{-1}$ OuterProductCoefficient $\\vec{Q}_1\\otimes\\vec{Q}_2$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Derived Matrix Coefficients"},{"location":"download/","text":"Latest Release New features \u250a Example codes \u250a Code documentation \u250a Sources Download mfem-4.2.tgz Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size SLOC Notes mfem-4.2.tgz v4.2 Oct 2020 2.4M 258K mfem-4.1.tgz v4.1 Mar 2020 7.9M 209K mfem-4.0.tgz v4.0 May 2019 5.2M 167K GPU support mfem-3.4.tgz v3.4 May 2018 4.4M 134K mfem-3.3.2.tgz v3.3.2 Nov 2017 4.2M 123K mesh optimization mfem-3.3.tgz v3.3 Jan 2017 4.0M 112K mfem-3.2.tgz v3.2 Jun 2016 3.3M 92K dynamic AMR, HPC miniapps mfem-3.1.tgz v3.1 Feb 2016 2.9M 80K fem \u2194 linear system interface mfem-3.0.1.tgz v3.0.1 Jan 2015 1.1M 61K mfem-3.0.tgz v3.0 Jan 2015 1.1M 61K non-conforming AMR mfem-2.0.tgz v2.0 Nov 2011 308K 40K arbitrary order spaces, NURBS mfem-v1.2.2.tgz v1.2.2 Apr 2011 240K 28K mfem-v1.2.1.tgz v1.2.1 Apr 2011 240K 28K mfem-v1.2.tgz v1.2 Apr 2011 240K 28K MPI parallelism based on hypre mfem-v1.1.tgz v1.1 Sep 2010 166K 23K mfem-v1.0.tgz v1.0 Jul 2010 160K 22K initial release","title":"Download"},{"location":"download/#latest-release","text":"New features \u250a Example codes \u250a Code documentation \u250a Sources Download mfem-4.2.tgz Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download/#all-releases","text":"Filename Version Release Date Size SLOC Notes mfem-4.2.tgz v4.2 Oct 2020 2.4M 258K mfem-4.1.tgz v4.1 Mar 2020 7.9M 209K mfem-4.0.tgz v4.0 May 2019 5.2M 167K GPU support mfem-3.4.tgz v3.4 May 2018 4.4M 134K mfem-3.3.2.tgz v3.3.2 Nov 2017 4.2M 123K mesh optimization mfem-3.3.tgz v3.3 Jan 2017 4.0M 112K mfem-3.2.tgz v3.2 Jun 2016 3.3M 92K dynamic AMR, HPC miniapps mfem-3.1.tgz v3.1 Feb 2016 2.9M 80K fem \u2194 linear system interface mfem-3.0.1.tgz v3.0.1 Jan 2015 1.1M 61K mfem-3.0.tgz v3.0 Jan 2015 1.1M 61K non-conforming AMR mfem-2.0.tgz v2.0 Nov 2011 308K 40K arbitrary order spaces, NURBS mfem-v1.2.2.tgz v1.2.2 Apr 2011 240K 28K mfem-v1.2.1.tgz v1.2.1 Apr 2011 240K 28K mfem-v1.2.tgz v1.2 Apr 2011 240K 28K MPI parallelism based on hypre mfem-v1.1.tgz v1.1 Sep 2010 166K 23K mfem-v1.0.tgz v1.0 Jul 2010 160K 22K initial release","title":"All Releases"},{"location":"electromagnetics/","text":"Electromagnetics Mini Applications $\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}} \\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}} \\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}} \\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}} \\newcommand{\\F}{\\vec{F}} \\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla}$ The miniapps/electromagnetics directory contains a collection of electromagnetic miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current electromagnetic miniapps are described below. Electromagnetics The equations describing electromagnetic phenomena are known collectively as the Maxwell Equations. They are usually given as: $$\\begin{align} \\curl\\H - \\dd{\\D}{t} & = \\J \\label{ampere} \\\\ \\curl\\E + \\dd{\\B}{t} & = 0 \\label{faraday} \\\\ \\div\\D & = \\rho \\label{gauss} \\\\ \\div\\B & = 0 \\label{divb} \\end{align}$$ Where equation \\eqref{ampere} can be referred to as Amp\u00e8re's Law , equation \\eqref{faraday} is called Faraday's Law , equation \\eqref{gauss} is Gauss's Law , and equation \\eqref{divb} doesn't generally have a name but is related to the nonexistence of magnetic monopoles. The various fields in these equations are: Symbol Name SI Units $\\H$ magnetic field Ampere/meter $\\B$ magnetic flux density Tesla $\\E$ electric field Volt/meter $\\D$ electric displacement Coulomb/meter$^2$ $\\J$ current density Ampere/meter$^2$ $\\rho$ charge density Coulomb/meter$^3$ In the literature these names do vary, particularly those for $\\H$ and $\\B$, but in this document we will try to adhere to the convention laid out above. Generally we also need constitutive relations between $\\E$ and $\\D$ and/or between $\\H$ and $\\B$. These relations start with the definitions: $$\\begin{align} \\D & = \\epsilon_0\\E + \\P \\label{const_d} \\\\ \\B & = \\mu_0(\\H + \\M) \\label{const_b} \\end{align}$$ Where $\\P$ is the polarization density , and $\\M$ is the magnetization . Also, $\\epsilon_0$ is the permittivity of free space and $\\mu_0$ is the permeability of free space which are both constants of nature. In many common materials the polarization density can be approximated as a scalar multiple of the electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D = \\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity of the material. The nature of magnetization is more complicated but we will take a very simplified view which is valid in many situations. Specifically, we will assume that either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$ where $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the magnetic susceptibility or that $\\M$ is independent of the applied field. The former case pertains to both diamagnetic and paramagnetic materials and the latter to ferromagnetic materials. Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be combined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$ which can be important in plasma physics and magnetohydrodynamics (MHD). Electrostatics Electrostatic problems come in a variety of subtypes but they all derive from Gauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}). When we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$. This suggests that the electric field can be expressed as the gradient of a scalar field which is traditionally taken to be $-\\varphi$, i.e. $$\\E = -\\grad\\varphi \\label{gradphi}$$ where $\\varphi$ is called the electric potential and has units of Volts in the SI system. Inserting this definition into equation \\eqref{gauss} gives: $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P \\label{poisson}$$ which is Poisson's equation for the electric potential, where we have assumed a linear constitutive relation between $\\D$ and $\\E$ of the form $\\D = \\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as well as a polarization independent of $\\E$. If this relation happens to be nonlinear then Poisson's equation would need to be replaced with a more complicated nonlinear expression. The solutions to equation \\eqref{poisson} are non unique because they can be shifted by any additive constant. This means that we must apply a Dirichlet boundary condition at least at one point in the problem domain in order to obtain a solution. Typically this point will be on the boundary but it need not be so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a. potential) at one or more locations. Additionally, this equation admits a normal derivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a prescribed value on some portion of the boundary. This is equivalent to defining a surface charge density on that portion of the boundary. Volta Mini Application The electrostatics mini application, named volta after the inventor of the voltaic pile , is intended to demonstrate how to solve standard electrostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters. Mini Application Features Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Charge Density: The charge density, $\\rho$, is assumed to be zero except for an optional sphere of uniform charge density which can be defined by the user. The command line option for this is -cs which follows the same pattern as the dielectric sphere. Note that the last entry is the total charge of the sphere and not its charge density. Polarization: A polarization vector function, $\\P$, can be imposed as a source of the electric field. The command line option -vp creates a polarization due to a simple voltaic pile, i.e., a cylinder which is electrically polarized along its axis. The user should specify the two end points of the cylinder axis, its radius and the magnitude of the polarization vector. Dirichlet BC: Dirichlet boundary conditions can either specify piecewise constant voltages on a collection of surfaces or they can specify a gradient field which approximates a uniform applied electric field. In either case the user specifies the surfaces where the Dirichlet boundary condition should be applied using the -dbcs option followed by a list of boundary attributes. For example to select surfaces 2, 3, and 4 the user would use the following: -dbcs '2 3 4' . To apply a gradient field on these surfaces the user would also use the -dbcg option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with -uebc followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would supply: -uebc '1 2 3' . To specify piecewise constant potential values the user would list the desired values after -dbcv as follows: -dbcv '0.0 1.0 -1.0' . Neumann BC: Neumann boundary conditions set the normal component of the electric displacement on portions of the boundary. This normal component is equivalent to the surface charge density on the surface. This is rarely used because surface charge densities are rarely known unless they are known to be zero. However, if the surface charge density is zero then the Neumann BCs are not needed because this is the natural boundary condition. Only piecewise constant Neumann boundary conditions are supported. They can be set analogously to piecewise Dirichlet boundary conditions but using options -nbcs and -nbcv . Magnetostatics Magnetostatic problems arise when we assume no time variation in Amp\u00e8re's Law \\eqref{ampere} which leads to: $$\\curl\\H = \\J \\nonumber$$ We will again assume a somewhat more general constitutive relation between $\\H$ and $\\vec{B}$ than is normally seen: $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M \\nonumber$$ Where the magnetization is split into two portions; one which is proportional to $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and is given by $\\M$. This allows for paramagnetic and/or diamagnetic materials defined through $\\mu$ as well as ferromagnetic materials represented by $\\M$. This choice yields: $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M \\nonumber$$ Which, when combined with equation \\eqref{divb}, becomes: $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$ If $\\J$ happens to be zero we have another option because we can assume that $\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined with equation \\eqref{divb} this leads to: $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$ Currently only the vector potential equation is used so we will focus on that for the remainder of this document. The vector potential is again non unique so we must apply additional constraints in order to arrive at a solution for $\\A$. When working analytically it is common to constrain the solution by restricting the divergence of $\\A$ but numerically this leads to other complications. For our problems of interest it will be necessary to require Dirichlet boundary conditions on the entire outer surface in order to sufficiently constrain the solution. Dirichlet boundary conditions for the vector potential on a surface provide a means to specify the component of $\\B$ normal to that surface. For example, setting the tangential components of $\\A$ to be zero on a particular surface results in a magnetic flux density which must be tangent to that surface. Tesla Mini Application The magnetostatics mini application, named tesla after the unit of magnetic field strength (and of course the man Nikola Tesla), is intended to demonstrate how to solve standard magnetostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources of boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters. Mini Application Features Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional ring of constant current which can be defined by the user. The command line option for this is -cr which requires two points giving the end points of the ring's axis, inner and outer radii, and a constant total current. For example, to specify a ring centered at the origin and laying in the XY plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps the user would give: -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 . Magnetization: A permanent magnetization, $\\M$, can be applied in the form of a cylindrical magnet with poles at its circular ends. The command line option is -bm which indicates a 'bar magnet'. The option requires the two end points of the cylinder's axis, its radius, and the magnitude of the magnetization. Surface Current Density: A surface current can be imposed indirectly by specifying separate surface patches with different voltages as well as a collection of surface patches connecting the voltages through which the current will flow. The voltage surfaces and their voltages can be specified using -vbcs followed by the indices of the surfaces and -vbcv followed by their voltages. The path for the surface current ($\\vec{K}$) is specified by using -kbcs followed by a set of surface indices. For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current path along surfaces 4 and 6 would be specified as: -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' . Any surfaces not listed as voltage or current surfaces will be assigned as homogeneous Dirichlet boundaries. Note that when this option is selected an auxiliary electrostatic problem will be solved on the surface of the geometry to compute the surface current. Dirichlet BC: Dirichlet boundary conditions are required if a surface current density is not defined. For this reason the user need not specify boundary surfaces by number since the boundary condition must be applied on all of them. The default boundary condition is a homogeneous Dirichlet boundary condition on all outer surfaces. This means that the normal component of $\\B$ will be zero at the outer boundary. An alternative is to specify a desired uniform magnetic flux density on the entire outer surface. This is accomplished with the -ubbc command line option followed by the desired $\\B$ vector. Transient Full-Wave Electromagnetics Transient electromagnetics problems are governed by the time-dependent Maxwell equations \\eqref{ampere} and \\eqref{faraday} when combined using the constitutive relations \\eqref{const_d} and \\eqref{const_b}. When combined these equations can describe the evolution and propagation of electromagnetic waves. $$\\begin{align} \\dd{(\\epsilon\\E)}{t} & = \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J \\\\ \\dd{\\B}{t} & = - \\curl\\E \\end{align}$$ The term $\\sigma\\E$ arises in the presence of electrically conductive materials where the electric field induces a current which can be separated from $\\J$. In such cases the total current appearing in Amp\u00e8re's Law \\eqref{ampere} can be expressed as the sum of an applied current (also labeled as $\\J$) and an induced current $\\sigma\\E$. Solving these equations requires initial conditions for both the electric and magnetic fields $\\E$ and $\\B$ as well as boundary conditions related to the tangential components of $\\E$ or $\\H$. Other formulations are possible such as evolving $\\H$ and $\\D$ or the potentials $\\varphi$ and $\\A$. This system of equations can also be written as a single second order equation involving only $\\E$, $\\H$, $\\varphi$, or $\\A$. Each of these formulations has a different set of sources, initial and boundary conditions for which it is well-suited. The choice we make here is perhaps the most common but it may not be the most convenient choice for a given application. These equations can be used to evolve their initial conditions or they can be driven by either a current source or through time-varying boundary conditions. It is also possible to combine all three of these sources in a single simulation. Maxwell Mini Application The electrodynamics mini application, named maxwell after James Clerk Maxwell who first formulated the classical theory of electromagnetic radiation, is intended to demonstrate how to solve transient wave problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. An example simulation is depicted below (click to animate the wave propagation). Time integration is handled by a variable order symplectic time integration algorithm. This algorithm is designed for systems of equations which are derived from a Hamiltonian and it helps to ensure energy conservation within some tolerance. The time step used during integration is automatically chosen based on the largest stable time step as computed from the largest eigenvalue of the update equations. This determination involves a user-adjustable factor which creates a safety margin. By default the actual time step is less than 95% of the estimate for the largest stable time step. Note that this application assumes the mesh coordinates are given in meters. Internally the code assumes time is in seconds but the command line options use nanoseconds for convenience. Mini Application Features Time Evolution: The initial and final times for the simulation can be specified, in nanoseconds, with the -ti and -tf options. Visualization snapshots of data will be written out after time intervals specified by -ts which again given in nanoseconds. The order of the time integration can be specified, from 1 to 4, using the -to option. Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Conductivity: The conductivity, $\\sigma$, is assumed to be zero except for an optional sphere of conductive material which can be defined by the user. The command line option -cs can be used to set the parameters for this conductive sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify: -cs '0 0 0 0.5 3e6' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional cylinder of pulsed current which can be defined by the user. The command line option for this is -dp , short for 'dipole pulse', which requires two points giving the end points of the cylinder's axis, radius, amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$). The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds. Dirichlet BC: Homogeneous Dirichlet boundary conditions, which constrain the tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be activated on a portion of the boundary by specifying a list of boundary attributes such as -dbcs '4 8' . For convenience a boundary attribute of '-1' can be used to specify all boundary surfaces. Non-Homogeneous, time-dependent Dirichlet boundary conditions are supported by the Maxwell solver so a user can edit maxwell.cpp and supply their own function if desired. Absorbing BC: A first order Sommerfeld absorbing boundary condition can be applied to a portion of the boundary using the -abcs option along with a list of boundary attributes such as -abcs '4 18' . Again, the special purpose boundary attribute '-1' can be used to specify all boundary surfaces. This boundary condition depends on a coefficient, $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just inside the boundary. The code assumes that the permittivity and permeability are those of the vacuum near the surface but, if this is not the case, an ambitious user can replace etaInvCoef_ with a more appropriate function. Transient Magnetics and Joule Heating Joule Mini Application The transient magnetics mini application, named joule after the SI unit of energy (and the scientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve transient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled with the equations of heat transfer. The coupling is one way, electromagnetics generates Joule heating, but the heating does not affect the electromagnetics. The thermal problem is solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the thermal flux $\\F$ is in $H(\\mathrm{div})$. There are three linear solves per time step: Poisson's equation for the scalar electric potential is solved using the AMG preconditioner, the electric diffusion equation is solved using the AMS preconditioner, and the thermal diffusion equation is solved using the ADS preconditioner. Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical coil in vacuum (the latter is 21MB and can be downloaded from here ). The idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses into the metal, the metal is heated by Joule heating, the heat diffuses out. The equations are: $$\\begin{align} \\div\\sigma\\grad\\Phi &= 0 \\\\ \\sigma \\E &= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\ \\frac{d \\B}{d t} &= - \\curl \\E \\\\ \\F &= -k \\grad T \\\\ c \\frac{d T}{d t} &= - \\div \\F + \\sigma \\E \\cdot \\E \\end{align}$$ The equations are integrated in time using implicit time integration, either midpoint or higher order SDIRK. Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the scalar potential, the electric field, and the thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. Note that this application assumes the mesh coordinates are given in meters. The above picture shows Joule heating of a cylinder using the mesh cylinder-hex.mesh . The cylinder is surrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat flux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature. Mini Application Features Boundary Conditions: Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . Note that the essential BC's can be time varying. Material Properties: There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Electromagnetics"},{"location":"electromagnetics/#electromagnetics-mini-applications","text":"$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}} \\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}} \\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}} \\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}} \\newcommand{\\F}{\\vec{F}} \\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla}$ The miniapps/electromagnetics directory contains a collection of electromagnetic miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current electromagnetic miniapps are described below.","title":"Electromagnetics Mini Applications"},{"location":"electromagnetics/#electromagnetics","text":"The equations describing electromagnetic phenomena are known collectively as the Maxwell Equations. They are usually given as: $$\\begin{align} \\curl\\H - \\dd{\\D}{t} & = \\J \\label{ampere} \\\\ \\curl\\E + \\dd{\\B}{t} & = 0 \\label{faraday} \\\\ \\div\\D & = \\rho \\label{gauss} \\\\ \\div\\B & = 0 \\label{divb} \\end{align}$$ Where equation \\eqref{ampere} can be referred to as Amp\u00e8re's Law , equation \\eqref{faraday} is called Faraday's Law , equation \\eqref{gauss} is Gauss's Law , and equation \\eqref{divb} doesn't generally have a name but is related to the nonexistence of magnetic monopoles. The various fields in these equations are: Symbol Name SI Units $\\H$ magnetic field Ampere/meter $\\B$ magnetic flux density Tesla $\\E$ electric field Volt/meter $\\D$ electric displacement Coulomb/meter$^2$ $\\J$ current density Ampere/meter$^2$ $\\rho$ charge density Coulomb/meter$^3$ In the literature these names do vary, particularly those for $\\H$ and $\\B$, but in this document we will try to adhere to the convention laid out above. Generally we also need constitutive relations between $\\E$ and $\\D$ and/or between $\\H$ and $\\B$. These relations start with the definitions: $$\\begin{align} \\D & = \\epsilon_0\\E + \\P \\label{const_d} \\\\ \\B & = \\mu_0(\\H + \\M) \\label{const_b} \\end{align}$$ Where $\\P$ is the polarization density , and $\\M$ is the magnetization . Also, $\\epsilon_0$ is the permittivity of free space and $\\mu_0$ is the permeability of free space which are both constants of nature. In many common materials the polarization density can be approximated as a scalar multiple of the electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D = \\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity of the material. The nature of magnetization is more complicated but we will take a very simplified view which is valid in many situations. Specifically, we will assume that either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$ where $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the magnetic susceptibility or that $\\M$ is independent of the applied field. The former case pertains to both diamagnetic and paramagnetic materials and the latter to ferromagnetic materials. Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be combined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$ which can be important in plasma physics and magnetohydrodynamics (MHD).","title":"Electromagnetics"},{"location":"electromagnetics/#electrostatics","text":"Electrostatic problems come in a variety of subtypes but they all derive from Gauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}). When we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$. This suggests that the electric field can be expressed as the gradient of a scalar field which is traditionally taken to be $-\\varphi$, i.e. $$\\E = -\\grad\\varphi \\label{gradphi}$$ where $\\varphi$ is called the electric potential and has units of Volts in the SI system. Inserting this definition into equation \\eqref{gauss} gives: $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P \\label{poisson}$$ which is Poisson's equation for the electric potential, where we have assumed a linear constitutive relation between $\\D$ and $\\E$ of the form $\\D = \\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as well as a polarization independent of $\\E$. If this relation happens to be nonlinear then Poisson's equation would need to be replaced with a more complicated nonlinear expression. The solutions to equation \\eqref{poisson} are non unique because they can be shifted by any additive constant. This means that we must apply a Dirichlet boundary condition at least at one point in the problem domain in order to obtain a solution. Typically this point will be on the boundary but it need not be so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a. potential) at one or more locations. Additionally, this equation admits a normal derivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a prescribed value on some portion of the boundary. This is equivalent to defining a surface charge density on that portion of the boundary.","title":"Electrostatics"},{"location":"electromagnetics/#volta-mini-application","text":"The electrostatics mini application, named volta after the inventor of the voltaic pile , is intended to demonstrate how to solve standard electrostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters.","title":"Volta Mini Application"},{"location":"electromagnetics/#mini-application-features","text":"Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Charge Density: The charge density, $\\rho$, is assumed to be zero except for an optional sphere of uniform charge density which can be defined by the user. The command line option for this is -cs which follows the same pattern as the dielectric sphere. Note that the last entry is the total charge of the sphere and not its charge density. Polarization: A polarization vector function, $\\P$, can be imposed as a source of the electric field. The command line option -vp creates a polarization due to a simple voltaic pile, i.e., a cylinder which is electrically polarized along its axis. The user should specify the two end points of the cylinder axis, its radius and the magnitude of the polarization vector. Dirichlet BC: Dirichlet boundary conditions can either specify piecewise constant voltages on a collection of surfaces or they can specify a gradient field which approximates a uniform applied electric field. In either case the user specifies the surfaces where the Dirichlet boundary condition should be applied using the -dbcs option followed by a list of boundary attributes. For example to select surfaces 2, 3, and 4 the user would use the following: -dbcs '2 3 4' . To apply a gradient field on these surfaces the user would also use the -dbcg option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with -uebc followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would supply: -uebc '1 2 3' . To specify piecewise constant potential values the user would list the desired values after -dbcv as follows: -dbcv '0.0 1.0 -1.0' . Neumann BC: Neumann boundary conditions set the normal component of the electric displacement on portions of the boundary. This normal component is equivalent to the surface charge density on the surface. This is rarely used because surface charge densities are rarely known unless they are known to be zero. However, if the surface charge density is zero then the Neumann BCs are not needed because this is the natural boundary condition. Only piecewise constant Neumann boundary conditions are supported. They can be set analogously to piecewise Dirichlet boundary conditions but using options -nbcs and -nbcv .","title":"Mini Application Features"},{"location":"electromagnetics/#magnetostatics","text":"Magnetostatic problems arise when we assume no time variation in Amp\u00e8re's Law \\eqref{ampere} which leads to: $$\\curl\\H = \\J \\nonumber$$ We will again assume a somewhat more general constitutive relation between $\\H$ and $\\vec{B}$ than is normally seen: $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M \\nonumber$$ Where the magnetization is split into two portions; one which is proportional to $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and is given by $\\M$. This allows for paramagnetic and/or diamagnetic materials defined through $\\mu$ as well as ferromagnetic materials represented by $\\M$. This choice yields: $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M \\nonumber$$ Which, when combined with equation \\eqref{divb}, becomes: $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$ If $\\J$ happens to be zero we have another option because we can assume that $\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined with equation \\eqref{divb} this leads to: $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$ Currently only the vector potential equation is used so we will focus on that for the remainder of this document. The vector potential is again non unique so we must apply additional constraints in order to arrive at a solution for $\\A$. When working analytically it is common to constrain the solution by restricting the divergence of $\\A$ but numerically this leads to other complications. For our problems of interest it will be necessary to require Dirichlet boundary conditions on the entire outer surface in order to sufficiently constrain the solution. Dirichlet boundary conditions for the vector potential on a surface provide a means to specify the component of $\\B$ normal to that surface. For example, setting the tangential components of $\\A$ to be zero on a particular surface results in a magnetic flux density which must be tangent to that surface.","title":"Magnetostatics"},{"location":"electromagnetics/#tesla-mini-application","text":"The magnetostatics mini application, named tesla after the unit of magnetic field strength (and of course the man Nikola Tesla), is intended to demonstrate how to solve standard magnetostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources of boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters.","title":"Tesla Mini Application"},{"location":"electromagnetics/#mini-application-features_1","text":"Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional ring of constant current which can be defined by the user. The command line option for this is -cr which requires two points giving the end points of the ring's axis, inner and outer radii, and a constant total current. For example, to specify a ring centered at the origin and laying in the XY plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps the user would give: -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 . Magnetization: A permanent magnetization, $\\M$, can be applied in the form of a cylindrical magnet with poles at its circular ends. The command line option is -bm which indicates a 'bar magnet'. The option requires the two end points of the cylinder's axis, its radius, and the magnitude of the magnetization. Surface Current Density: A surface current can be imposed indirectly by specifying separate surface patches with different voltages as well as a collection of surface patches connecting the voltages through which the current will flow. The voltage surfaces and their voltages can be specified using -vbcs followed by the indices of the surfaces and -vbcv followed by their voltages. The path for the surface current ($\\vec{K}$) is specified by using -kbcs followed by a set of surface indices. For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current path along surfaces 4 and 6 would be specified as: -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' . Any surfaces not listed as voltage or current surfaces will be assigned as homogeneous Dirichlet boundaries. Note that when this option is selected an auxiliary electrostatic problem will be solved on the surface of the geometry to compute the surface current. Dirichlet BC: Dirichlet boundary conditions are required if a surface current density is not defined. For this reason the user need not specify boundary surfaces by number since the boundary condition must be applied on all of them. The default boundary condition is a homogeneous Dirichlet boundary condition on all outer surfaces. This means that the normal component of $\\B$ will be zero at the outer boundary. An alternative is to specify a desired uniform magnetic flux density on the entire outer surface. This is accomplished with the -ubbc command line option followed by the desired $\\B$ vector.","title":"Mini Application Features"},{"location":"electromagnetics/#transient-full-wave-electromagnetics","text":"Transient electromagnetics problems are governed by the time-dependent Maxwell equations \\eqref{ampere} and \\eqref{faraday} when combined using the constitutive relations \\eqref{const_d} and \\eqref{const_b}. When combined these equations can describe the evolution and propagation of electromagnetic waves. $$\\begin{align} \\dd{(\\epsilon\\E)}{t} & = \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J \\\\ \\dd{\\B}{t} & = - \\curl\\E \\end{align}$$ The term $\\sigma\\E$ arises in the presence of electrically conductive materials where the electric field induces a current which can be separated from $\\J$. In such cases the total current appearing in Amp\u00e8re's Law \\eqref{ampere} can be expressed as the sum of an applied current (also labeled as $\\J$) and an induced current $\\sigma\\E$. Solving these equations requires initial conditions for both the electric and magnetic fields $\\E$ and $\\B$ as well as boundary conditions related to the tangential components of $\\E$ or $\\H$. Other formulations are possible such as evolving $\\H$ and $\\D$ or the potentials $\\varphi$ and $\\A$. This system of equations can also be written as a single second order equation involving only $\\E$, $\\H$, $\\varphi$, or $\\A$. Each of these formulations has a different set of sources, initial and boundary conditions for which it is well-suited. The choice we make here is perhaps the most common but it may not be the most convenient choice for a given application. These equations can be used to evolve their initial conditions or they can be driven by either a current source or through time-varying boundary conditions. It is also possible to combine all three of these sources in a single simulation.","title":"Transient Full-Wave Electromagnetics"},{"location":"electromagnetics/#maxwell-mini-application","text":"The electrodynamics mini application, named maxwell after James Clerk Maxwell who first formulated the classical theory of electromagnetic radiation, is intended to demonstrate how to solve transient wave problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. An example simulation is depicted below (click to animate the wave propagation). Time integration is handled by a variable order symplectic time integration algorithm. This algorithm is designed for systems of equations which are derived from a Hamiltonian and it helps to ensure energy conservation within some tolerance. The time step used during integration is automatically chosen based on the largest stable time step as computed from the largest eigenvalue of the update equations. This determination involves a user-adjustable factor which creates a safety margin. By default the actual time step is less than 95% of the estimate for the largest stable time step. Note that this application assumes the mesh coordinates are given in meters. Internally the code assumes time is in seconds but the command line options use nanoseconds for convenience.","title":"Maxwell Mini Application"},{"location":"electromagnetics/#mini-application-features_2","text":"Time Evolution: The initial and final times for the simulation can be specified, in nanoseconds, with the -ti and -tf options. Visualization snapshots of data will be written out after time intervals specified by -ts which again given in nanoseconds. The order of the time integration can be specified, from 1 to 4, using the -to option. Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Conductivity: The conductivity, $\\sigma$, is assumed to be zero except for an optional sphere of conductive material which can be defined by the user. The command line option -cs can be used to set the parameters for this conductive sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify: -cs '0 0 0 0.5 3e6' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional cylinder of pulsed current which can be defined by the user. The command line option for this is -dp , short for 'dipole pulse', which requires two points giving the end points of the cylinder's axis, radius, amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$). The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds. Dirichlet BC: Homogeneous Dirichlet boundary conditions, which constrain the tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be activated on a portion of the boundary by specifying a list of boundary attributes such as -dbcs '4 8' . For convenience a boundary attribute of '-1' can be used to specify all boundary surfaces. Non-Homogeneous, time-dependent Dirichlet boundary conditions are supported by the Maxwell solver so a user can edit maxwell.cpp and supply their own function if desired. Absorbing BC: A first order Sommerfeld absorbing boundary condition can be applied to a portion of the boundary using the -abcs option along with a list of boundary attributes such as -abcs '4 18' . Again, the special purpose boundary attribute '-1' can be used to specify all boundary surfaces. This boundary condition depends on a coefficient, $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just inside the boundary. The code assumes that the permittivity and permeability are those of the vacuum near the surface but, if this is not the case, an ambitious user can replace etaInvCoef_ with a more appropriate function.","title":"Mini Application Features"},{"location":"electromagnetics/#transient-magnetics-and-joule-heating","text":"","title":"Transient Magnetics and Joule Heating"},{"location":"electromagnetics/#joule-mini-application","text":"The transient magnetics mini application, named joule after the SI unit of energy (and the scientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve transient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled with the equations of heat transfer. The coupling is one way, electromagnetics generates Joule heating, but the heating does not affect the electromagnetics. The thermal problem is solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the thermal flux $\\F$ is in $H(\\mathrm{div})$. There are three linear solves per time step: Poisson's equation for the scalar electric potential is solved using the AMG preconditioner, the electric diffusion equation is solved using the AMS preconditioner, and the thermal diffusion equation is solved using the ADS preconditioner. Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical coil in vacuum (the latter is 21MB and can be downloaded from here ). The idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses into the metal, the metal is heated by Joule heating, the heat diffuses out. The equations are: $$\\begin{align} \\div\\sigma\\grad\\Phi &= 0 \\\\ \\sigma \\E &= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\ \\frac{d \\B}{d t} &= - \\curl \\E \\\\ \\F &= -k \\grad T \\\\ c \\frac{d T}{d t} &= - \\div \\F + \\sigma \\E \\cdot \\E \\end{align}$$ The equations are integrated in time using implicit time integration, either midpoint or higher order SDIRK. Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the scalar potential, the electric field, and the thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. Note that this application assumes the mesh coordinates are given in meters. The above picture shows Joule heating of a cylinder using the mesh cylinder-hex.mesh . The cylinder is surrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat flux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.","title":"Joule Mini Application"},{"location":"electromagnetics/#mini-application-features_3","text":"Boundary Conditions: Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . Note that the essential BC's can be time varying. Material Properties: There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Mini Application Features"},{"location":"examples/","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Codes and Miniapps This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments . Application (PDE) All Diffusion Elasticity Electromagnetics grad-div Darcy Advection Conduction Wave Compressible flow Incompressible flow Meshing Finite Elements All H1 nodal elements L2 discontinuous elements H(curl) Nedelec elements H(div) Raviart-Thomas elements H^{-1/2} interfacial elements Discretization All Galerkin FEM Mixed FEM Discontinuous Galerkin (DG) Discont. Petrov-Galerkin (DPG) Hybridization Static condensation Isogeometric analysis (NURBS) Adaptive mesh refinement (AMR) Partial assembly Solver All Jacobi Gauss-Seidel PCG MINRES GMRES Algebraic Multigrid (BoomerAMG) Auxiliary-space Maxwell Solver (AMS) Auxiliary-space Divergence Solver (ADS) SuperLU/STRUMPACK (parallel direct) UMFPACK (serial direct) Newton method (nonlinear solver) Explicit Runge-Kutta (ODE integration) Implicit Runge-Kutta (ODE integration) Newmark (ODE Integration) Symplectic Algorithm (ODE Integration) LOBPCG, AME (eigensolvers) SUNDIALS solvers PETSc solvers SLEPc eigensolvers HiOp solvers Example 0: Simplest Laplace Problem This is the simplest MFEM example and a good starting point for new users. The example demonstrates the use of MFEM to define and solve an $H^1$ finite element discretization of the Laplace problem $$-\\Delta u = 1 \\quad\\text{in } \\Omega$$ with homogeneous Dirichlet boundary conditions $$ u = 0 \\quad\\text{on } \\partial\\Omega$$ The example illustrates the use of the basic MFEM classes for defining the mesh, finite element space, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. The example has serial ( ex0.cpp ) and parallel ( ex0p.cpp ) versions. Example 1: Laplace Problem This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The problem solved in this example is the same as ex0 , but with more sophisticated options and features. The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc , a PUMI modification in examples/pumi and a Ginkgo modification in examples/ginkgo . Partial assembly and GPU devices are supported. Example 2: Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example. Example 3: Definite Maxwell Problem This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-2 before viewing this example. Example 4: Grad-div Problem This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-3 before viewing this example. Example 5: Darcy Problem This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in VisIt and ParaView formats. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly is supported. We recommend viewing examples 1-4 before viewing this example. Example 6: Laplace Problem with AMR This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . Partial assembly and GPU devices are supported. We recommend viewing Example 1 before viewing this example. Example 7: Surface Meshes This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 8: DPG for the Laplace Problem This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example. Example 9: DG Advection This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit and implicit (with block ILU preconditioning) ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt and ParaView is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop . Example 10: Nonlinear Elasticity This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example. Example 11: Laplace Eigenproblem This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. It also has a SLEPc modification in examples/petsc . We recommend viewing Example 1 before viewing this example. Example 12: Linear Elasticity Eigenproblem This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example. Example 13: Maxwell Eigenproblem This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example. Example 14: DG Diffusion This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example. Example 15: Dynamic AMR Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example. Example 16: Time Dependent Heat Conduction This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example. Example 17: DG Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example. Example 18: DG Euler Equations This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example. Example 19: Incompressible Nonlinear Elasticity This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example. Example 20: Symplectic Integration of Hamiltonian Systems This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration. Example 21: Adaptive mesh refinement for linear elasticity This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example. Example 22: Complex Linear Systems This example code demonstrates the use of MFEM to define and solve a complex-valued linear system. It implements three variants of a damped harmonic oscillator: A scalar $H^1$ field: $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$ A vector $H(curl)$ field: $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ A vector $H(div)$ field: $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ In each case the field is driven by a forced oscillation, with angular frequency $\\omega$, imposed at the boundary or a portion of the boundary. The example also demonstrates how to display a time-varying solution as a sequence of fields sent to a single GLVis socket. The example has a serial ( ex22.cpp ) and a parallel ( ex22p.cpp ) version. We recommend viewing examples 1, 3, and 4 before viewing this example. Example 23: Wave Problem This example code solves a simple 2D/3D wave equation with a second order time derivative: $$\\frac{\\partial^2 u}{\\partial t^2} - c^2\\Delta u = 0$$ The boundary conditions are either Dirichlet or Neumann. The example demonstrates the use of time dependent operators, implicit solvers and second order time integration. The example has only a serial ( ex23.cpp ) version. We recommend viewing examples 9 and 10 before viewing this example. Example 24: Mixed finite element spaces This example code illustrates usage of mixed finite element spaces, with three variants: $H^1 \\times H(curl)$ $H(curl) \\times H(div)$ $H(div) \\times L_2$ Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or divergence in the appropriate spaces, comparing the errors in each case. Partial assembly and GPU devices are supported. The example has a serial ( ex24.cpp ) and a parallel ( ex24p.cpp ) version. We recommend viewing examples 1 and 3 before viewing this example. Example 25: Perfectly Matched Layers The example illustrates the use of a Perfectly Matched Layer (PML) for the simulation of time-harmonic electromagnetic waves propagating in unbounded domains. PML was originally introduced by Berenger in \"A Perfectly Matched Layer for the Absorption of Electromagnetic Waves\" . It is a technique used to solve wave propagation problems posed in infinite domains. The implementation involves the introduction of an artificial absorbing layer that minimizes undesired reflections. Inside this layer a complex coordinate stretching map is used which forces the wave modes to decay exponentially. The example solves the indefinite Maxwell equations $$\\nabla \\times (a \\nabla \\times E) - \\omega^2 b E = f.$$ where $a = \\mu^{-1} |J|^{-1} J^T J$, $b= \\epsilon |J| J^{-1} J^{-T}$ and $J$ is the Jacobian matrix of the coordinate transformation. The example demonstrates discretization with Nedelec finite elements in 2D or 3D, as well as the use of complex-valued bilinear and linear forms. Several test problems are included, with known exact solutions. The example has a serial ( ex25.cpp ) and a parallel ( ex25p.cpp ) version. We recommend viewing Example 22 before viewing this example. Example 26: Multigrid Preconditioner This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions and how to solve it efficiently using a matrix-free multigrid preconditioner. The example highlights on the creation of a hierarchy of discretization spaces and diffusion bilinear forms using partial assembly. The levels in the hierarchy of finite element spaces maybe constructed through geometric or order refinements. Moreover, the construction of a multigrid preconditioner for the PCG solver is shown. The multigrid uses a PCG solver on the coarsest level and second order Chebyshev accelerated smoothers on the other levels. The example has a serial ( ex26.cpp ) and a parallel ( ex26p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 27: Laplace Boundary Conditions This example code demonstrates the use of MFEM to define a simple finite element discretization of the Laplace problem: $$ -\\Delta u = 0 $$ with a variety of boundary conditions. Specifically, we discretize using a FE space of the specified order using a continuous or discontinuous space. We then apply Dirichlet, Neumann (both homogeneous and inhomogeneous), Robin, and Periodic boundary conditions on different portions of a predefined mesh. Boundary conditions: $u = u_{dbc}$ on $\\Gamma_{dbc}$ $\\hat{n}\\cdot\\nabla u = g_{nbc}$ on $\\Gamma_{nbc}$ $\\hat{n}\\cdot\\nabla u = 0$ on $\\Gamma_{nbc_0}$ $\\hat{n}\\cdot\\nabla u + a u = b$ on $\\Gamma_{rbc}$ as well as periodic boundary conditions which are enforced topologically. The example has a serial ( ex27.cpp ) and a parallel ( ex27p.cpp ) version. We recommend viewing examples 1 and 14 before viewing this example. Example 28: Constraints and Sliding Boundary Conditions This example code illustrates the use of constraints in linear solvers by solving an elasticity problem where the normal component of the displacement is constrained to zero on two boundaries but tangential displacement is allowed. The constraints can be enforced in several different ways, including eliminating them from the linear system or solving a saddle-point system that explicitly includes constraint conditions. The example has a serial ( ex28.cpp ) and a parallel ( ex28p.cpp ) version. We recommend viewing example 2 before viewing this example. Volta Miniapp: Electrostatics This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Tesla Miniapp: Magnetostatics This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Maxwell Miniapp: Transient Full-Wave Electromagnetics This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Joule Miniapp: Transient Magnetics and Joule Heating This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mobius Strip Miniapp This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Klein Bottle Miniapp This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Toroid Miniapp This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Twist Miniapp This miniapp generates simple periodic meshes to demonstrate MFEM's handling of periodic domains. MFEM's strategy is to use a discontinuous vector field to define the mesh coordinates on a topologically periodic mesh. It works by defining a stack of individual elements and stitching together the top and bottom of the mesh. The stack can also be twisted so that the vertices of the bottom and top can be joined with any integer offset (for tetrahedral and wedge meshes only even offsets are supported). The Twist miniapp supports various options including: The element type: 4 - Tetrahedron, 6 - Wedge, 8 - Hexahedron The geometric order of the elements The dimensions of the initial brick-shaped stack of elements The number of elements in the z direction The number of nodes to offset by before rejoining the stack The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( twist.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Extruder Miniapp This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Polar-NC Miniapp This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra. The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM. The implementation also demonstrates how to initialize a non-conforming mesh on the fly by marking hanging nodes with Mesh::AddVertexParents . For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( polar-nc.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Shaper Miniapp This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Explorer Miniapp This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Optimizer Miniapp This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Minimal Surface Miniapp This miniapp solves Plateau's problem: the Dirichlet problem for the minimal surface equation. Options to solve the minimal surface equations of both parametric surfaces as well as surfaces restricted to be graphs of the form $z=f(x,y)$ are supported, including a number of examples such as the Catenoid, Helicoid, Costa and Schrek surfaces. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( minimal-surface.cpp ) and a parallel ( pminimal-surface.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Low-Order Refined Transfer Miniapp The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Interpolation Miniapps The interpolation miniapp, found under miniapps/gslib , demonstrate the capability to interpolate high-order finite element functions at given set of points in physical space. These miniapps utilize the gslib library's high-order interpolation utility for quad and hex meshes: Find Points miniapp has a serial ( findpts.cpp ) and a parallel ( pfindpts.cpp ) version that demonstrate the basic procedures for point search and evaluation of grid functions. Field Interp miniapp ( field-interp.cpp ) demonstrates how grid functions can be transferred between meshes. Field Diff miniapp ( field-diff.cpp ) demonstrates how grid functions on two different meshes can be compared with each other. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps. Distance Solver Miniapp The distance miniapp, found in the miniapps/shifted directory demonstrates the capability to compute the \"distance\" to a given point source or to the zero level set of a given function. Here \"distance\" refers to the length of the shortest path through the mesh. The input can be a DeltaCoefficient (representing a point source), or any Coefficient (for the case of a level set). The output is a ParGridFunction that can be scalar (representing the scalar distance), or a vector (its magnitude is the distance, and its direction is the starting direction of the shortest path). The miniapp has only a parallel ( distance.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Laghos Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos . Remhos Miniapp Remhos (REMap High-Order Solver) is a miniapp that solves the pure advection equations that are used to perform monotonic and conservative discontinuous field interpolation (remap) as part of the Eulerian phase in Arbitrary Lagrangian Eulerian (ALE) simulations. The computational motives captured in Remhos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements. Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Remhos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Mass operator that is local per each zone. It is inverted by iterative or exact methods at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Advection operator that couples neighboring zones. It is applied once at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization and data analysis with VisIt . The Remhos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Remhos . Navier Miniapp Navier is a miniapp that solves the time-dependent Navier-Stokes equations of incompressible fluid dynamics \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u - \\nabla p &= f \\\\ \\nabla \\cdot u &= 0 \\end{align} using a spatially high-order finite element discretization. The time-dependent problem is solved using a (up to) third order implicit-explicit method which leverages an extrapolation scheme for the convective parts and a backward-difference formulation for the viscous parts of the equation. The miniapp supports: Arbitrary order H1 elements High order mesh elements IMEX (EXTk-BDFk) time-stepping up to third order Convenient interface for new users A variety of test cases and benchmarks This miniapp has only a parallel ( navier_solver.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Block Solvers Miniapp The Block Solvers miniapp, found under miniapps/solvers , compares various linear solvers for the saddle point system obtained from mixed finite element discretization of the Darcy's flow problem \\begin{array}{rcl} k{\\bf u} & + \\nabla p & = f \\\\ -\\nabla \\cdot {\\bf u} & & = g \\end{array} The solvers being compared include: The divergence-free solver (couple and decoupled modes), which is based on a multilevel decomposition of the Raviart-Thomas finite element space and its divergence-free subspace. MINRES preconditioned by the block diagonal preconditioner in ex5p.cpp . For more details, please see the documentation in the miniapps/solvers directory. The miniapp supports: Arbitrary order mixed finite element pair (Raviart-Thomas elements + piecewise discontinuous polynomials) Various combination of essential and natural boundary conditions Homogeneous or heterogeneous scalar coefficient k This miniapp has only a parallel ( block-solvers.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Overlapping Grids Miniapps Overlapping grids-based frameworks can often make problems tractable that are otherwise inaccessible with a single conforming grid. The following gslib -based miniapps in MFEM demonstrate how to set up and use overlapping grids: The Schwarz Example 1 miniapp in miniapps/gslib has a serial ( schwarz_ex1.cpp ) a parallel ( schwarz_ex1p.cpp ) version that solves the Poisson problem on overlapping grids. The serial version is restricted to use two overlapping grids, while the parallel version supports arbitrary number of overlapping grids. The Navier Conjugate Heat Transfer miniapp in miniapps/navier ( navier_cht.cpp ) demonstrates how a conjugate heat transfer problem can be solved with the fluid dynamics (incompressible Navier-Stokes equations) and heat transfer (advection-diffusion equation) PDEs modeled on different meshes. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps. No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"ex0\", (diffusion) && h1 && (galerkin) && (gs || pcg || amg)) + showElement(\"ex1\", (diffusion) && h1 && (galerkin || nurbs || staticcond || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex3\", (maxwell) && hcurl && (galerkin || staticcond || pa) && (gs || pcg || umfpack || ams || petsc)) + showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond || pa) && (gs || pcg || umfpack || amg || ads || ams || petsc)) + showElement(\"ex5\", darcy && (l2 || hdiv) && (mixed || pa) && (gs || jacobi || minres || umfpack || amg || petsc)) + showElement(\"ex6\", (diffusion) && h1 && (galerkin || nurbs || amr || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex7\", (diffusion || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex8\", diffusion && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)) + showElement(\"ex9\", (advection) && l2 && (dg || pa) && (pcg || rk || sundials || petsc || hiop || gmres || sdirk)) + showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)) + showElement(\"ex11\", diffusion && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu || slepc)) + showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)) + showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)) + showElement(\"ex14\", diffusion && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex15\", diffusion && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)) + showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex18\", compressibleflow && l2 && dg && (rk)) + showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)) + showElement(\"ex20\", (elasticity || maxwell || conduction || compressibleflow) && h1 && mixed && symplectic) + showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex22\", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads)) + showElement(\"ex23\", (diffusion || wave) && h1 && (galerkin || nurbs) && newmark) + showElement(\"ex24\", (graddiv) && (h1 || hcurl) && (galerkin || pa) && pcg) + showElement(\"ex25\", (maxwell || wave) && hcurl && galerkin && (gmres || ams)) + showElement(\"ex26\", diffusion && h1 && (galerkin || pa) && (jacobi || pcg || amg)) + showElement(\"ex27\", (elasticity || maxwell || conduction || compressibleflow) && (h1 || l2) && (galerkin || dg) && (gs || pcg || gmres || amg || umfpack)) + showElement(\"ex28\", elasticity && h1 && galerkin && pcg) // electromagnetic miniapps + showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)) + showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)) + showElement(\"maxwell\", (maxwell || conduction || wave) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)) + showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)) // meshing miniapps + showElement(\"mobius-strip\", meshing && all2 && all3 && all4) + showElement(\"klein-bottle\", meshing && all2 && all3 && all4) + showElement(\"toroid\", meshing && all2 && all3 && all4) + showElement(\"twist\", meshing && all2 && all3 && all4) + showElement(\"extruder\", meshing && all2 && all3 && all4) + showElement(\"polar-nc\", meshing && all2 && all3 && all4) + showElement(\"shaper\", meshing && all2 && all3 && all4) + showElement(\"mesh-explorer\", meshing && all2 && all3 && all4) + showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4) + showElement(\"minimal-surface\", meshing && all2 && (galerkin || amr || pa) && all4) + showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4) + showElement(\"gslib-interpolation\", meshing && all2 && all3 && all4) // shifted methods miniapps + showElement(\"distance\", all1 && h1 && galerkin && (pcg || gmres || amg || newton)) // external miniapps + showElement(\"laghos\", (compressibleflow) && (l2 || h1) && (galerkin || dg || pa) && (rk)) + showElement(\"remhos\", (advection) && (l2) && (galerkin || dg || pa) && (rk)) + showElement(\"navier\", (incompressibleflow) && (h1) && (galerkin || pa) && (gmres || pcg || amg)) + showElement(\"block-solvers\", darcy && (l2 || hdiv || hcurl) && mixed && (gmres || pcg || minres || amg)) + showElement(\"overlapping\", (incompressibleflow || diffusion || meshing) && (h1) && (galerkin) && (gmres || pcg)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown === 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Examples"},{"location":"examples/#example-codes-and-miniapps","text":"This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments .","title":"Example Codes and Miniapps"},{"location":"examples/#example-0-simplest-laplace-problem","text":"This is the simplest MFEM example and a good starting point for new users. The example demonstrates the use of MFEM to define and solve an $H^1$ finite element discretization of the Laplace problem $$-\\Delta u = 1 \\quad\\text{in } \\Omega$$ with homogeneous Dirichlet boundary conditions $$ u = 0 \\quad\\text{on } \\partial\\Omega$$ The example illustrates the use of the basic MFEM classes for defining the mesh, finite element space, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. The example has serial ( ex0.cpp ) and parallel ( ex0p.cpp ) versions.","title":"Example 0: Simplest Laplace Problem"},{"location":"examples/#example-1-laplace-problem","text":"This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The problem solved in this example is the same as ex0 , but with more sophisticated options and features. The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc , a PUMI modification in examples/pumi and a Ginkgo modification in examples/ginkgo . Partial assembly and GPU devices are supported.","title":"Example 1: Laplace Problem"},{"location":"examples/#example-2-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example.","title":"Example 2: Linear Elasticity"},{"location":"examples/#example-3-definite-maxwell-problem","text":"This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-2 before viewing this example.","title":"Example 3: Definite Maxwell Problem"},{"location":"examples/#example-4-grad-div-problem","text":"This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-3 before viewing this example.","title":"Example 4: Grad-div Problem"},{"location":"examples/#example-5-darcy-problem","text":"This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in VisIt and ParaView formats. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly is supported. We recommend viewing examples 1-4 before viewing this example.","title":"Example 5: Darcy Problem"},{"location":"examples/#example-6-laplace-problem-with-amr","text":"This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . Partial assembly and GPU devices are supported. We recommend viewing Example 1 before viewing this example.","title":"Example 6: Laplace Problem with AMR"},{"location":"examples/#example-7-surface-meshes","text":"This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 7: Surface Meshes"},{"location":"examples/#example-8-dpg-for-the-laplace-problem","text":"This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example.","title":"Example 8: DPG for the Laplace Problem"},{"location":"examples/#example-9-dg-advection","text":"This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit and implicit (with block ILU preconditioning) ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt and ParaView is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop .","title":"Example 9: DG Advection"},{"location":"examples/#example-10-nonlinear-elasticity","text":"This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example.","title":"Example 10: Nonlinear Elasticity"},{"location":"examples/#example-11-laplace-eigenproblem","text":"This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. It also has a SLEPc modification in examples/petsc . We recommend viewing Example 1 before viewing this example.","title":"Example 11: Laplace Eigenproblem"},{"location":"examples/#example-12-linear-elasticity-eigenproblem","text":"This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example.","title":"Example 12: Linear Elasticity Eigenproblem"},{"location":"examples/#example-13-maxwell-eigenproblem","text":"This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example.","title":"Example 13: Maxwell Eigenproblem"},{"location":"examples/#example-14-dg-diffusion","text":"This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example.","title":"Example 14: DG Diffusion"},{"location":"examples/#example-15-dynamic-amr","text":"Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example.","title":"Example 15: Dynamic AMR"},{"location":"examples/#example-16-time-dependent-heat-conduction","text":"This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example.","title":"Example 16: Time Dependent Heat Conduction"},{"location":"examples/#example-17-dg-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example.","title":"Example 17: DG Linear Elasticity"},{"location":"examples/#example-18-dg-euler-equations","text":"This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example.","title":"Example 18: DG Euler Equations"},{"location":"examples/#example-19-incompressible-nonlinear-elasticity","text":"This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example.","title":"Example 19: Incompressible Nonlinear Elasticity"},{"location":"examples/#example-20-symplectic-integration-of-hamiltonian-systems","text":"This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration.","title":"Example 20: Symplectic Integration of Hamiltonian Systems"},{"location":"examples/#example-21-adaptive-mesh-refinement-for-linear-elasticity","text":"This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example.","title":"Example 21: Adaptive mesh refinement for linear elasticity"},{"location":"examples/#example-22-complex-linear-systems","text":"This example code demonstrates the use of MFEM to define and solve a complex-valued linear system. It implements three variants of a damped harmonic oscillator: A scalar $H^1$ field: $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$ A vector $H(curl)$ field: $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ A vector $H(div)$ field: $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ In each case the field is driven by a forced oscillation, with angular frequency $\\omega$, imposed at the boundary or a portion of the boundary. The example also demonstrates how to display a time-varying solution as a sequence of fields sent to a single GLVis socket. The example has a serial ( ex22.cpp ) and a parallel ( ex22p.cpp ) version. We recommend viewing examples 1, 3, and 4 before viewing this example.","title":"Example 22: Complex Linear Systems"},{"location":"examples/#example-23-wave-problem","text":"This example code solves a simple 2D/3D wave equation with a second order time derivative: $$\\frac{\\partial^2 u}{\\partial t^2} - c^2\\Delta u = 0$$ The boundary conditions are either Dirichlet or Neumann. The example demonstrates the use of time dependent operators, implicit solvers and second order time integration. The example has only a serial ( ex23.cpp ) version. We recommend viewing examples 9 and 10 before viewing this example.","title":"Example 23: Wave Problem"},{"location":"examples/#example-24-mixed-finite-element-spaces","text":"This example code illustrates usage of mixed finite element spaces, with three variants: $H^1 \\times H(curl)$ $H(curl) \\times H(div)$ $H(div) \\times L_2$ Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or divergence in the appropriate spaces, comparing the errors in each case. Partial assembly and GPU devices are supported. The example has a serial ( ex24.cpp ) and a parallel ( ex24p.cpp ) version. We recommend viewing examples 1 and 3 before viewing this example.","title":"Example 24: Mixed finite element spaces"},{"location":"examples/#example-25-perfectly-matched-layers","text":"The example illustrates the use of a Perfectly Matched Layer (PML) for the simulation of time-harmonic electromagnetic waves propagating in unbounded domains. PML was originally introduced by Berenger in \"A Perfectly Matched Layer for the Absorption of Electromagnetic Waves\" . It is a technique used to solve wave propagation problems posed in infinite domains. The implementation involves the introduction of an artificial absorbing layer that minimizes undesired reflections. Inside this layer a complex coordinate stretching map is used which forces the wave modes to decay exponentially. The example solves the indefinite Maxwell equations $$\\nabla \\times (a \\nabla \\times E) - \\omega^2 b E = f.$$ where $a = \\mu^{-1} |J|^{-1} J^T J$, $b= \\epsilon |J| J^{-1} J^{-T}$ and $J$ is the Jacobian matrix of the coordinate transformation. The example demonstrates discretization with Nedelec finite elements in 2D or 3D, as well as the use of complex-valued bilinear and linear forms. Several test problems are included, with known exact solutions. The example has a serial ( ex25.cpp ) and a parallel ( ex25p.cpp ) version. We recommend viewing Example 22 before viewing this example.","title":"Example 25: Perfectly Matched Layers"},{"location":"examples/#example-26-multigrid-preconditioner","text":"This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions and how to solve it efficiently using a matrix-free multigrid preconditioner. The example highlights on the creation of a hierarchy of discretization spaces and diffusion bilinear forms using partial assembly. The levels in the hierarchy of finite element spaces maybe constructed through geometric or order refinements. Moreover, the construction of a multigrid preconditioner for the PCG solver is shown. The multigrid uses a PCG solver on the coarsest level and second order Chebyshev accelerated smoothers on the other levels. The example has a serial ( ex26.cpp ) and a parallel ( ex26p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 26: Multigrid Preconditioner"},{"location":"examples/#example-27-laplace-boundary-conditions","text":"This example code demonstrates the use of MFEM to define a simple finite element discretization of the Laplace problem: $$ -\\Delta u = 0 $$ with a variety of boundary conditions. Specifically, we discretize using a FE space of the specified order using a continuous or discontinuous space. We then apply Dirichlet, Neumann (both homogeneous and inhomogeneous), Robin, and Periodic boundary conditions on different portions of a predefined mesh. Boundary conditions: $u = u_{dbc}$ on $\\Gamma_{dbc}$ $\\hat{n}\\cdot\\nabla u = g_{nbc}$ on $\\Gamma_{nbc}$ $\\hat{n}\\cdot\\nabla u = 0$ on $\\Gamma_{nbc_0}$ $\\hat{n}\\cdot\\nabla u + a u = b$ on $\\Gamma_{rbc}$ as well as periodic boundary conditions which are enforced topologically. The example has a serial ( ex27.cpp ) and a parallel ( ex27p.cpp ) version. We recommend viewing examples 1 and 14 before viewing this example.","title":"Example 27: Laplace Boundary Conditions"},{"location":"examples/#example-28-constraints-and-sliding-boundary-conditions","text":"This example code illustrates the use of constraints in linear solvers by solving an elasticity problem where the normal component of the displacement is constrained to zero on two boundaries but tangential displacement is allowed. The constraints can be enforced in several different ways, including eliminating them from the linear system or solving a saddle-point system that explicitly includes constraint conditions. The example has a serial ( ex28.cpp ) and a parallel ( ex28p.cpp ) version. We recommend viewing example 2 before viewing this example.","title":"Example 28: Constraints and Sliding Boundary Conditions"},{"location":"examples/#volta-miniapp-electrostatics","text":"This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Volta Miniapp: Electrostatics"},{"location":"examples/#tesla-miniapp-magnetostatics","text":"This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Tesla Miniapp: Magnetostatics"},{"location":"examples/#maxwell-miniapp-transient-full-wave-electromagnetics","text":"This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Maxwell Miniapp: Transient Full-Wave Electromagnetics"},{"location":"examples/#joule-miniapp-transient-magnetics-and-joule-heating","text":"This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Joule Miniapp: Transient Magnetics and Joule Heating"},{"location":"examples/#mobius-strip-miniapp","text":"This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mobius Strip Miniapp"},{"location":"examples/#klein-bottle-miniapp","text":"This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Klein Bottle Miniapp"},{"location":"examples/#toroid-miniapp","text":"This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Toroid Miniapp"},{"location":"examples/#twist-miniapp","text":"This miniapp generates simple periodic meshes to demonstrate MFEM's handling of periodic domains. MFEM's strategy is to use a discontinuous vector field to define the mesh coordinates on a topologically periodic mesh. It works by defining a stack of individual elements and stitching together the top and bottom of the mesh. The stack can also be twisted so that the vertices of the bottom and top can be joined with any integer offset (for tetrahedral and wedge meshes only even offsets are supported). The Twist miniapp supports various options including: The element type: 4 - Tetrahedron, 6 - Wedge, 8 - Hexahedron The geometric order of the elements The dimensions of the initial brick-shaped stack of elements The number of elements in the z direction The number of nodes to offset by before rejoining the stack The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( twist.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Twist Miniapp"},{"location":"examples/#extruder-miniapp","text":"This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Extruder Miniapp"},{"location":"examples/#polar-nc-miniapp","text":"This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra. The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM. The implementation also demonstrates how to initialize a non-conforming mesh on the fly by marking hanging nodes with Mesh::AddVertexParents . For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( polar-nc.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Polar-NC Miniapp"},{"location":"examples/#shaper-miniapp","text":"This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Shaper Miniapp"},{"location":"examples/#mesh-explorer-miniapp","text":"This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Explorer Miniapp"},{"location":"examples/#mesh-optimizer-miniapp","text":"This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Optimizer Miniapp"},{"location":"examples/#minimal-surface-miniapp","text":"This miniapp solves Plateau's problem: the Dirichlet problem for the minimal surface equation. Options to solve the minimal surface equations of both parametric surfaces as well as surfaces restricted to be graphs of the form $z=f(x,y)$ are supported, including a number of examples such as the Catenoid, Helicoid, Costa and Schrek surfaces. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( minimal-surface.cpp ) and a parallel ( pminimal-surface.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Minimal Surface Miniapp"},{"location":"examples/#low-order-refined-transfer-miniapp","text":"The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Low-Order Refined Transfer Miniapp"},{"location":"examples/#interpolation-miniapps","text":"The interpolation miniapp, found under miniapps/gslib , demonstrate the capability to interpolate high-order finite element functions at given set of points in physical space. These miniapps utilize the gslib library's high-order interpolation utility for quad and hex meshes: Find Points miniapp has a serial ( findpts.cpp ) and a parallel ( pfindpts.cpp ) version that demonstrate the basic procedures for point search and evaluation of grid functions. Field Interp miniapp ( field-interp.cpp ) demonstrates how grid functions can be transferred between meshes. Field Diff miniapp ( field-diff.cpp ) demonstrates how grid functions on two different meshes can be compared with each other. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps.","title":"Interpolation Miniapps"},{"location":"examples/#distance-solver-miniapp","text":"The distance miniapp, found in the miniapps/shifted directory demonstrates the capability to compute the \"distance\" to a given point source or to the zero level set of a given function. Here \"distance\" refers to the length of the shortest path through the mesh. The input can be a DeltaCoefficient (representing a point source), or any Coefficient (for the case of a level set). The output is a ParGridFunction that can be scalar (representing the scalar distance), or a vector (its magnitude is the distance, and its direction is the starting direction of the shortest path). The miniapp has only a parallel ( distance.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Distance Solver Miniapp"},{"location":"examples/#laghos-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos .","title":"Laghos Miniapp"},{"location":"examples/#remhos-miniapp","text":"Remhos (REMap High-Order Solver) is a miniapp that solves the pure advection equations that are used to perform monotonic and conservative discontinuous field interpolation (remap) as part of the Eulerian phase in Arbitrary Lagrangian Eulerian (ALE) simulations. The computational motives captured in Remhos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements. Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Remhos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Mass operator that is local per each zone. It is inverted by iterative or exact methods at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Advection operator that couples neighboring zones. It is applied once at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization and data analysis with VisIt . The Remhos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Remhos .","title":"Remhos Miniapp"},{"location":"examples/#navier-miniapp","text":"Navier is a miniapp that solves the time-dependent Navier-Stokes equations of incompressible fluid dynamics \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u - \\nabla p &= f \\\\ \\nabla \\cdot u &= 0 \\end{align} using a spatially high-order finite element discretization. The time-dependent problem is solved using a (up to) third order implicit-explicit method which leverages an extrapolation scheme for the convective parts and a backward-difference formulation for the viscous parts of the equation. The miniapp supports: Arbitrary order H1 elements High order mesh elements IMEX (EXTk-BDFk) time-stepping up to third order Convenient interface for new users A variety of test cases and benchmarks This miniapp has only a parallel ( navier_solver.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Navier Miniapp"},{"location":"examples/#block-solvers-miniapp","text":"The Block Solvers miniapp, found under miniapps/solvers , compares various linear solvers for the saddle point system obtained from mixed finite element discretization of the Darcy's flow problem \\begin{array}{rcl} k{\\bf u} & + \\nabla p & = f \\\\ -\\nabla \\cdot {\\bf u} & & = g \\end{array} The solvers being compared include: The divergence-free solver (couple and decoupled modes), which is based on a multilevel decomposition of the Raviart-Thomas finite element space and its divergence-free subspace. MINRES preconditioned by the block diagonal preconditioner in ex5p.cpp . For more details, please see the documentation in the miniapps/solvers directory. The miniapp supports: Arbitrary order mixed finite element pair (Raviart-Thomas elements + piecewise discontinuous polynomials) Various combination of essential and natural boundary conditions Homogeneous or heterogeneous scalar coefficient k This miniapp has only a parallel ( block-solvers.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Block Solvers Miniapp"},{"location":"examples/#overlapping-grids-miniapps","text":"Overlapping grids-based frameworks can often make problems tractable that are otherwise inaccessible with a single conforming grid. The following gslib -based miniapps in MFEM demonstrate how to set up and use overlapping grids: The Schwarz Example 1 miniapp in miniapps/gslib has a serial ( schwarz_ex1.cpp ) a parallel ( schwarz_ex1p.cpp ) version that solves the Poisson problem on overlapping grids. The serial version is restricted to use two overlapping grids, while the parallel version supports arbitrary number of overlapping grids. The Navier Conjugate Heat Transfer miniapp in miniapps/navier ( navier_cht.cpp ) demonstrates how a conjugate heat transfer problem can be solved with the fluid dynamics (incompressible Navier-Stokes equations) and heat transfer (advection-diffusion equation) PDEs modeled on different meshes. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps. No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"ex0\", (diffusion) && h1 && (galerkin) && (gs || pcg || amg)) + showElement(\"ex1\", (diffusion) && h1 && (galerkin || nurbs || staticcond || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex3\", (maxwell) && hcurl && (galerkin || staticcond || pa) && (gs || pcg || umfpack || ams || petsc)) + showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond || pa) && (gs || pcg || umfpack || amg || ads || ams || petsc)) + showElement(\"ex5\", darcy && (l2 || hdiv) && (mixed || pa) && (gs || jacobi || minres || umfpack || amg || petsc)) + showElement(\"ex6\", (diffusion) && h1 && (galerkin || nurbs || amr || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex7\", (diffusion || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex8\", diffusion && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)) + showElement(\"ex9\", (advection) && l2 && (dg || pa) && (pcg || rk || sundials || petsc || hiop || gmres || sdirk)) + showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)) + showElement(\"ex11\", diffusion && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu || slepc)) + showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)) + showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)) + showElement(\"ex14\", diffusion && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex15\", diffusion && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)) + showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex18\", compressibleflow && l2 && dg && (rk)) + showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)) + showElement(\"ex20\", (elasticity || maxwell || conduction || compressibleflow) && h1 && mixed && symplectic) + showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex22\", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads)) + showElement(\"ex23\", (diffusion || wave) && h1 && (galerkin || nurbs) && newmark) + showElement(\"ex24\", (graddiv) && (h1 || hcurl) && (galerkin || pa) && pcg) + showElement(\"ex25\", (maxwell || wave) && hcurl && galerkin && (gmres || ams)) + showElement(\"ex26\", diffusion && h1 && (galerkin || pa) && (jacobi || pcg || amg)) + showElement(\"ex27\", (elasticity || maxwell || conduction || compressibleflow) && (h1 || l2) && (galerkin || dg) && (gs || pcg || gmres || amg || umfpack)) + showElement(\"ex28\", elasticity && h1 && galerkin && pcg) // electromagnetic miniapps + showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)) + showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)) + showElement(\"maxwell\", (maxwell || conduction || wave) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)) + showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)) // meshing miniapps + showElement(\"mobius-strip\", meshing && all2 && all3 && all4) + showElement(\"klein-bottle\", meshing && all2 && all3 && all4) + showElement(\"toroid\", meshing && all2 && all3 && all4) + showElement(\"twist\", meshing && all2 && all3 && all4) + showElement(\"extruder\", meshing && all2 && all3 && all4) + showElement(\"polar-nc\", meshing && all2 && all3 && all4) + showElement(\"shaper\", meshing && all2 && all3 && all4) + showElement(\"mesh-explorer\", meshing && all2 && all3 && all4) + showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4) + showElement(\"minimal-surface\", meshing && all2 && (galerkin || amr || pa) && all4) + showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4) + showElement(\"gslib-interpolation\", meshing && all2 && all3 && all4) // shifted methods miniapps + showElement(\"distance\", all1 && h1 && galerkin && (pcg || gmres || amg || newton)) // external miniapps + showElement(\"laghos\", (compressibleflow) && (l2 || h1) && (galerkin || dg || pa) && (rk)) + showElement(\"remhos\", (advection) && (l2) && (galerkin || dg || pa) && (rk)) + showElement(\"navier\", (incompressibleflow) && (h1) && (galerkin || pa) && (gmres || pcg || amg)) + showElement(\"block-solvers\", darcy && (l2 || hdiv || hcurl) && mixed && (gmres || pcg || minres || amg)) + showElement(\"overlapping\", (incompressibleflow || diffusion || meshing) && (h1) && (galerkin) && (gmres || pcg)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown === 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Overlapping Grids Miniapps"},{"location":"features/","text":"Features The goal of MFEM is to enable high-performance scalable finite element discretization research and application development on a wide variety of platforms, ranging from laptops to supercomputers. Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Higher-order Finite Element Spaces MFEM supports a wide variety of finite element spaces in 2D and 3D, including arbitrary high-order: H 1 -conforming, H(div) -conforming, H(curl) -conforming spaces, discontinuous L 2 spaces, numerical trace ( interfacial ) spaces, NURBS spaces for isogeometric analysis. Many bilinear and linear forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code. Flexible Discretization In addition to classical Galerkin methods, MFEM enables the quick prototyping of mixed finite elements, Discontinuous Galerkin ( DG ) methods, isogeometric analysis methods, Discontinuous Petrov-Galerkin ( DPG ) approaches, Hybridization and static condensation for high-order problems. Wide Range of Mesh Types MFEM supports arbitrary element transformations and includes classes for dealing with: triangular, quadrilateral, tetrahedral, wedge, and hexahedral elements , uniform refinement (all element types), conforming local mesh refinement (triangular/tetrahedral meshes), non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement, mesh optimization based on the Target-Matrix Optimization Paradigm (TMOP), higher-order elements with curved boundaries, surface meshes embedded in 3D, topologically periodic meshes, 1D meshes. Additional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the PUMI distributed mesh management system. Parallel, Scalable and GPU-ready MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator. MFEM-based applications have been scaled to hundreds of thousands of parallel cores. The library supports efficient operator assembly/evaluation for tensor-product high-order elements. Support for hardware devices, such as GPUs , and programming models, such as CUDA, HIP, OCCA , RAJA and OpenMP is also included. A serial MFEM application typically requires minimal changes to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the hypre library. Both of these versions can be further transitioned to high-performing templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several examples and many linear algebra and finite element operations is available. Built-in Solvers MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors and sparse matrices . Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and matrices are also supported. A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems): point-wise and polynomial serial and parallel smoothers, Krylov solvers , such as PCG, MINRES and GMRES applicable to general operators in serial and in parallel, parallel eigensolvers : LOBPCG and AME, high-performance preconditioners from the hypre library including the BoomerAMG , AMS and ADS solvers, many linear and nonlinear solvers, preconditioners and time integrators from the PETSc suite, several eigensolvers from the SLEPc suite, various iterative solvers and preconditioners on multiple architectures (OpenMP, CUDA and HIP) from the Ginkgo library. time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the SUNDIALS suite, discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods, parallel and serial sparse direct solvers based on SuperLU , STRUMPACK and the SuiteSparse library, explicit and implicit high-order Runge-Kutta time integrators , solvers for nonlinear problems (Newton, HiOp ) and for single linearly constrained quadratic minimization problems. Extensive Examples MFEM includes a number of well-documented example codes that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are: Example 0 : simplest MFEM example, good starting point for new users (nodal H1 FEM for the Laplace problem), Example 1 : nodal H1 FEM for the Laplace problem, Example 2 : vector FEM for linear elasticity, Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem, Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem, Example 5 : mixed pressure-velocity FEM for the Darcy problem, Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem, Example 7 : Laplace problem on a surface (the unit sphere), Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem, Example 9 : Discontinuous Galerkin (DG) time-dependent advection, Example 10 : time-dependent implicit nonlinear elasticity, Example 11 : parallel Laplace eigensolver, Example 12 : parallel linear elasticity eigensolver, Example 13 : parallel Maxwell eigensolver, Example 14 : Discontinuous Galerkin (DG) for the Laplace problem, Example 15 : dynamic AMR for Laplace with prescribed time-dependent source, Example 16 : time-dependent nonlinear heat equation, Example 17 : Discontinuous Galerkin (DG) for linear elasticity, Example 18 : Discontinuous Galerkin (DG) for the Euler equations, Example 19 : incompressible nonlinear elasticity, Example 20 : symplectic ODE integration, Example 21 : adaptive mesh refinement for linear elasticity, Example 22 : complex-valued linear systems, Example 23 : second order in time wave equation, Example 24 : mixed finite element spaces and interpolators, Example 25 : Perfectly Matched Layer (PML) for Maxwell equations, Example 26 : multigrid preconditioner for the Laplace problem, Example 27 : boundary conditions for the Laplace problem, Example 28 : constraints and sliding boundary conditions. Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two. Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc , SLEPc , SUNDIALS , PUMI , Ginkgo and HiOp . Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are: Volta : simple electrostatics simulation code, Tesla : simple magnetostatics simulation code, Maxwell : transient electromagnetics simulation code, Joule : transient magnetics and Joule heating miniapp, Navier : solver for the incompressible time-dependent Navier-Stokes equations, Mesh Explorer : visualize and manipulate meshes, Mesh Optimizer : optimize high-order meshes, Interpolation : evaluation of high-order finite element functions in physical space, Overlapping Grids : Schwarz coupling of single- and multi-physics problems, Distance : finite element distance solver, Minimal Surface : compute the minimal surface of a given mesh, Display Basis : visualize finite element basis functions, Get Values : extract field values via DataCollection classes, Load DC : visualize fields saved via DataCollection classes, Convert DC : convert between different DataCollection formats, LOR Transfer : map functions between high-order and low-order-refined spaces. In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available: Laghos : high-order Lagrangian hydrodynamics miniapp, Remhos : high-order advection remap miniapp, Mulard : multigroup thermal radiation diffusion mini application. A handful of \"toy\" miniapps of less serious nature demonstrate the flexibility of MFEM (and provide a bit of fun): Automata : model of a simple cellular automata, Life : model of Conway's game of life, Lissajous : spinning optical illusion, Mandel : fractal visualization with AMR, Mondrian : convert any image to an AMR mesh, Rubik : interactive Rubik's Cube\u2122 puzzle, Snake : model of the Rubik's Snake\u2122 puzzle. Accurate and Flexible Visualization The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool GLVis , which is built on top of MFEM. The VisIt visualization and analysis tool also natively supports MFEM formats. Another visualization tool natively supported by MFEM is ParaView . The file format supports high-order (up to order six) meshes and elements. Lightweight, Portable and Easily Extendable The MFEM code base is relatively small and is written in highly portable C++ (e.g. with very limited use of templates and the STL). The serial version of MFEM has no external dependencies and is straightforward to build on Linux, Mac and Windows machines. The MPI-parallel version uses two third-party libraries ( hypre and METIS), and is also easy to build with an MPI compiler. On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively. The object-oriented design of MFEM separates the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of applications . Open Source MFEM is an open-source software, and can be freely used under the terms of the BSD license.","title":"Features"},{"location":"features/#features","text":"The goal of MFEM is to enable high-performance scalable finite element discretization research and application development on a wide variety of platforms, ranging from laptops to supercomputers. Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.","title":"Features"},{"location":"features/#higher-order-finite-element-spaces","text":"MFEM supports a wide variety of finite element spaces in 2D and 3D, including arbitrary high-order: H 1 -conforming, H(div) -conforming, H(curl) -conforming spaces, discontinuous L 2 spaces, numerical trace ( interfacial ) spaces, NURBS spaces for isogeometric analysis. Many bilinear and linear forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.","title":"Higher-order Finite Element Spaces"},{"location":"features/#flexible-discretization","text":"In addition to classical Galerkin methods, MFEM enables the quick prototyping of mixed finite elements, Discontinuous Galerkin ( DG ) methods, isogeometric analysis methods, Discontinuous Petrov-Galerkin ( DPG ) approaches, Hybridization and static condensation for high-order problems.","title":"Flexible Discretization"},{"location":"features/#wide-range-of-mesh-types","text":"MFEM supports arbitrary element transformations and includes classes for dealing with: triangular, quadrilateral, tetrahedral, wedge, and hexahedral elements , uniform refinement (all element types), conforming local mesh refinement (triangular/tetrahedral meshes), non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement, mesh optimization based on the Target-Matrix Optimization Paradigm (TMOP), higher-order elements with curved boundaries, surface meshes embedded in 3D, topologically periodic meshes, 1D meshes. Additional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the PUMI distributed mesh management system.","title":"Wide Range of Mesh Types"},{"location":"features/#parallel-scalable-and-gpu-ready","text":"MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator. MFEM-based applications have been scaled to hundreds of thousands of parallel cores. The library supports efficient operator assembly/evaluation for tensor-product high-order elements. Support for hardware devices, such as GPUs , and programming models, such as CUDA, HIP, OCCA , RAJA and OpenMP is also included. A serial MFEM application typically requires minimal changes to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the hypre library. Both of these versions can be further transitioned to high-performing templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several examples and many linear algebra and finite element operations is available.","title":"Parallel, Scalable and GPU-ready"},{"location":"features/#built-in-solvers","text":"MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors and sparse matrices . Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and matrices are also supported. A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems): point-wise and polynomial serial and parallel smoothers, Krylov solvers , such as PCG, MINRES and GMRES applicable to general operators in serial and in parallel, parallel eigensolvers : LOBPCG and AME, high-performance preconditioners from the hypre library including the BoomerAMG , AMS and ADS solvers, many linear and nonlinear solvers, preconditioners and time integrators from the PETSc suite, several eigensolvers from the SLEPc suite, various iterative solvers and preconditioners on multiple architectures (OpenMP, CUDA and HIP) from the Ginkgo library. time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the SUNDIALS suite, discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods, parallel and serial sparse direct solvers based on SuperLU , STRUMPACK and the SuiteSparse library, explicit and implicit high-order Runge-Kutta time integrators , solvers for nonlinear problems (Newton, HiOp ) and for single linearly constrained quadratic minimization problems.","title":"Built-in Solvers"},{"location":"features/#extensive-examples","text":"MFEM includes a number of well-documented example codes that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are: Example 0 : simplest MFEM example, good starting point for new users (nodal H1 FEM for the Laplace problem), Example 1 : nodal H1 FEM for the Laplace problem, Example 2 : vector FEM for linear elasticity, Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem, Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem, Example 5 : mixed pressure-velocity FEM for the Darcy problem, Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem, Example 7 : Laplace problem on a surface (the unit sphere), Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem, Example 9 : Discontinuous Galerkin (DG) time-dependent advection, Example 10 : time-dependent implicit nonlinear elasticity, Example 11 : parallel Laplace eigensolver, Example 12 : parallel linear elasticity eigensolver, Example 13 : parallel Maxwell eigensolver, Example 14 : Discontinuous Galerkin (DG) for the Laplace problem, Example 15 : dynamic AMR for Laplace with prescribed time-dependent source, Example 16 : time-dependent nonlinear heat equation, Example 17 : Discontinuous Galerkin (DG) for linear elasticity, Example 18 : Discontinuous Galerkin (DG) for the Euler equations, Example 19 : incompressible nonlinear elasticity, Example 20 : symplectic ODE integration, Example 21 : adaptive mesh refinement for linear elasticity, Example 22 : complex-valued linear systems, Example 23 : second order in time wave equation, Example 24 : mixed finite element spaces and interpolators, Example 25 : Perfectly Matched Layer (PML) for Maxwell equations, Example 26 : multigrid preconditioner for the Laplace problem, Example 27 : boundary conditions for the Laplace problem, Example 28 : constraints and sliding boundary conditions. Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two. Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc , SLEPc , SUNDIALS , PUMI , Ginkgo and HiOp . Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are: Volta : simple electrostatics simulation code, Tesla : simple magnetostatics simulation code, Maxwell : transient electromagnetics simulation code, Joule : transient magnetics and Joule heating miniapp, Navier : solver for the incompressible time-dependent Navier-Stokes equations, Mesh Explorer : visualize and manipulate meshes, Mesh Optimizer : optimize high-order meshes, Interpolation : evaluation of high-order finite element functions in physical space, Overlapping Grids : Schwarz coupling of single- and multi-physics problems, Distance : finite element distance solver, Minimal Surface : compute the minimal surface of a given mesh, Display Basis : visualize finite element basis functions, Get Values : extract field values via DataCollection classes, Load DC : visualize fields saved via DataCollection classes, Convert DC : convert between different DataCollection formats, LOR Transfer : map functions between high-order and low-order-refined spaces. In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available: Laghos : high-order Lagrangian hydrodynamics miniapp, Remhos : high-order advection remap miniapp, Mulard : multigroup thermal radiation diffusion mini application. A handful of \"toy\" miniapps of less serious nature demonstrate the flexibility of MFEM (and provide a bit of fun): Automata : model of a simple cellular automata, Life : model of Conway's game of life, Lissajous : spinning optical illusion, Mandel : fractal visualization with AMR, Mondrian : convert any image to an AMR mesh, Rubik : interactive Rubik's Cube\u2122 puzzle, Snake : model of the Rubik's Snake\u2122 puzzle.","title":"Extensive Examples"},{"location":"features/#accurate-and-flexible-visualization","text":"The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool GLVis , which is built on top of MFEM. The VisIt visualization and analysis tool also natively supports MFEM formats. Another visualization tool natively supported by MFEM is ParaView . The file format supports high-order (up to order six) meshes and elements.","title":"Accurate and Flexible Visualization"},{"location":"features/#lightweight-portable-and-easily-extendable","text":"The MFEM code base is relatively small and is written in highly portable C++ (e.g. with very limited use of templates and the STL). The serial version of MFEM has no external dependencies and is straightforward to build on Linux, Mac and Windows machines. The MPI-parallel version uses two third-party libraries ( hypre and METIS), and is also easy to build with an MPI compiler. On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively. The object-oriented design of MFEM separates the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of applications .","title":"Lightweight, Portable and Easily Extendable"},{"location":"features/#open-source","text":"MFEM is an open-source software, and can be freely used under the terms of the BSD license.","title":"Open Source"},{"location":"fem/","text":"Finite Element Method The finite element method is a general discretization technique that can utilize unstructured grids to approximate the solutions of many partial differential equations (PDEs). There is a large body of literature on finite elements, including the following excellent books: Numerical Solution of Partial Differential Equations by the Finite Element Method by Claes Johnson Theory and Practice of Finite Elements by Alexandre Ern and Jean-Luc Guermond Higher-Order Finite Element Methods by Pavel \u0160ol\u00edn , Karel Segeth and Ivo Dole\u017eel High-Order Methods for Incompressible Fluid Flow by Michel Deville , Paul Fischer and Ernest Mund Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess The Finite Element Method for Elliptic Problems by Philippe Ciarlet The Mathematical Theory of Finite Element Methods by Susanne Brenner and Ridgway Scott An Analysis of the Finite Element Method by Gilbert Strang and George Fix The Finite Element Method: Its Basis and Fundamentals by Olek Zienkiewicz , Robert Taylor and J.Z. Zhu The MFEM library is designed to be lightweight, general and highly scalable finite element toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Some of the C++ classes for the finite element realizations of these PDE-level concepts in MFEM are described below. Primal and Dual Vectors The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Bilinear Form Integrators Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). The BilinearForm class adds several BilinearFormIntegrator s together to build the global sparse finite element matrix. Linear Form Integrators Linear form integrators are used to compute the integrals of products of a basis function with a given source function over individual mesh elements (or sometimes over edges or faces). The LinearForm class adds several LinearFormIntegrator s together to build the global right-hand side for the finite element linear system. Coefficients The Coefficient objects in MFEM are general functions on continuous level that are used to represent the PDE coefficients of linear and bilinear forms, as well as to specify initial conditions, boundary conditions, exact solutions, etc. Nonlinear Form Integrators Nonlinear form integrators are used to express the local action of a general nonlinear finite element operator. In addition, they may provide the capability to assemble the local gradient operator and to compute the local energy. Linear Interpolators Unlike Bilinear and Linear forms, Linear Interpolators do not perform integrations, but project one basis function (or a linear function of a basis function) onto another basis function. The DiscreteLinearOperator class adds one or more LinearInterpolators together to build a global sparse matrix representation of the linear operator. Weak Formulations Weak formulations are at the heart of the finite element method. Finite element approximations are almost always less smooth than the solutions we hope to approximate. Weak formulations provide a means of approximating derivatives of non-differentiable functions. Boundary Conditions The types of available boundary conditions and how to apply them depend on the discretizations being used. This page describes how to enforce various boundary conditions for certain classes of problems.","title":"Finite Elements"},{"location":"fem/#finite-element-method","text":"The finite element method is a general discretization technique that can utilize unstructured grids to approximate the solutions of many partial differential equations (PDEs). There is a large body of literature on finite elements, including the following excellent books: Numerical Solution of Partial Differential Equations by the Finite Element Method by Claes Johnson Theory and Practice of Finite Elements by Alexandre Ern and Jean-Luc Guermond Higher-Order Finite Element Methods by Pavel \u0160ol\u00edn , Karel Segeth and Ivo Dole\u017eel High-Order Methods for Incompressible Fluid Flow by Michel Deville , Paul Fischer and Ernest Mund Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess The Finite Element Method for Elliptic Problems by Philippe Ciarlet The Mathematical Theory of Finite Element Methods by Susanne Brenner and Ridgway Scott An Analysis of the Finite Element Method by Gilbert Strang and George Fix The Finite Element Method: Its Basis and Fundamentals by Olek Zienkiewicz , Robert Taylor and J.Z. Zhu The MFEM library is designed to be lightweight, general and highly scalable finite element toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Some of the C++ classes for the finite element realizations of these PDE-level concepts in MFEM are described below.","title":"Finite Element Method"},{"location":"fem/#primal-and-dual-vectors","text":"The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play.","title":"Primal and Dual Vectors"},{"location":"fem/#bilinear-form-integrators","text":"Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). The BilinearForm class adds several BilinearFormIntegrator s together to build the global sparse finite element matrix.","title":"Bilinear Form Integrators"},{"location":"fem/#linear-form-integrators","text":"Linear form integrators are used to compute the integrals of products of a basis function with a given source function over individual mesh elements (or sometimes over edges or faces). The LinearForm class adds several LinearFormIntegrator s together to build the global right-hand side for the finite element linear system.","title":"Linear Form Integrators"},{"location":"fem/#coefficients","text":"The Coefficient objects in MFEM are general functions on continuous level that are used to represent the PDE coefficients of linear and bilinear forms, as well as to specify initial conditions, boundary conditions, exact solutions, etc.","title":"Coefficients"},{"location":"fem/#nonlinear-form-integrators","text":"Nonlinear form integrators are used to express the local action of a general nonlinear finite element operator. In addition, they may provide the capability to assemble the local gradient operator and to compute the local energy.","title":"Nonlinear Form Integrators"},{"location":"fem/#linear-interpolators","text":"Unlike Bilinear and Linear forms, Linear Interpolators do not perform integrations, but project one basis function (or a linear function of a basis function) onto another basis function. The DiscreteLinearOperator class adds one or more LinearInterpolators together to build a global sparse matrix representation of the linear operator.","title":"Linear Interpolators"},{"location":"fem/#weak-formulations","text":"Weak formulations are at the heart of the finite element method. Finite element approximations are almost always less smooth than the solutions we hope to approximate. Weak formulations provide a means of approximating derivatives of non-differentiable functions.","title":"Weak Formulations"},{"location":"fem/#boundary-conditions","text":"The types of available boundary conditions and how to apply them depend on the discretizations being used. This page describes how to enforce various boundary conditions for certain classes of problems.","title":"Boundary Conditions"},{"location":"fem_bc/","text":"Boundary Conditions $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} \\newcommand{\\dO}{{\\partial\\Omega}} $ MFEM supports boundary conditions of mixed type through the definition of boundary attributes on the mesh. A boundary attribute is a positive integer assigned to each boundary element of the mesh. Since each boundary element can have only one attribute number the boundary attributes split the boundary into a group of disjoint sets. MFEM allows the user to define boundary conditions on a subset of boundary attributes. Typically mixed boundary conditions are imposed on disjoint portions of the boundary defined as: Symbol Description $\\Gamma\\equiv\\dO$ Boundary of the Domain ($\\Omega$) $\\Gamma_D$ Dirichlet Boundary $\\Gamma_N$ Neumann Boundary $\\Gamma_R$ Robin Boundary $\\Gamma_0$ Natural Boundary Where we assume $\\Gamma = \\Gamma_D\\cup\\Gamma_N\\cup\\Gamma_R\\cup\\Gamma_0$. In MFEM boundaries are usually described by \"marker arrays\". A marker array is an array of integers containing zeros and ones with a length equal to the largest boundary attribute index. // Assume we start with an array containing boundary attribute numbers // stored in bdr_attr. // // Prepare a marker array from a set of attributes Array<int> bdr_marker(pmesh.bdr_attributes.Max()); bdr_marker = 0; for (int i=0; i<bdr_attr.Size(); i++) { bdr_marker[bdr_attr[i]-1] = 1; } Separate marker arrays of this type can be prepared for the Dirichlet, Neumann, and Robin portions of the boundary. It is left to the user to ensure that $\\Gamma_D$, $\\Gamma_N$, and $\\Gamma_R$ are defined as non-overlapping portions of the boundary. Continuous Formulations Dirichlet (Essential) Boundary Conditions In continuous formulations essential boundary conditions are set by modifying the linear system to require the degrees of freedom on the boundary to obtain specific values. This limits the types of constraints that can be imposed on fields. For example, $L^2$ fields have no degrees of freedom on the boundary of elements so essential BCs cannot be applied, H(Curl) (Nedelec) elements can only constrain the tangential components of a vector field, and H(Div) (Raviart-Thomas) elements can only constrain the normal component of a vector field. Space Essential BC H1 $u = f$ on $\\Gamma_D$ H1$^d$ $\\vec{u} = \\vec{f}$ on $\\Gamma_D$ ND $(\\hat{n}\\times\\vec{u})\\times\\hat{n} = \\vec{f}$ on $\\Gamma_D$ RT $\\hat{n}\\cdot\\vec{u} = f$ on $\\Gamma_D$ MFEM provides a convenience method, called FormLinearSystem , on the [Par]BilinearForm class which can prepare a linear system with these essential constraints. // Set the Dirichlet values in the solution vector ParGridFunction u(&fespace); u = 0.0; u.ProjectBdrCoefficient(dbcCoef, dbc_marker); // Prepare the source term in the right-hand-side ParLinearForm b(&fespace); b.AddDomainIntegrator(new DomainLFIntegrator(rhsCoef)); b.Assemble(); // Prepare the bilinear form ParBilinearForm a(&fespace); a.AddDomainIntegrator(new DiffusionIntegrator(matCoef)); a.Assemble(); // Determine the essential degrees of freedom corresponding to the set of // boundary attributes marked in dbc_marker Array<int> ess_tdof_list(0); fespace.GetEssentialTrueDofs(dbc_marker, ess_tdof_list); // Prepare the linear system with enforcement of the essential boundary // conditions OperatorPtr A; Vector B, X; a.FormLinearSystem(ess_tdof_list, u, b, A, X, B); Natural Boundary Conditions The so called \"Natural Boundary Conditions\" arise whenever weak derivatives occur in a PDE (see below for more on weak derivatives ). Weak derivatives must be handled using integration by parts which introduces a boundary integral. If this boundary integral is ignored, its value is implicitly set to zero which creates an implicit constraint on the solution called a \"natural boundary condition\". Continuous Operator Weak Operator Natural BC $-\\div(\\lambda\\grad u)$ $(\\lambda\\grad u,\\grad v)$ $\\hat{n}\\cdot(\\lambda\\grad u)=0$ on $\\Gamma_0$ $\\curl(\\lambda\\curl\\vec{u})$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u})=0$ on $\\Gamma_0$ $-\\grad(\\lambda\\div\\vec{u})$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $\\lambda\\div\\vec{u}=0$ on $\\Gamma_0$ $\\div(\\vec{\\lambda}u)$ $(-\\vec{\\lambda}u,\\grad v)$ $\\hat{n}\\cdot\\vec{\\lambda}u = 0$ on $\\Gamma_0$ $\\curl(\\lambda\\vec{u})$ $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\hat{n}\\cross(\\lambda\\vec{u})=0$ on $\\Gamma_0$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)=0$ on $\\Gamma_0$ No additional implementation is necessary to impose natural boundary conditions. Any portion of the boundary where a Dirichlet, Neumann, or Robin boundary condition has not been applied will receive a natural boundary condition by default. Neumann Boundary Conditions Neumann boundary conditions are closely related to natural boundary conditions. Rather than ignoring the boundary integral we integrate a known function on the boundary which approximates the desired value of the boundary condition (often a involving a derivative of the field). The following table shows a variety of common operators and their related Neumann boundary condition. Operator Continuous Operator Neumann BC $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ $\\hat{n}\\cdot(\\lambda\\grad u)=f$ on $\\Gamma_N$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_N$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}=\\hat{n}\\cdot\\vec{f}$ on $\\Gamma_N$ $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $\\hat{n}\\cdot\\vec{\\lambda}u = f$ on $\\Gamma_N$ $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\hat{n}\\cross(\\lambda\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_N$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)=f$ on $\\Gamma_N$ To impose these boundary conditions in MFEM simply modify the right-hand side of your linear system by adding the appropriate boundary integral of either $f$ or $\\vec{f}$. For $H^1$ or $L^2$ fields this can be accomplished by adding the BoundaryLFIntegrator with an appropriate coefficient for $f$ to a [Par]LinearForm object. Neumann boundary conditions can be added to the above example code by adding the following line before the call to b.Assemble() . // Add Neumann BCs n.(matCoef Grad u) = nbcCoef on the boundary marked in // the nbc_marker array. b.AddBoundaryIntegrator(new BoundaryLFIntegrator(nbcCoef), nbc_marker); For H(Curl) fields this can be accomplished by adding the VectorFEBoundaryTangentLFIntegrator with an appropriate vector coefficient for $\\vec{f}$ to a [Par]LinearForm object. And finally, for H(Div) fields this can be accomplished by adding the VectorFEBoundaryFluxLFIntegrator with an appropriate scalar coefficient for $f = \\hat{n}\\cdot\\vec{f}$ to a [Par]LinearForm object. Other integrators may be appropriate if it is desirable to express the functions $\\,f$ or $\\vec{f}$ in other ways. Robin Boundary Conditions Robin boundary conditions typically involve a linear function of the field and its normal derivative. As such they also arise from weak derivatives and the boundary integrals they introduce to the system of equations. Typical forms of the Robin boundary condition include the following. Operator Continuous Operator Robin BC $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ $\\hat{n}\\cdot(\\lambda\\grad u)+\\gamma\\,u=f$ on $\\Gamma_R$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u}+\\gamma\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_R$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}+\\gamma\\,u=\\hat{n}\\cdot\\vec{f}$ on $\\Gamma_R$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)+\\gamma\\,u=f$ on $\\Gamma_R$ Robin boundary conditions are applied in the same manner as Neumann boundary conditions except that one must also add a boundary integral to the [Par]BilinearForm object to account for the term involving $\\gamma$. For example, when solving for an $H^1$ field one should add a MassIntegrator with an appropriate scalar coefficient for $\\gamma$. The implementation of a Robin boundary condition requires precisely the same change to the right-hand-side as the Neumann boundary condition as well as a new term in the bilinear form before a.Assemble() : // Add Robin BCs n.(matCoef Grad u) rbcACoef u = rbcBCoef on the boundary // marked in the rbc_marker array. b.AddBoundaryIntegrator(new BoundaryLFIntegrator(rbcBCoef), rbc_marker); ... // Add Robin BCs n.(matCoef grad u) + rbcACoef u = rbcBCoef on the boundary // marked in the rbc_marker array. a.AddBoundaryIntegrator(new MassIntegrator(rbcACoef), rbc_marker); Discontinuous Galerkin Formulations In the Discontinuous Galerkin (DG) formulation the Natural , Neumann , and Robin can be implemented in precisely the same manner as in the continuous case. However, since DG basis functions have no degrees of freedom associated with the boundary, Dirichlet boundary conditions must be handled differently. // Add the desired value for the Dirichlet constraint on the boundary // marked in the dbc_marker array. b.AddBdrFaceIntegrator(new DGDirichletLFIntegrator(dbcCoef, matCoef, sigma, kappa), dbc_marker); ... // Add the n.Grad(u) boundary integral on the Dirichlet portion of the // boundary marked in the dbc_marker array. a.AddBdrFaceIntegrator(new DGDiffusionIntegrator(matCoef, sigma, kappa), dbc_marker); Where sigma and kappa are parameters controlling the symmetry and interior penalty used in the DG diffusion formulation. These two integrators work together to balance the natural boundary condition associated with the DiffusionIntegrator and to penalize solutions which differ from the desired Dirichlet value near the boundary. Similar pairs of integrators can be implemented to accommodate other PDEs. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Boundary Conditions"},{"location":"fem_bc/#boundary-conditions","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} \\newcommand{\\dO}{{\\partial\\Omega}} $ MFEM supports boundary conditions of mixed type through the definition of boundary attributes on the mesh. A boundary attribute is a positive integer assigned to each boundary element of the mesh. Since each boundary element can have only one attribute number the boundary attributes split the boundary into a group of disjoint sets. MFEM allows the user to define boundary conditions on a subset of boundary attributes. Typically mixed boundary conditions are imposed on disjoint portions of the boundary defined as: Symbol Description $\\Gamma\\equiv\\dO$ Boundary of the Domain ($\\Omega$) $\\Gamma_D$ Dirichlet Boundary $\\Gamma_N$ Neumann Boundary $\\Gamma_R$ Robin Boundary $\\Gamma_0$ Natural Boundary Where we assume $\\Gamma = \\Gamma_D\\cup\\Gamma_N\\cup\\Gamma_R\\cup\\Gamma_0$. In MFEM boundaries are usually described by \"marker arrays\". A marker array is an array of integers containing zeros and ones with a length equal to the largest boundary attribute index. // Assume we start with an array containing boundary attribute numbers // stored in bdr_attr. // // Prepare a marker array from a set of attributes Array<int> bdr_marker(pmesh.bdr_attributes.Max()); bdr_marker = 0; for (int i=0; i<bdr_attr.Size(); i++) { bdr_marker[bdr_attr[i]-1] = 1; } Separate marker arrays of this type can be prepared for the Dirichlet, Neumann, and Robin portions of the boundary. It is left to the user to ensure that $\\Gamma_D$, $\\Gamma_N$, and $\\Gamma_R$ are defined as non-overlapping portions of the boundary.","title":"Boundary Conditions"},{"location":"fem_bc/#continuous-formulations","text":"","title":"Continuous Formulations"},{"location":"fem_bc/#dirichlet-essential-boundary-conditions","text":"In continuous formulations essential boundary conditions are set by modifying the linear system to require the degrees of freedom on the boundary to obtain specific values. This limits the types of constraints that can be imposed on fields. For example, $L^2$ fields have no degrees of freedom on the boundary of elements so essential BCs cannot be applied, H(Curl) (Nedelec) elements can only constrain the tangential components of a vector field, and H(Div) (Raviart-Thomas) elements can only constrain the normal component of a vector field. Space Essential BC H1 $u = f$ on $\\Gamma_D$ H1$^d$ $\\vec{u} = \\vec{f}$ on $\\Gamma_D$ ND $(\\hat{n}\\times\\vec{u})\\times\\hat{n} = \\vec{f}$ on $\\Gamma_D$ RT $\\hat{n}\\cdot\\vec{u} = f$ on $\\Gamma_D$ MFEM provides a convenience method, called FormLinearSystem , on the [Par]BilinearForm class which can prepare a linear system with these essential constraints. // Set the Dirichlet values in the solution vector ParGridFunction u(&fespace); u = 0.0; u.ProjectBdrCoefficient(dbcCoef, dbc_marker); // Prepare the source term in the right-hand-side ParLinearForm b(&fespace); b.AddDomainIntegrator(new DomainLFIntegrator(rhsCoef)); b.Assemble(); // Prepare the bilinear form ParBilinearForm a(&fespace); a.AddDomainIntegrator(new DiffusionIntegrator(matCoef)); a.Assemble(); // Determine the essential degrees of freedom corresponding to the set of // boundary attributes marked in dbc_marker Array<int> ess_tdof_list(0); fespace.GetEssentialTrueDofs(dbc_marker, ess_tdof_list); // Prepare the linear system with enforcement of the essential boundary // conditions OperatorPtr A; Vector B, X; a.FormLinearSystem(ess_tdof_list, u, b, A, X, B);","title":"Dirichlet (Essential) Boundary Conditions"},{"location":"fem_bc/#natural-boundary-conditions","text":"The so called \"Natural Boundary Conditions\" arise whenever weak derivatives occur in a PDE (see below for more on weak derivatives ). Weak derivatives must be handled using integration by parts which introduces a boundary integral. If this boundary integral is ignored, its value is implicitly set to zero which creates an implicit constraint on the solution called a \"natural boundary condition\". Continuous Operator Weak Operator Natural BC $-\\div(\\lambda\\grad u)$ $(\\lambda\\grad u,\\grad v)$ $\\hat{n}\\cdot(\\lambda\\grad u)=0$ on $\\Gamma_0$ $\\curl(\\lambda\\curl\\vec{u})$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u})=0$ on $\\Gamma_0$ $-\\grad(\\lambda\\div\\vec{u})$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $\\lambda\\div\\vec{u}=0$ on $\\Gamma_0$ $\\div(\\vec{\\lambda}u)$ $(-\\vec{\\lambda}u,\\grad v)$ $\\hat{n}\\cdot\\vec{\\lambda}u = 0$ on $\\Gamma_0$ $\\curl(\\lambda\\vec{u})$ $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\hat{n}\\cross(\\lambda\\vec{u})=0$ on $\\Gamma_0$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)=0$ on $\\Gamma_0$ No additional implementation is necessary to impose natural boundary conditions. Any portion of the boundary where a Dirichlet, Neumann, or Robin boundary condition has not been applied will receive a natural boundary condition by default.","title":"Natural Boundary Conditions"},{"location":"fem_bc/#neumann-boundary-conditions","text":"Neumann boundary conditions are closely related to natural boundary conditions. Rather than ignoring the boundary integral we integrate a known function on the boundary which approximates the desired value of the boundary condition (often a involving a derivative of the field). The following table shows a variety of common operators and their related Neumann boundary condition. Operator Continuous Operator Neumann BC $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ $\\hat{n}\\cdot(\\lambda\\grad u)=f$ on $\\Gamma_N$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_N$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}=\\hat{n}\\cdot\\vec{f}$ on $\\Gamma_N$ $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $\\hat{n}\\cdot\\vec{\\lambda}u = f$ on $\\Gamma_N$ $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\hat{n}\\cross(\\lambda\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_N$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)=f$ on $\\Gamma_N$ To impose these boundary conditions in MFEM simply modify the right-hand side of your linear system by adding the appropriate boundary integral of either $f$ or $\\vec{f}$. For $H^1$ or $L^2$ fields this can be accomplished by adding the BoundaryLFIntegrator with an appropriate coefficient for $f$ to a [Par]LinearForm object. Neumann boundary conditions can be added to the above example code by adding the following line before the call to b.Assemble() . // Add Neumann BCs n.(matCoef Grad u) = nbcCoef on the boundary marked in // the nbc_marker array. b.AddBoundaryIntegrator(new BoundaryLFIntegrator(nbcCoef), nbc_marker); For H(Curl) fields this can be accomplished by adding the VectorFEBoundaryTangentLFIntegrator with an appropriate vector coefficient for $\\vec{f}$ to a [Par]LinearForm object. And finally, for H(Div) fields this can be accomplished by adding the VectorFEBoundaryFluxLFIntegrator with an appropriate scalar coefficient for $f = \\hat{n}\\cdot\\vec{f}$ to a [Par]LinearForm object. Other integrators may be appropriate if it is desirable to express the functions $\\,f$ or $\\vec{f}$ in other ways.","title":"Neumann Boundary Conditions"},{"location":"fem_bc/#robin-boundary-conditions","text":"Robin boundary conditions typically involve a linear function of the field and its normal derivative. As such they also arise from weak derivatives and the boundary integrals they introduce to the system of equations. Typical forms of the Robin boundary condition include the following. Operator Continuous Operator Robin BC $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ $\\hat{n}\\cdot(\\lambda\\grad u)+\\gamma\\,u=f$ on $\\Gamma_R$ $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\hat{n}\\cross(\\lambda\\curl\\vec{u}+\\gamma\\vec{u})=\\hat{n}\\cross\\vec{f}$ on $\\Gamma_R$ $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}+\\gamma\\,u=\\hat{n}\\cdot\\vec{f}$ on $\\Gamma_R$ $(\\lambda\\grad u - \\vec{\\beta}u,\\grad v)$ $-\\div(\\lambda\\grad u) + \\div(\\vec{\\beta}u)$ $\\hat{n}\\cdot(\\lambda\\grad u-\\vec{\\beta}u)+\\gamma\\,u=f$ on $\\Gamma_R$ Robin boundary conditions are applied in the same manner as Neumann boundary conditions except that one must also add a boundary integral to the [Par]BilinearForm object to account for the term involving $\\gamma$. For example, when solving for an $H^1$ field one should add a MassIntegrator with an appropriate scalar coefficient for $\\gamma$. The implementation of a Robin boundary condition requires precisely the same change to the right-hand-side as the Neumann boundary condition as well as a new term in the bilinear form before a.Assemble() : // Add Robin BCs n.(matCoef Grad u) rbcACoef u = rbcBCoef on the boundary // marked in the rbc_marker array. b.AddBoundaryIntegrator(new BoundaryLFIntegrator(rbcBCoef), rbc_marker); ... // Add Robin BCs n.(matCoef grad u) + rbcACoef u = rbcBCoef on the boundary // marked in the rbc_marker array. a.AddBoundaryIntegrator(new MassIntegrator(rbcACoef), rbc_marker);","title":"Robin Boundary Conditions"},{"location":"fem_bc/#discontinuous-galerkin-formulations","text":"In the Discontinuous Galerkin (DG) formulation the Natural , Neumann , and Robin can be implemented in precisely the same manner as in the continuous case. However, since DG basis functions have no degrees of freedom associated with the boundary, Dirichlet boundary conditions must be handled differently. // Add the desired value for the Dirichlet constraint on the boundary // marked in the dbc_marker array. b.AddBdrFaceIntegrator(new DGDirichletLFIntegrator(dbcCoef, matCoef, sigma, kappa), dbc_marker); ... // Add the n.Grad(u) boundary integral on the Dirichlet portion of the // boundary marked in the dbc_marker array. a.AddBdrFaceIntegrator(new DGDiffusionIntegrator(matCoef, sigma, kappa), dbc_marker); Where sigma and kappa are parameters controlling the symmetry and interior penalty used in the DG diffusion formulation. These two integrators work together to balance the natural boundary condition associated with the DiffusionIntegrator and to penalize solutions which differ from the desired Dirichlet value near the boundary. Similar pairs of integrators can be implemented to accommodate other PDEs. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Discontinuous Galerkin Formulations"},{"location":"fem_weak_form/","text":"Weak Formulations $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} \\newcommand{\\dO}{{\\partial\\Omega}} $ Spaces of finite element basis functions are rarely rich enough to contain exact solutions to partial differential equations (PDEs) of interest. This is particularly true when we consider the irregular domains that often arise in practical simulations. One consequence of this is that finite element solutions often don't precisely satisfy the continuous PDEs being modeled. The goal is to build a finite element solution which approximates the true solution and satisfies the PDE in a weaker sense. Consider a general linear differential operator $L(u)$ and the partial differential equation: $$L(u) = f\\mbox{ on }\\Omega$$ We approximate the solution using a linear combination of finite element basis functions which we'll call $\\varphi_i$. $$u\\approx u_h\\equiv\\sum_i\\alpha_i\\varphi_i(\\vec{x})$$ The basis functions $\\varphi_i$ are known but we need to find the degrees of freedom, $\\alpha_i$, which produce a reasonable approximation of $u$. In Galerkin finite element methods this is done by multiplying the PDE by each of the basis functions and integrating over the problem domain. If we have a total of $N$ finite element basis functions, this leads to a set of $N$ equations for the $N$ unknowns. The resulting system of equations for the $\\alpha_i$ is called the \"weak formulation\" of the PDE. The weak formulation of this problem can be written as: $$\\sum_j\\alpha_j\\int_\\Omega L(\\varphi_j)\\varphi_i\\dO = \\int_\\Omega f\\varphi_i\\dO$$ or by the matrix equation: $$M\\vec{\\alpha}=\\vec{f}$$ Where the matrix entries $M_{ij}\\equiv\\int_\\Omega L(\\varphi_j)\\varphi_i\\dO$ and the entries of $\\,\\vec{f}$ are given by $\\,f_i\\equiv\\int_\\Omega f\\varphi_i\\dO$. However, it is much more common to write these integrals using inner product notation: $$(L(u),v)_\\Omega=(f, v)_\\Omega\\,\\forall v\\in V$$ Where $V$ is space spanned by the basis functions $\\varphi_i$. The next step is to examine the linear operator $L(u)$ and determine how to compute the integral $(L(u),v)_\\Omega$ in the most accurate manner possible which leads us to \"weak derivatives\". Weak Derivatives A \"weak derivative\" is a generalization of the notion of a derivative for integrable functions whose derivatives do not exist in the strong sense. When using the finite element method weak derivatives are required whenever terms in a PDE require derivatives of discontinuous or otherwise non-differentiable quantities. Finite element basis functions are typically not smooth functions. Even if they happen to be continuous their derivatives are often at least partially discontinuous. Also, coefficient functions can be discontinuous but, more importantly, their derivatives are often not known. For these reasons PDE terms similar to $\\grad(\\lambda u)$ or $\\div\\grad u$ cannot be accurately computed using finite element basis functions without employing weak derivatives. Consider the following discontinuous approximation to the function $\\cos(2\\pi x)e^{-2x}$. Piecewise linear, discontinuous basis functions can approximate this function rather well on this coarse 4 element mesh. If we simply ignore the discontinuities and compute the piecewise derivatives of the basis functions we obtain the following approximation of the continuous function's derivative. This is a reasonable, albeit quite crude, approximation of the derivative. Expending a little more effort to compute the weak derivative using continuous 2nd order basis functions produces a far superior approximation. Clearly we will benefit from using weak derivatives to handle derivatives of discontinuous functions which arise in our linear operators. Weak Divergence Consider a linear operator of the form $L(u)=-\\div\\vec{\\alpha}(u)$ with $\\vec{\\alpha}\\equiv\\vec{\\beta}u+\\gamma\\grad u$, where $\\vec{\\beta}$ is a vector-valued function and $\\gamma$ is a scalar or tensor-valued function. The function $\\vec{\\alpha}$ is a general linear function of $u$ and its gradient. The weak divergence of this quantity would be calculated by multiplying $\\div\\vec{\\alpha}$ by a test function, $v$, and integrating over the domain $\\Omega$. $$(-\\div\\vec{\\alpha},v)_\\Omega \\equiv-\\int_\\Omega(\\div\\vec{\\alpha})v\\,d\\Omega$$ The negative sign in this expression is only a matter of convention. Using the vector calculus identity, $\\div(\\vec{\\alpha}v) = (\\div\\vec{\\alpha})v + \\vec{\\alpha}\\cdot\\grad v$, we find: $$(-\\div\\vec{\\alpha}, v)_\\Omega = (\\vec{\\alpha}, \\grad v)_\\Omega - \\int_\\Omega\\div(\\vec{\\alpha}v)\\,d\\Omega$$ We then use the Divergence theorem to obtain: $$(-\\div\\vec{\\alpha}, v)_\\Omega = (\\vec{\\alpha}, \\grad v)_\\Omega - \\int_\\dO(\\hat{n}\\cdot\\vec{\\alpha})v\\,d\\Gamma = (\\vec{\\alpha}, \\grad v)_\\Omega - (\\hat{n}\\cdot\\vec{\\alpha},v)_\\dO $$ Where $d\\Gamma$ is the area element on the boundary of $\\Omega$. For linear operators of this type the bilinear form $\\,(\\vec{\\alpha}, \\grad v)_\\Omega$ can be much more accurately approximated than the original bilinear form $\\,(-\\div\\vec{\\alpha}, v)_\\Omega$ provided we can accurately manage the boundary integral $\\,(\\hat{n}\\cdot\\vec{\\alpha},v)_\\dO$. Boundary integrals such as this can be used to incorporate Neumann boundary conditions into a PDE. See the Boundary Conditions page for more information on this. Weak Curl For the next example consider the weak curl of a vector operator. Let $L(u)=\\curl\\vec{\\alpha}(u)$ with $\\vec{\\alpha} \\equiv \\beta\\vec{u}+\\gamma\\curl\\vec{u}$, where $\\beta$ and $\\gamma$ are either scalar or tensor-valued functions. The function $\\vec{\\alpha}$ is a general linear function of $\\vec{u}$ and its curl. The weak curl of this quantity would be calculated by multiplying $\\curl\\vec{\\alpha}$ by a test function, $\\vec{v}$, and integrating over the domain $\\Omega$. $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega \\equiv \\int_\\Omega(\\curl\\vec{\\alpha})\\cdot\\vec{v}\\,d\\Omega$$ Using the vector calculus identity, $\\div(\\vec{\\alpha}\\cross\\vec{v}) = (\\curl\\vec{\\alpha})\\cdot\\vec{v} - \\vec{\\alpha}\\cdot(\\curl\\vec{v})$, we find: $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + \\int_\\Omega\\div(\\vec{\\alpha}\\times\\vec{v})\\,d\\Omega$$ We again use the Divergence theorem to obtain: $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + \\int_\\dO\\hat{n}\\cdot(\\vec{\\alpha}\\times\\vec{v})\\,d\\Gamma = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + (\\hat{n}\\cross\\vec{\\alpha},\\vec{v})_\\dO$$ Where we also made use of the scalar triple product, $\\hat{n}\\cdot(\\vec{\\alpha}\\cross\\vec{v}) = \\vec{v}\\cdot(\\hat{n}\\cross\\vec{\\alpha})$, in the last equality. Again it will be more accurate to use the bilinear form $(\\vec{\\alpha},\\curl\\vec{v})_\\Omega$ and a Neumann boundary condition will arise from the boundary integral. Weak Gradient For the last example consider the weak gradient of a scalar operator. Let $L(u)=-\\grad\\alpha(u)$ with $\\alpha\\equiv\\vec{\\beta}\\cdot\\vec{u}+\\gamma\\div\\vec{u}$, where $\\vec{\\beta}$ is a vector-valued function and $\\gamma$ is a scalar-valued function. The function $\\alpha$ is a general linear function of $\\vec{u}$ and its divergence. The weak gradient of this quantity would be calculated by multiplying $\\grad\\alpha$ by a test function, $\\vec{v}$, and integrating over the domain $\\Omega$. $$(-\\grad\\alpha,\\vec{v})_\\Omega \\equiv -\\int_\\Omega(\\grad\\alpha)\\cdot\\vec{v}\\,d\\Omega$$ The negative sign in this expression is again only a matter of convention. Using the vector calculus identity, $\\div(\\alpha\\vec{v}) = (\\grad\\alpha)\\cdot\\vec{v} + \\alpha\\div\\vec{v}$, we find: $$(-\\grad\\alpha,\\vec{v})_\\Omega = (\\alpha,\\div\\vec{v})_\\Omega - \\int_\\Omega\\div(\\alpha\\vec{v})\\,d\\Omega$$ We again use the Divergence theorem to obtain: $$(-\\grad\\alpha,\\vec{v})_\\Omega = (\\alpha,\\div\\vec{v})_\\Omega - \\int_\\dO\\hat{n}\\cdot(\\alpha\\vec{v})\\,d\\Gamma = (\\alpha,\\div\\vec{v})_\\Omega - (\\alpha\\hat{n},\\vec{v})_\\dO$$ Once again we find a complimentary bilinear form in $(\\alpha,\\div\\vec{v})_\\Omega$ and a boundary integral leading to a Neumann boundary condition. Other Types of Terms Partial differential equations with other types of terms such as spatial derivatives of order three or higher (e.g. $\\nabla^4u$) or coefficients in inconvenient locations (e.g. $\\alpha\\div(\\beta\\grad u)$) will often require the introduction of auxiliary variables unless algebraic manipulations can remove the inconvenient factors. For example, $$\\nabla^4 u=f$$ can be split into a pair of coupled equations: $$ \\begin{align*} \\nabla^2u &= \\psi\\\\ \\nabla^2\\psi &= f \\end{align*} $$ and $$\\alpha\\div(\\beta\\grad u)=f$$ can be split into: $$ \\begin{align*} \\beta\\grad u &= \\psi\\\\ \\alpha\\div\\psi &= f \\end{align*} $$ Careful examination of the required derivatives will often suggest the most appropriate choice for the basis functions to be used for such auxiliary fields. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Weak Formulations"},{"location":"fem_weak_form/#weak-formulations","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} \\newcommand{\\dO}{{\\partial\\Omega}} $ Spaces of finite element basis functions are rarely rich enough to contain exact solutions to partial differential equations (PDEs) of interest. This is particularly true when we consider the irregular domains that often arise in practical simulations. One consequence of this is that finite element solutions often don't precisely satisfy the continuous PDEs being modeled. The goal is to build a finite element solution which approximates the true solution and satisfies the PDE in a weaker sense. Consider a general linear differential operator $L(u)$ and the partial differential equation: $$L(u) = f\\mbox{ on }\\Omega$$ We approximate the solution using a linear combination of finite element basis functions which we'll call $\\varphi_i$. $$u\\approx u_h\\equiv\\sum_i\\alpha_i\\varphi_i(\\vec{x})$$ The basis functions $\\varphi_i$ are known but we need to find the degrees of freedom, $\\alpha_i$, which produce a reasonable approximation of $u$. In Galerkin finite element methods this is done by multiplying the PDE by each of the basis functions and integrating over the problem domain. If we have a total of $N$ finite element basis functions, this leads to a set of $N$ equations for the $N$ unknowns. The resulting system of equations for the $\\alpha_i$ is called the \"weak formulation\" of the PDE. The weak formulation of this problem can be written as: $$\\sum_j\\alpha_j\\int_\\Omega L(\\varphi_j)\\varphi_i\\dO = \\int_\\Omega f\\varphi_i\\dO$$ or by the matrix equation: $$M\\vec{\\alpha}=\\vec{f}$$ Where the matrix entries $M_{ij}\\equiv\\int_\\Omega L(\\varphi_j)\\varphi_i\\dO$ and the entries of $\\,\\vec{f}$ are given by $\\,f_i\\equiv\\int_\\Omega f\\varphi_i\\dO$. However, it is much more common to write these integrals using inner product notation: $$(L(u),v)_\\Omega=(f, v)_\\Omega\\,\\forall v\\in V$$ Where $V$ is space spanned by the basis functions $\\varphi_i$. The next step is to examine the linear operator $L(u)$ and determine how to compute the integral $(L(u),v)_\\Omega$ in the most accurate manner possible which leads us to \"weak derivatives\".","title":"Weak Formulations"},{"location":"fem_weak_form/#weak-derivatives","text":"A \"weak derivative\" is a generalization of the notion of a derivative for integrable functions whose derivatives do not exist in the strong sense. When using the finite element method weak derivatives are required whenever terms in a PDE require derivatives of discontinuous or otherwise non-differentiable quantities. Finite element basis functions are typically not smooth functions. Even if they happen to be continuous their derivatives are often at least partially discontinuous. Also, coefficient functions can be discontinuous but, more importantly, their derivatives are often not known. For these reasons PDE terms similar to $\\grad(\\lambda u)$ or $\\div\\grad u$ cannot be accurately computed using finite element basis functions without employing weak derivatives. Consider the following discontinuous approximation to the function $\\cos(2\\pi x)e^{-2x}$. Piecewise linear, discontinuous basis functions can approximate this function rather well on this coarse 4 element mesh. If we simply ignore the discontinuities and compute the piecewise derivatives of the basis functions we obtain the following approximation of the continuous function's derivative. This is a reasonable, albeit quite crude, approximation of the derivative. Expending a little more effort to compute the weak derivative using continuous 2nd order basis functions produces a far superior approximation. Clearly we will benefit from using weak derivatives to handle derivatives of discontinuous functions which arise in our linear operators.","title":"Weak Derivatives"},{"location":"fem_weak_form/#weak-divergence","text":"Consider a linear operator of the form $L(u)=-\\div\\vec{\\alpha}(u)$ with $\\vec{\\alpha}\\equiv\\vec{\\beta}u+\\gamma\\grad u$, where $\\vec{\\beta}$ is a vector-valued function and $\\gamma$ is a scalar or tensor-valued function. The function $\\vec{\\alpha}$ is a general linear function of $u$ and its gradient. The weak divergence of this quantity would be calculated by multiplying $\\div\\vec{\\alpha}$ by a test function, $v$, and integrating over the domain $\\Omega$. $$(-\\div\\vec{\\alpha},v)_\\Omega \\equiv-\\int_\\Omega(\\div\\vec{\\alpha})v\\,d\\Omega$$ The negative sign in this expression is only a matter of convention. Using the vector calculus identity, $\\div(\\vec{\\alpha}v) = (\\div\\vec{\\alpha})v + \\vec{\\alpha}\\cdot\\grad v$, we find: $$(-\\div\\vec{\\alpha}, v)_\\Omega = (\\vec{\\alpha}, \\grad v)_\\Omega - \\int_\\Omega\\div(\\vec{\\alpha}v)\\,d\\Omega$$ We then use the Divergence theorem to obtain: $$(-\\div\\vec{\\alpha}, v)_\\Omega = (\\vec{\\alpha}, \\grad v)_\\Omega - \\int_\\dO(\\hat{n}\\cdot\\vec{\\alpha})v\\,d\\Gamma = (\\vec{\\alpha}, \\grad v)_\\Omega - (\\hat{n}\\cdot\\vec{\\alpha},v)_\\dO $$ Where $d\\Gamma$ is the area element on the boundary of $\\Omega$. For linear operators of this type the bilinear form $\\,(\\vec{\\alpha}, \\grad v)_\\Omega$ can be much more accurately approximated than the original bilinear form $\\,(-\\div\\vec{\\alpha}, v)_\\Omega$ provided we can accurately manage the boundary integral $\\,(\\hat{n}\\cdot\\vec{\\alpha},v)_\\dO$. Boundary integrals such as this can be used to incorporate Neumann boundary conditions into a PDE. See the Boundary Conditions page for more information on this.","title":"Weak Divergence"},{"location":"fem_weak_form/#weak-curl","text":"For the next example consider the weak curl of a vector operator. Let $L(u)=\\curl\\vec{\\alpha}(u)$ with $\\vec{\\alpha} \\equiv \\beta\\vec{u}+\\gamma\\curl\\vec{u}$, where $\\beta$ and $\\gamma$ are either scalar or tensor-valued functions. The function $\\vec{\\alpha}$ is a general linear function of $\\vec{u}$ and its curl. The weak curl of this quantity would be calculated by multiplying $\\curl\\vec{\\alpha}$ by a test function, $\\vec{v}$, and integrating over the domain $\\Omega$. $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega \\equiv \\int_\\Omega(\\curl\\vec{\\alpha})\\cdot\\vec{v}\\,d\\Omega$$ Using the vector calculus identity, $\\div(\\vec{\\alpha}\\cross\\vec{v}) = (\\curl\\vec{\\alpha})\\cdot\\vec{v} - \\vec{\\alpha}\\cdot(\\curl\\vec{v})$, we find: $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + \\int_\\Omega\\div(\\vec{\\alpha}\\times\\vec{v})\\,d\\Omega$$ We again use the Divergence theorem to obtain: $$(\\curl\\vec{\\alpha},\\vec{v})_\\Omega = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + \\int_\\dO\\hat{n}\\cdot(\\vec{\\alpha}\\times\\vec{v})\\,d\\Gamma = (\\vec{\\alpha},\\curl\\vec{v})_\\Omega + (\\hat{n}\\cross\\vec{\\alpha},\\vec{v})_\\dO$$ Where we also made use of the scalar triple product, $\\hat{n}\\cdot(\\vec{\\alpha}\\cross\\vec{v}) = \\vec{v}\\cdot(\\hat{n}\\cross\\vec{\\alpha})$, in the last equality. Again it will be more accurate to use the bilinear form $(\\vec{\\alpha},\\curl\\vec{v})_\\Omega$ and a Neumann boundary condition will arise from the boundary integral.","title":"Weak Curl"},{"location":"fem_weak_form/#weak-gradient","text":"For the last example consider the weak gradient of a scalar operator. Let $L(u)=-\\grad\\alpha(u)$ with $\\alpha\\equiv\\vec{\\beta}\\cdot\\vec{u}+\\gamma\\div\\vec{u}$, where $\\vec{\\beta}$ is a vector-valued function and $\\gamma$ is a scalar-valued function. The function $\\alpha$ is a general linear function of $\\vec{u}$ and its divergence. The weak gradient of this quantity would be calculated by multiplying $\\grad\\alpha$ by a test function, $\\vec{v}$, and integrating over the domain $\\Omega$. $$(-\\grad\\alpha,\\vec{v})_\\Omega \\equiv -\\int_\\Omega(\\grad\\alpha)\\cdot\\vec{v}\\,d\\Omega$$ The negative sign in this expression is again only a matter of convention. Using the vector calculus identity, $\\div(\\alpha\\vec{v}) = (\\grad\\alpha)\\cdot\\vec{v} + \\alpha\\div\\vec{v}$, we find: $$(-\\grad\\alpha,\\vec{v})_\\Omega = (\\alpha,\\div\\vec{v})_\\Omega - \\int_\\Omega\\div(\\alpha\\vec{v})\\,d\\Omega$$ We again use the Divergence theorem to obtain: $$(-\\grad\\alpha,\\vec{v})_\\Omega = (\\alpha,\\div\\vec{v})_\\Omega - \\int_\\dO\\hat{n}\\cdot(\\alpha\\vec{v})\\,d\\Gamma = (\\alpha,\\div\\vec{v})_\\Omega - (\\alpha\\hat{n},\\vec{v})_\\dO$$ Once again we find a complimentary bilinear form in $(\\alpha,\\div\\vec{v})_\\Omega$ and a boundary integral leading to a Neumann boundary condition.","title":"Weak Gradient"},{"location":"fem_weak_form/#other-types-of-terms","text":"Partial differential equations with other types of terms such as spatial derivatives of order three or higher (e.g. $\\nabla^4u$) or coefficients in inconvenient locations (e.g. $\\alpha\\div(\\beta\\grad u)$) will often require the introduction of auxiliary variables unless algebraic manipulations can remove the inconvenient factors. For example, $$\\nabla^4 u=f$$ can be split into a pair of coupled equations: $$ \\begin{align*} \\nabla^2u &= \\psi\\\\ \\nabla^2\\psi &= f \\end{align*} $$ and $$\\alpha\\div(\\beta\\grad u)=f$$ can be split into: $$ \\begin{align*} \\beta\\grad u &= \\psi\\\\ \\alpha\\div\\psi &= f \\end{align*} $$ Careful examination of the required derivatives will often suggest the most appropriate choice for the basis functions to be used for such auxiliary fields. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Other Types of Terms"},{"location":"fluids/","text":"Navier-Stokes Mini Application The solver implemented in this miniapp solves the transient incompressible Navier-Stokes equations. Theory The equations are given in the non-dimensionalized form \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u + \\nabla p &= f & \\quad \\text{in } \\Omega\\\\ \\nabla \\cdot u &= 0 & \\quad \\text{in } \\Omega \\end{align} where $Re$ represents the Reynolds number. In order to solve these equations, the method presented in Tomboulides (1997) 1 is used, which is based on an equal order finite element discretization on quadrilateral or hexahedral elements of high polynomial order. The method describes an implicit-explicit time-integration scheme for the viscous and convective terms respectively. Introducing the following notation the nonlinear term $N(u) = -(u \\cdot \\nabla) u$ and the time-extrapolated form \\begin{align} \\label{eq:Next} N^*(u^{n+1}) = \\sum_{j=1}^k a_j N(u^{n+1-j}) \\end{align} where $a_j$ are coefficients from the corresponding explicit time integration method. Applying a BDF method with coefficients $b_j$ to the initial equation using the introduced forms yields \\begin{align} \\sum_{j=0}^k \\frac{b_j}{\\Delta t} u^{n+1-j} = -\\nabla p^{n+1} + L(u^{n+1}) + N^*(u^{n+1}) + f^{n+1}. \\end{align} Collecting all known quantities at a given time with \\begin{align} F^*(u^n) = -\\sum_{j=1}^k \\frac{b_j}{\\Delta t} u^{n+1-j} + N^*(u^{n+1}) + f^{n+1} \\end{align} the BDF expression reduces to \\begin{align} \\label{eq:bdf_short} \\frac{b_0}{\\Delta t} u^{n+1} = -\\nabla p^{n+1} + L(u^{n+1}) + F^*(u^n). \\end{align} To achieve a high order convergence in space the linear term $L(u)$ is replaced by \\begin{align} L_{\\times}(u) = \\nu \\nabla(\\nabla \\cdot u) - \\nu \\nabla \\times \\nabla \\times u \\end{align} which is used to weakly enforce incompressibility by setting the first term to zero. Like in \\eqref{eq:Next} we introduce the time extrapolated term \\begin{align} L^*_{\\times}(u) = \\sum_{j=1}^k a_j L_{\\times}(u^{n+1-j}). \\end{align} To compute the pressure we rearrange \\eqref{eq:bdf_short} and take the divergence on both sides \\begin{align} \\label{eq:prespois} \\nabla^2 p^{n+1} = \\nabla \\cdot (L_{\\times}^*(u^{n+1} + F^*(u^{n+1})), \\end{align} which is closed by the Neumann type boundary condition \\begin{align} \\nabla p^{n+1} \\cdot \\hat{n} = -\\frac{b_0}{\\Delta t} u^{n+1} \\cdot \\hat{n} + (L_{\\times}^*(u^{n+1} + F^*(u^{n+1})) \\cdot \\hat{n}. \\end{align} We will refer to this as the pressure Poisson equation in the following. The last step is a Helmholtz type equation to solve for the implicit (viscous) velocity part which is also derived from \\eqref{eq:bdf_short}. Consider \\begin{align} \\label{eq:hlm} \\frac{b_0}{\\Delta t} u^{n+1} - L(u^{n+1}) = -\\nabla p^{n+1} + F^*(u^{n+1}) \\end{align} with the Dirichlet (essential type) boundary condition \\begin{align} u^{n+1} = g_D^{n+1}. \\end{align} A detailed walk through can also be found in Franco et al (2020) 2 . Note The notation is very similar to what is used in the code to make it easy to follow the theoretical explanation and understand what is done in the implementation. Boundary Conditions Inflow and no-slip walls For inflow or no-slip wall boundary conditions one should use the method NavierSolver::AddVelDirichletBC . This enforces the value on $u^{n+1}$ in \\eqref{eq:hlm}. It is valid to call this method multiple times on different boundary attributes of the mesh. The NavierSolver instance keeps track of the associated Coefficient and accompanying boundary attribute. The passed attribute array can be modified, deleted or reused, since a copy is created. Pressure outlet If an outlet of a domain is supposed to represent a pressure outlet (e.g. zero-pressure), one should use the method NavierSolver::AddPresDirichletBC . This enforces the pressure value $p^{n+1}$ in \\eqref{eq:prespois}. Zero-stress This boundary condition is used to represent an outflow attribute. Due to the nature of the $H^1$ finite-element discretization, the terms arise naturally in \\eqref{eq:prespois} and \\eqref{eq:hlm} resulting in \\begin{align} \\nu \\nabla u \\cdot \\hat{n} - p \\mathbb{I} \\cdot \\hat{n} = 0, \\end{align} where $\\mathbb{I}$ represents the identity tensor. If there is no other boundary condition applied to a certain attribute, this boundary condition is applied automatically (not through modification but rather through the formulation). Solvers and preconditioners The choice of solvers and preconditioners for \\eqref{eq:prespois} and \\eqref{eq:hlm} are essential for the performance and robustness of the simulation. The pressure Poisson equation \\eqref{eq:prespois} is solved using the CG Krylov method in combination with the low-order refined preconditioning technique coupled with AMG (c.f. Franco et al (2020) 2 ). Due to the nature of the explicit time discretization of the nonlinear term, the method used is CFL (and therefore time step) bound. As a result the time derivative term in \\eqref{eq:hlm} is dominating and a CG Krylov method preconditioned with Jacobi is sufficient. Depending on the problem, this results in the majority of time per time step being spent in the pressure Poisson solve. At the moment there is no interface to change the default options for the solvers, but a user can easily modify them in the code itself. FAQ You are using the spectral element method, why is the mass matrix not a vector representing the condensed diagonal? This is a design choice. It is possible to use the \"numerical integration\" option, which produces a diagonal mass matrix with 1 non zero value per row. This leaves freedom to experiment. Do you support simulations using real parameters? No, right now you have to non-dimensionalize your problem. Not doing this impacts the performance a lot. I want to implement turbulence model X, how do I dot that? This is another design choice to make and should be discussed, preferably in a Github issue. Why doesn't it have adaptive time stepping? While it is possible and there exists a branch that works with varying step sizes (variable order/variable step size IMEX), I have not found a reliable and robust method to determine the step size (CFL based error estimators are very squishy here or have to use a very conservative limit). How do I compute steady state solutions with this? There is no acceleration to steady state algorithm implemented right now. Your only option is to run the transient case until you reach a steady state criterion. (See adaptive time stepping FAQ above). MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}}); A. G. Tomboulides, J. C. Y. Lee & S. A. Orszag (1997) Numerical Simulation of Low Mach Number Reactive Flows \u21a9 Michael Franco, Jean-Sylvain Camier, Julian Andrej, Will Pazner (2020) High-order matrix-free incompressible flow solvers with GPU acceleration and low-order refined preconditioners (https://arxiv.org/abs/1910.03032) \u21a9 \u21a9","title":"Fluids"},{"location":"fluids/#navier-stokes-mini-application","text":"The solver implemented in this miniapp solves the transient incompressible Navier-Stokes equations.","title":"Navier-Stokes Mini Application"},{"location":"fluids/#theory","text":"The equations are given in the non-dimensionalized form \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u + \\nabla p &= f & \\quad \\text{in } \\Omega\\\\ \\nabla \\cdot u &= 0 & \\quad \\text{in } \\Omega \\end{align} where $Re$ represents the Reynolds number. In order to solve these equations, the method presented in Tomboulides (1997) 1 is used, which is based on an equal order finite element discretization on quadrilateral or hexahedral elements of high polynomial order. The method describes an implicit-explicit time-integration scheme for the viscous and convective terms respectively. Introducing the following notation the nonlinear term $N(u) = -(u \\cdot \\nabla) u$ and the time-extrapolated form \\begin{align} \\label{eq:Next} N^*(u^{n+1}) = \\sum_{j=1}^k a_j N(u^{n+1-j}) \\end{align} where $a_j$ are coefficients from the corresponding explicit time integration method. Applying a BDF method with coefficients $b_j$ to the initial equation using the introduced forms yields \\begin{align} \\sum_{j=0}^k \\frac{b_j}{\\Delta t} u^{n+1-j} = -\\nabla p^{n+1} + L(u^{n+1}) + N^*(u^{n+1}) + f^{n+1}. \\end{align} Collecting all known quantities at a given time with \\begin{align} F^*(u^n) = -\\sum_{j=1}^k \\frac{b_j}{\\Delta t} u^{n+1-j} + N^*(u^{n+1}) + f^{n+1} \\end{align} the BDF expression reduces to \\begin{align} \\label{eq:bdf_short} \\frac{b_0}{\\Delta t} u^{n+1} = -\\nabla p^{n+1} + L(u^{n+1}) + F^*(u^n). \\end{align} To achieve a high order convergence in space the linear term $L(u)$ is replaced by \\begin{align} L_{\\times}(u) = \\nu \\nabla(\\nabla \\cdot u) - \\nu \\nabla \\times \\nabla \\times u \\end{align} which is used to weakly enforce incompressibility by setting the first term to zero. Like in \\eqref{eq:Next} we introduce the time extrapolated term \\begin{align} L^*_{\\times}(u) = \\sum_{j=1}^k a_j L_{\\times}(u^{n+1-j}). \\end{align} To compute the pressure we rearrange \\eqref{eq:bdf_short} and take the divergence on both sides \\begin{align} \\label{eq:prespois} \\nabla^2 p^{n+1} = \\nabla \\cdot (L_{\\times}^*(u^{n+1} + F^*(u^{n+1})), \\end{align} which is closed by the Neumann type boundary condition \\begin{align} \\nabla p^{n+1} \\cdot \\hat{n} = -\\frac{b_0}{\\Delta t} u^{n+1} \\cdot \\hat{n} + (L_{\\times}^*(u^{n+1} + F^*(u^{n+1})) \\cdot \\hat{n}. \\end{align} We will refer to this as the pressure Poisson equation in the following. The last step is a Helmholtz type equation to solve for the implicit (viscous) velocity part which is also derived from \\eqref{eq:bdf_short}. Consider \\begin{align} \\label{eq:hlm} \\frac{b_0}{\\Delta t} u^{n+1} - L(u^{n+1}) = -\\nabla p^{n+1} + F^*(u^{n+1}) \\end{align} with the Dirichlet (essential type) boundary condition \\begin{align} u^{n+1} = g_D^{n+1}. \\end{align} A detailed walk through can also be found in Franco et al (2020) 2 . Note The notation is very similar to what is used in the code to make it easy to follow the theoretical explanation and understand what is done in the implementation.","title":"Theory"},{"location":"fluids/#boundary-conditions","text":"","title":"Boundary Conditions"},{"location":"fluids/#inflow-and-no-slip-walls","text":"For inflow or no-slip wall boundary conditions one should use the method NavierSolver::AddVelDirichletBC . This enforces the value on $u^{n+1}$ in \\eqref{eq:hlm}. It is valid to call this method multiple times on different boundary attributes of the mesh. The NavierSolver instance keeps track of the associated Coefficient and accompanying boundary attribute. The passed attribute array can be modified, deleted or reused, since a copy is created.","title":"Inflow and no-slip walls"},{"location":"fluids/#pressure-outlet","text":"If an outlet of a domain is supposed to represent a pressure outlet (e.g. zero-pressure), one should use the method NavierSolver::AddPresDirichletBC . This enforces the pressure value $p^{n+1}$ in \\eqref{eq:prespois}.","title":"Pressure outlet"},{"location":"fluids/#zero-stress","text":"This boundary condition is used to represent an outflow attribute. Due to the nature of the $H^1$ finite-element discretization, the terms arise naturally in \\eqref{eq:prespois} and \\eqref{eq:hlm} resulting in \\begin{align} \\nu \\nabla u \\cdot \\hat{n} - p \\mathbb{I} \\cdot \\hat{n} = 0, \\end{align} where $\\mathbb{I}$ represents the identity tensor. If there is no other boundary condition applied to a certain attribute, this boundary condition is applied automatically (not through modification but rather through the formulation).","title":"Zero-stress"},{"location":"fluids/#solvers-and-preconditioners","text":"The choice of solvers and preconditioners for \\eqref{eq:prespois} and \\eqref{eq:hlm} are essential for the performance and robustness of the simulation. The pressure Poisson equation \\eqref{eq:prespois} is solved using the CG Krylov method in combination with the low-order refined preconditioning technique coupled with AMG (c.f. Franco et al (2020) 2 ). Due to the nature of the explicit time discretization of the nonlinear term, the method used is CFL (and therefore time step) bound. As a result the time derivative term in \\eqref{eq:hlm} is dominating and a CG Krylov method preconditioned with Jacobi is sufficient. Depending on the problem, this results in the majority of time per time step being spent in the pressure Poisson solve. At the moment there is no interface to change the default options for the solvers, but a user can easily modify them in the code itself.","title":"Solvers and preconditioners"},{"location":"fluids/#faq","text":"You are using the spectral element method, why is the mass matrix not a vector representing the condensed diagonal? This is a design choice. It is possible to use the \"numerical integration\" option, which produces a diagonal mass matrix with 1 non zero value per row. This leaves freedom to experiment. Do you support simulations using real parameters? No, right now you have to non-dimensionalize your problem. Not doing this impacts the performance a lot. I want to implement turbulence model X, how do I dot that? This is another design choice to make and should be discussed, preferably in a Github issue. Why doesn't it have adaptive time stepping? While it is possible and there exists a branch that works with varying step sizes (variable order/variable step size IMEX), I have not found a reliable and robust method to determine the step size (CFL based error estimators are very squishy here or have to use a very conservative limit). How do I compute steady state solutions with this? There is no acceleration to steady state algorithm implemented right now. Your only option is to run the transient case until you reach a steady state criterion. (See adaptive time stepping FAQ above). MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}}); A. G. Tomboulides, J. C. Y. Lee & S. A. Orszag (1997) Numerical Simulation of Low Mach Number Reactive Flows \u21a9 Michael Franco, Jean-Sylvain Camier, Julian Andrej, Will Pazner (2020) High-order matrix-free incompressible flow solvers with GPU acceleration and low-order refined preconditioners (https://arxiv.org/abs/1910.03032) \u21a9 \u21a9","title":"FAQ"},{"location":"gallery/","text":"Gallery This page collects screenshots from various simulations based on MFEM. Additional images can be found in the GLVis gallery . A version of the MFEM logo demonstrating curvilinear elements, adaptive mesh refinement and (idealized) parallel partitioning. Visualization with GLVis . Incompressible Taylor-Green vortex simulation with high-order finite elements. Visualization with ParaView . Fibers generated by LDRB approach based on 4 Laplacian solves in the Cardioid project. Solution of a Maxwell problem on a Klein bottle. Mesh generated with the klein-bottle miniapp. Solution with Example 3 . Comparisons of equipotential surfaces and force lines from Maxwell's Treatise on Electricity and Magnetism with results from MFEM's Volta miniapp . Level surfaces in the interior of the solution from Example 1 on escher.mesh . Visualization with GLVis . 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Poisson problem on a \"Breather\" surface. Mesh generated with the Mesh Explorer miniapp. Solution with Example 1 . Triple point shock interaction on 4 elements of order 12. Note the element curvature and the high variation of the field inside the lower right element. Streamlines of the magnetic field from a parallel computation of the magnetostatic interaction of two magnetic orbs. Visualization with VTK . Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Slice image of the high harmonic fast wave propagation in the NSTX-U magnetic fusion device. Computed using MFEM's 4th order H(curl) elements by the RF-SciDAC project . An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with Example 13 . High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Two-region AMR mesh generated by the Shaper miniapp from successive adaptation to the outlines of Australia. Radiating Kelvin-Helmholtz modeled with the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Simulation-driven r-adaptivity using TMOP for a three-material high-velocity gas impact in BLAST . Visualization with VisIt . Click here for a movie. The Shaper miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with GLVis . Topology optimization of a drone body using LLNL's LiDO project , based on MFEM. Electric field induced by an MRI gradient coil in a human body. Simulation by the Magnetic Resonance Physics and Instrumentation Group at Harvard Medical School. Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with GLVis . Parallel version of Example 1 on 100 processors with a relatively coarse version of square-disc.mesh . Visualization with GLVis . Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in GLVis . Structural topology optimization with MFEM in LLNL's Center for Design and Optimization . Test of the anisotropic refinement feature on a random mesh. A slightly modified version of Example 1 . Visualization with GLVis . Level lines in a cutting plane of the solution from the parallel version of Example 1 on 64 processors with fichera.mesh . Visualization with GLVis . Cut image of the solution from Example 1 on a sharply twisted, high order toroidal mesh. The mesh was generated with the toroid miniapp.","title":"Gallery"},{"location":"gallery/#gallery","text":"This page collects screenshots from various simulations based on MFEM. Additional images can be found in the GLVis gallery . A version of the MFEM logo demonstrating curvilinear elements, adaptive mesh refinement and (idealized) parallel partitioning. Visualization with GLVis . Incompressible Taylor-Green vortex simulation with high-order finite elements. Visualization with ParaView . Fibers generated by LDRB approach based on 4 Laplacian solves in the Cardioid project. Solution of a Maxwell problem on a Klein bottle. Mesh generated with the klein-bottle miniapp. Solution with Example 3 . Comparisons of equipotential surfaces and force lines from Maxwell's Treatise on Electricity and Magnetism with results from MFEM's Volta miniapp . Level surfaces in the interior of the solution from Example 1 on escher.mesh . Visualization with GLVis . 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Poisson problem on a \"Breather\" surface. Mesh generated with the Mesh Explorer miniapp. Solution with Example 1 . Triple point shock interaction on 4 elements of order 12. Note the element curvature and the high variation of the field inside the lower right element. Streamlines of the magnetic field from a parallel computation of the magnetostatic interaction of two magnetic orbs. Visualization with VTK . Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Slice image of the high harmonic fast wave propagation in the NSTX-U magnetic fusion device. Computed using MFEM's 4th order H(curl) elements by the RF-SciDAC project . An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with Example 13 . High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Two-region AMR mesh generated by the Shaper miniapp from successive adaptation to the outlines of Australia. Radiating Kelvin-Helmholtz modeled with the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Simulation-driven r-adaptivity using TMOP for a three-material high-velocity gas impact in BLAST . Visualization with VisIt . Click here for a movie. The Shaper miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with GLVis . Topology optimization of a drone body using LLNL's LiDO project , based on MFEM. Electric field induced by an MRI gradient coil in a human body. Simulation by the Magnetic Resonance Physics and Instrumentation Group at Harvard Medical School. Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with GLVis . Parallel version of Example 1 on 100 processors with a relatively coarse version of square-disc.mesh . Visualization with GLVis . Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in GLVis . Structural topology optimization with MFEM in LLNL's Center for Design and Optimization . Test of the anisotropic refinement feature on a random mesh. A slightly modified version of Example 1 . Visualization with GLVis . Level lines in a cutting plane of the solution from the parallel version of Example 1 on 64 processors with fichera.mesh . Visualization with GLVis . Cut image of the solution from Example 1 on a sharply twisted, high order toroidal mesh. The mesh was generated with the toroid miniapp.","title":"Gallery"},{"location":"gpu-tips-n-tricks/","text":"GPU support in MFEM MFEM relies mainly on two features for running algorithms on devices such as GPUs: The memory manager handles transparently the moving of data between the host (CPU) and the device (e.g. GPU), The MFEM_FORALL macro allows to abstract for loops to parallelize the execution on an arbitrary device. Vector u; Vector v; // ... auto u_data = u.Read(); // Express the intent to read u auto v_data = v.ReadWrite(); // Express the intent to read and write v MFEM_FORALL(i, u.Size(), // Abstract the loop: for(int i=0; i<u.Size(); i++) { v_data[i] *= u_data[i]; // This block of code is executed on the chosen device }); Memory manager In order to make the use of host/device memory as simple as possible, MFEM relies on internal memory manager. Instead of storing a pointer of type T* , each object that can be accessed on a device contains Memory<T> objects. The Memory<T> objects handle host and device pointers, memory allocations, and data synchronizations between host and device. To get the pointer T* from a Memory<T> object, one has to use the Read() , Write() , or ReadWrite() methods. Read() returns a const T* pointer, and should be used when the data will only be read, Write() returns a T* pointer, and should be used when writing data without using any previously contained data, ReadWrite() returns T* pointer, and should be used when read and write access to the pointer are required. Read() , Write() , and ReadWrite() automatically handle data movement between the host and device. They can optimize data transfer, since e.g. data that is declared as Write() on the host/device need not be updated from the device/host. The method void UseDevice(bool) specifies if a Memory<T> object is intended for computation on host or on device. The Read() , Write() , and ReadWrite() methods will return device pointer if using the device has been set to true with UseDevice , by default it is false and will return a host pointer. Sometimes, it is necessary to access the data specifically on the host. In this case the HostRead() , HostWrite() , and HostReadWrite() methods should be used. In practice, developers rarely have to manipulate Memory<T> objects, instead objects data can be stored using Vector and Array<T> . Vector and Array<T> data pointers can be accessed with the same methods as Memory<T> . Vector v; v.UseDevice(true); const double *device_ptr = v.Read(); const double *host_ptr = v.HostRead(); MFEM_FORALL The idea behind the MFEM_FORALL macro is to have the same behavior as a for loop and hide all device-specific code in order to enable performance portability. Example: for (int i = 0; i < N; i++) { ... } becomes MFEM_FORALL(i, N, { ... }); One class that is convenient to use in combination with the memory manager and MFEM_FORALL is DeviceTensor<N,T> : an N dimensional array containing elements of type T , which by default is double . The Reshape function reshapes its input into such an N dimensional array: Vector a; a.UseDevice(true); const int p = ...; const int q = ...; const int r = ...; const int N = ...; auto A = Reshape(a.Write(), p, q, r, N); // returns a DeviceTensor<4,double> MFEM_FORALL(n, N, { for (int k = 0; k < r; k++) for (int j = 0; j < q; j++) for (int i = 0; i < p; i++) A(i,j,k,n) = ...; }); Several variants of MFEM_FORALL exist, such as MFEM_FORALL_2D and MFEM_FORALL_3D , to help map 2D or 3D blocks of threads to the hardware more efficiently. In the case of a GPU, MFEM_FORALL_3D(i,N,X,Y,Z,{...}) will declare N block of threads each of size X x Y x Z threads, whereas MFEM_FORALL uses N/256 block of threads each of size 256 threads. Using MFEM_FORALL_3D (and MFEM_FORALL_2D ) over MFEM_FORALL results in a higher level of parallelism, the former using N x X x Y x Z software threads and the latter only N software threads. In order to exploit 2D or 3D blocks of threads, it is convenient to use the macro MFEM_FOREACH_THREAD(i,x,p) to use threads as a for loop. The first variable i is the name of the \"loop\" variable, x is the threadId (it can take the values x , y , or z ), and p is the loop upper bound. If we rewrite the previous example using MFEM_FORALL_3D and MFEM_FOREACH_THREAD , we get: Vector a; a.UseDevice(true); const int p = ...; const int q = ...; const int r = ...; const int N = ...; auto A = Reshape(a.Write(), p, q, r, N); // returns a DeviceTensor<4,double> MFEM_FORALL_3D(n, N, p, q, r, { MFEM_FOREACH_THREAD(k,z,r) MFEM_FOREACH_THREAD(j,y,q) MFEM_FOREACH_THREAD(i,x,p) A(i,j,k,n) = ...; }); The reasons for this more complex syntax is to better utilize the hardware, GPUs in particular. Using MFEM_FORALL_3D and MFEM_FOREACH_THREAD allows to use more concurrency N x X x Y x Z threads instead of only N threads with MFEM_FORALL , but more importantly the memory accesses on A(i,j,k,n) are much better with MFEM_FORALL_3D . With MFEM_FORALL_3D , threads access consecutive memory (i.e. coalesced memory access). Because most applied math algorithms are memory bound, having coalesced memory accesses is critical to achieve high performance. Achieving high performance on GPUs Finite element algorithms are usually memory bound on GPUs, and therefore in order to achieve peak performance one has to maximize the utilization of the different memory bandwidths . In particular, the main memory, or device memory, is the memory that has to be maximally used (i.e. saturated ) in order to achieve peak performance. It is important to not saturate memory bandwidth other than the main memory bandwidth, failing to do so will decrease the main memory throughput by creating memory bandwidth bottlenecks. Maximizing the main memory bandwidth is achieved by issuing enough memory transactions and using efficiently the transferred data. The more computationally light a kernel is the more frequently memory transactions are issued, and if there is no memory bandwidth saturated other than the main memory bandwidth, e.g: shared or L1 memory, then the first condition to achieve peak performance is fulfilled. Memory is transferred by contiguous blocks, called cache-line , which are typically the size of 32 float , or 16 double . Since each cache-line is a block of contiguous memory it is common to over-fetch data when accessing non-contiguous memory addresses (because not all the data is used in each cache-line). In the worst case, only one float of each cache-line is used resulting in only 1/32 of the data transferred being used, such a kernel is potentially 32 times slower than a kernel that fully utilizes the data in each cache line. When a kernel is carefully written to use all the data from each cache-line, the memory access are often referred as coalesced memory access. Having coalesced memory access kernels is critical to achieving peak performance. In term of parallelization, when seeing GPUs as having only one level of parallelism over threads, severe constraints are imposed to the kernels in order to achieve high performance. Each thread is limited to 255 float registers, using more registers results in what is known as register spilling which significantly impacts performance, this is why this type of parallelization strategy should only be used for the most simple kernels. Therefore, it is usually a good strategy to see GPUs as having two levels of parallelism: the coarse parallelism level among block of threads, and the fine parallelism level among threads in a block of threads. Threads in different blocks of threads can only exchange data through the main memory, therefore data exchange between blocks of threads should be kept to the absolute minimum. Threads inside a block of threads can exchange data efficiently by using the shared memory . Shared memory can also be used to store data common between threads, but stored data should be carefully managed due to the very limited storage capacity of the shared memory. Due to their low arithmetic intensity, finite element algorithms often require a significant amount of shared memory bandwidth to exchange information between threads in a block. High amounts of shared memory bandwidth usage is a common bottleneck to achieve high performance. In order to be used efficiently, shared memory also requires specific memory access patterns to prevent bank conflicts . When bank conflicts occur, memory access are serialized instead of being parallel. Each cache line in the shared memory is linearly spread over the shared memory banks, if the threads in a block of threads access different data in the same bank then a bank conflict occurs. However, if the threads in a block access the same data in a bank, or different data in different banks, then the memory access can occur optimally in parallel. Profiling on NVIDIA GPUs When profiling to improve the performance of a memory bound kernel, we recommend the following steps: Measure the main memory bandwidth and efficiency: this tells us how far from peak throughput we are. Insure that no register spills are occurring: most kernels can be written without any register spilling. Measure the shared memory bandwidth and efficiency: try to prevent the shared memory to be the performance bottleneck. Optimizing the main memory usage The first thing we need to know is how far from peak throughput and how efficiently the main memory is accessed. For instance, with nvprof the following command nvprof --metrics gld_throughput,gst_throughput,gld_efficiency,gst_efficiency gives us the desired information. The sum of the load throughput ( gld_throughput ) and store throughput ( gst_throughput ) should be as close as possible to the main memory maximum bandwidth. gld_efficiency and gst_efficiency informs us on ratio of requested global memory load/store throughput to required global memory load/store throughput expressed as percentage. As mentioned above, efficiency issues are critical to achieve peak performance and are solved by coalescing memory access. Once we know how far we are from peak throughput, one should look at the main stall reasons to get an idea of what might be slowing down the kernels: Instruction Fetch \u2014 The next assembly instruction has not yet been fetched. Memory Throttle \u2014 A large number of pending memory operations prevent further forward progress. These can be reduced by combining several memory transactions into one. Memory Dependency \u2014 A load/store cannot be made because the required resources are not available or are fully utilized, or too many requests of a given type are outstanding. Memory dependency stalls can potentially be reduced by optimizing memory alignment and access patterns. Synchronization \u2014 The warp is blocked at a _syncthreads() call. Execution Dependency \u2014 An input required by the instruction is not yet available. Execution dependency stalls can potentially be reduced by increasing instruction-level parallelism. You can use nvprof --metrics with: stall_inst_fetch for the percentage of stalls occurring because of instruction fetch, stall_exec_dependency for the percentage of stalls occurring because of execution dependency, stall_memory_dependency for the percentage of stalls occurring because a memory dependency, stall_memory_throttle for the percentage of stalls occurring because of memory throttle, stall_sync for the percentage of stalls occurring because the warp is blocked at a __syncthreads() call. Optimizing the register usage Register spilling can be detected in two ways: Compile for CUDA with -Xptxas=\"-v\" which reports at compilation the register usage and spills for each kernel. Measure the local memory transfers with a profiler to check if there are register spills. nvprof --metrics local_load_transactions,local_store_transactions --kernels myKernel should be 0 . Register spills happen for two main reasons: Each thread uses too many registers, Array indices are not known at compilation time. When each thread uses too many registers it is often useful to redesign the kernel to use more threads per block to perform the computation, this lowers the amount of registers used per thread but usually increases the shared memory usage due to more distributed data. Computing indices at compilation can often be resolved by simply unrolling loops with MFEM_UNROLL and making sure that all the necessary information to compute the indices is known at compilation time. Roofline model A roofline model helps predicting the peak performance achievable by a specific algorithm. The arithmetic intensity is the ratio of the total number of operations divided by the amount of data movement from and to the main memory. By dividing the maximum FLOPs, by the maximum bandwidth we get an arithmetic intensity threshold value between the two main regime of a GPU. A kernel with an arithmetic intensity below or above the threshold value will be memory bound or computation bound respectively. For in depths performance analysis we recommend to look at efficiency issues The list of all the possible metrics for nvprof is available here . Tips & Tricks Compile in debug mode when developing for devices The memory manager performs checks that catches most of the misuse of the memory on host or device. When using device debug, if your code fails you can run gdb or lldb , and set a breakpoint at b mfem::mfem_error . The code will break as soon as it reaches this point and then you can backtrace bt from here to see what went wrong and where. Forcing synchronization with the host or the device It is sometimes needed to force synchronization between host and device data. In order to make sure that the host data is synchronized one should use HostRead() , similarly to ensure synchronized data on the device one should use Read() . Do not use GetData Do not use GetData() to access a pointer for device work since this will always return the host pointer without synchronizing the data with the device. Tracking data movements and allocations Compiling MFEM with MFEM_TRACK_CUDA_MEM can help by printing when data is transferred, allocated, etc. Large amount of data movement between host and device should be avoided at all costs. Pinpoint where this is occurring and see if you can refactor your code so the data stays mainly on the device. Avoid allocating GPU memory too frequently, CUDA malloc calls are slow and can hinder performance. If you really need to allocate frequently GPU memory, consider using a memory pool (e.g. Umpire ), that way the mallocs are much cheaper on the GPU. The UseDevice function It is a good practice to call UseDevice(true) on any Vector intended to go on device right after constructing it. Vector v; v.UseDevice(true); Be aware that UseDevice() is not the same as UseDevice(true) , the first one just returns a boolean that tells you whether the object is intended for computation on the device or not. Using constexpr inside MFEM_FORALL constexpr P = ...; // Results in an error on MSVC MFEM_FORALL(I,N, { double my_data[P]; }); The MFEM_FORALL macro relies on lambda capturing in C++. One issue comes up with compilers such as MSVC is the capturing of constexpr variables inside MFEM_FORALL . According to the C++ standard, constexpr variables do not need to be captured, and should not lose their const-ness in a lambda. However, on MSVC (e.g. in the MFEM AppVeyor CI checks), this can result in errors like: error C2131: expression did not evaluate to a constant A simple fix for this error is to declare the constexpr variable as static constexpr . static constexpr P = ...; // Omitting the static results in an error on MSVC MFEM_FORALL(I,N, { double my_data[P]; }); Similar problems and workarounds are discussed here . Error: \"alias not found\" This error message indicates that you are trying to move an \"alias\" Vector to GPU while its \"base\" Vector did not have a GPU allocation (valid or not) when the alias was created (and may still not have GPU allocation when the move of the \"alias\" was attempted). This is another case where we cannot update the \"base\" Vector because we do not have access to it (and even if we did, there are complications). This can be avoided if one follows the following rule: if you are creating an \"alias\" that will be used on device, you need to ensure that the \"base\" is allocated on that device. Depending on the context, one can use different methods to do that. For example, if the \"base\" is initialized (on host, otherwise there will be no issue) in the same function that will create the alias, one can call base.Write() to create the device allocation followed by base.HostWrite() and then initialize \"base\" on host -- this sequence avoids any unnecessary host-device transfers. Another example: if the \"base\" was initialized outside of the function where the \"alias\" is created, then the most appropriate choice probably is to call base.Read() before creating the \"alias\". Since the alias will need the data on device, the incurred host-to-device transfer is (at least partially) necessary anyway. Ideally, \"base\" Vectors that will be modified/accessed on device through aliases should be allocated on device to begin with, e.g. using Vector::SetSize(int s, MemoryType mt) typically with mt = Device::GetDeviceMemoryType() . MakeRef vectors do not see the same valid host/device data as their base vector Consider the following code snippet where the vector w is defined from v using the MakeRef() method: const int vSize = 10; Vector v; v.UseDevice(true); v.SetSize(vSize); v = 0.0; cout << \"IsHost(v) = \" << IsHostMemory(v.GetMemory().GetMemoryType()) << endl; Vector w; w.MakeRef(v, 0, vSize); cout << \"IsHost(w) = \" << IsHostMemory(w.GetMemory().GetMemoryType()) << endl; auto hv = v.HostWrite(); for (int j = 0; j < vSize; j++) { hv[j] = 1.0; } cout << \"IsHost(v) = \" << IsHostMemory(v.GetMemory().GetMemoryType()) << endl; cout << \"IsHost(w) = \" << IsHostMemory(w.GetMemory().GetMemoryType()) << endl; Vector z; z.UseDevice(true); z.SetSize(vSize); auto dz = z.Write(); auto dw = w.Read(); MFEM_FORALL(i, vSize, { dz[i] = dw[i]; }); z.HostRead(); cout << \"norm(z) = \" << z.Norml2() << endl; dz = z.Write(); auto dv = v.Read(); MFEM_FORALL(i, vSize, { dz[i] = dv[i]; }); z.HostRead(); cout << \"norm(z) = \" << z.Norml2() << endl; The resulting output may be unexpected: IsHost(v) = 0 IsHost(w) = 0 IsHost(v) = 1 IsHost(w) = 0 norm(z) = 0 norm(z) = 3.16228 Basically the issue is that the Memory objects (inside the Vector s) do not know about the other version, so they cannot update the validity flags (the host and device validity flags indicate which of the pointers has valid data) of the other Vector . Also such update may not make sense if you just moved the subvector. There is no easy way to keep the big \"base\" Vector v and the \"alias\" subvector w synchronized when they are being moved/copied between host and device. Therefore such synchronizations need to be done \"manually\" using the methods Vector::SyncMemory and Vector::SyncAliasMemory . In the example above, after you move the \"base\" Vector v to host, you need to \"inform\" the \"alias\" w that the validity flags of its base have been changed. This is done by calling w.SyncMemory(v) which simply copies the validity flags from v to w , there are no host-device memory transfers involved. On the other hand, if in the example you moved w to host and modified it there, and then you want to access the data through the base Vector v (you can think of the more general case here, when w is smaller than v ) then you need to call w.SyncAliasMemory(v) . In this particular case, the call will move the subvector described by w from host to device and update the validity flags of w to be the same as the ones of v . This way the whole Vector v gets the real data in one location -- before the call part of it was on device and the part described by w was on host. Both w.SyncMemory(v) and w.SyncAliasMemory(v) ensure that w gets the validity flags of v , the difference is where the real data is before the call -- in the first case the real data is in v and in the second, it is in w .","title":"GPU Support"},{"location":"gpu-tips-n-tricks/#gpu-support-in-mfem","text":"MFEM relies mainly on two features for running algorithms on devices such as GPUs: The memory manager handles transparently the moving of data between the host (CPU) and the device (e.g. GPU), The MFEM_FORALL macro allows to abstract for loops to parallelize the execution on an arbitrary device. Vector u; Vector v; // ... auto u_data = u.Read(); // Express the intent to read u auto v_data = v.ReadWrite(); // Express the intent to read and write v MFEM_FORALL(i, u.Size(), // Abstract the loop: for(int i=0; i<u.Size(); i++) { v_data[i] *= u_data[i]; // This block of code is executed on the chosen device });","title":"GPU support in MFEM"},{"location":"gpu-tips-n-tricks/#memory-manager","text":"In order to make the use of host/device memory as simple as possible, MFEM relies on internal memory manager. Instead of storing a pointer of type T* , each object that can be accessed on a device contains Memory<T> objects. The Memory<T> objects handle host and device pointers, memory allocations, and data synchronizations between host and device. To get the pointer T* from a Memory<T> object, one has to use the Read() , Write() , or ReadWrite() methods. Read() returns a const T* pointer, and should be used when the data will only be read, Write() returns a T* pointer, and should be used when writing data without using any previously contained data, ReadWrite() returns T* pointer, and should be used when read and write access to the pointer are required. Read() , Write() , and ReadWrite() automatically handle data movement between the host and device. They can optimize data transfer, since e.g. data that is declared as Write() on the host/device need not be updated from the device/host. The method void UseDevice(bool) specifies if a Memory<T> object is intended for computation on host or on device. The Read() , Write() , and ReadWrite() methods will return device pointer if using the device has been set to true with UseDevice , by default it is false and will return a host pointer. Sometimes, it is necessary to access the data specifically on the host. In this case the HostRead() , HostWrite() , and HostReadWrite() methods should be used. In practice, developers rarely have to manipulate Memory<T> objects, instead objects data can be stored using Vector and Array<T> . Vector and Array<T> data pointers can be accessed with the same methods as Memory<T> . Vector v; v.UseDevice(true); const double *device_ptr = v.Read(); const double *host_ptr = v.HostRead();","title":"Memory manager"},{"location":"gpu-tips-n-tricks/#mfem_forall","text":"The idea behind the MFEM_FORALL macro is to have the same behavior as a for loop and hide all device-specific code in order to enable performance portability. Example: for (int i = 0; i < N; i++) { ... } becomes MFEM_FORALL(i, N, { ... }); One class that is convenient to use in combination with the memory manager and MFEM_FORALL is DeviceTensor<N,T> : an N dimensional array containing elements of type T , which by default is double . The Reshape function reshapes its input into such an N dimensional array: Vector a; a.UseDevice(true); const int p = ...; const int q = ...; const int r = ...; const int N = ...; auto A = Reshape(a.Write(), p, q, r, N); // returns a DeviceTensor<4,double> MFEM_FORALL(n, N, { for (int k = 0; k < r; k++) for (int j = 0; j < q; j++) for (int i = 0; i < p; i++) A(i,j,k,n) = ...; }); Several variants of MFEM_FORALL exist, such as MFEM_FORALL_2D and MFEM_FORALL_3D , to help map 2D or 3D blocks of threads to the hardware more efficiently. In the case of a GPU, MFEM_FORALL_3D(i,N,X,Y,Z,{...}) will declare N block of threads each of size X x Y x Z threads, whereas MFEM_FORALL uses N/256 block of threads each of size 256 threads. Using MFEM_FORALL_3D (and MFEM_FORALL_2D ) over MFEM_FORALL results in a higher level of parallelism, the former using N x X x Y x Z software threads and the latter only N software threads. In order to exploit 2D or 3D blocks of threads, it is convenient to use the macro MFEM_FOREACH_THREAD(i,x,p) to use threads as a for loop. The first variable i is the name of the \"loop\" variable, x is the threadId (it can take the values x , y , or z ), and p is the loop upper bound. If we rewrite the previous example using MFEM_FORALL_3D and MFEM_FOREACH_THREAD , we get: Vector a; a.UseDevice(true); const int p = ...; const int q = ...; const int r = ...; const int N = ...; auto A = Reshape(a.Write(), p, q, r, N); // returns a DeviceTensor<4,double> MFEM_FORALL_3D(n, N, p, q, r, { MFEM_FOREACH_THREAD(k,z,r) MFEM_FOREACH_THREAD(j,y,q) MFEM_FOREACH_THREAD(i,x,p) A(i,j,k,n) = ...; }); The reasons for this more complex syntax is to better utilize the hardware, GPUs in particular. Using MFEM_FORALL_3D and MFEM_FOREACH_THREAD allows to use more concurrency N x X x Y x Z threads instead of only N threads with MFEM_FORALL , but more importantly the memory accesses on A(i,j,k,n) are much better with MFEM_FORALL_3D . With MFEM_FORALL_3D , threads access consecutive memory (i.e. coalesced memory access). Because most applied math algorithms are memory bound, having coalesced memory accesses is critical to achieve high performance.","title":"MFEM_FORALL"},{"location":"gpu-tips-n-tricks/#achieving-high-performance-on-gpus","text":"Finite element algorithms are usually memory bound on GPUs, and therefore in order to achieve peak performance one has to maximize the utilization of the different memory bandwidths . In particular, the main memory, or device memory, is the memory that has to be maximally used (i.e. saturated ) in order to achieve peak performance. It is important to not saturate memory bandwidth other than the main memory bandwidth, failing to do so will decrease the main memory throughput by creating memory bandwidth bottlenecks. Maximizing the main memory bandwidth is achieved by issuing enough memory transactions and using efficiently the transferred data. The more computationally light a kernel is the more frequently memory transactions are issued, and if there is no memory bandwidth saturated other than the main memory bandwidth, e.g: shared or L1 memory, then the first condition to achieve peak performance is fulfilled. Memory is transferred by contiguous blocks, called cache-line , which are typically the size of 32 float , or 16 double . Since each cache-line is a block of contiguous memory it is common to over-fetch data when accessing non-contiguous memory addresses (because not all the data is used in each cache-line). In the worst case, only one float of each cache-line is used resulting in only 1/32 of the data transferred being used, such a kernel is potentially 32 times slower than a kernel that fully utilizes the data in each cache line. When a kernel is carefully written to use all the data from each cache-line, the memory access are often referred as coalesced memory access. Having coalesced memory access kernels is critical to achieving peak performance. In term of parallelization, when seeing GPUs as having only one level of parallelism over threads, severe constraints are imposed to the kernels in order to achieve high performance. Each thread is limited to 255 float registers, using more registers results in what is known as register spilling which significantly impacts performance, this is why this type of parallelization strategy should only be used for the most simple kernels. Therefore, it is usually a good strategy to see GPUs as having two levels of parallelism: the coarse parallelism level among block of threads, and the fine parallelism level among threads in a block of threads. Threads in different blocks of threads can only exchange data through the main memory, therefore data exchange between blocks of threads should be kept to the absolute minimum. Threads inside a block of threads can exchange data efficiently by using the shared memory . Shared memory can also be used to store data common between threads, but stored data should be carefully managed due to the very limited storage capacity of the shared memory. Due to their low arithmetic intensity, finite element algorithms often require a significant amount of shared memory bandwidth to exchange information between threads in a block. High amounts of shared memory bandwidth usage is a common bottleneck to achieve high performance. In order to be used efficiently, shared memory also requires specific memory access patterns to prevent bank conflicts . When bank conflicts occur, memory access are serialized instead of being parallel. Each cache line in the shared memory is linearly spread over the shared memory banks, if the threads in a block of threads access different data in the same bank then a bank conflict occurs. However, if the threads in a block access the same data in a bank, or different data in different banks, then the memory access can occur optimally in parallel.","title":"Achieving high performance on GPUs"},{"location":"gpu-tips-n-tricks/#profiling-on-nvidia-gpus","text":"When profiling to improve the performance of a memory bound kernel, we recommend the following steps: Measure the main memory bandwidth and efficiency: this tells us how far from peak throughput we are. Insure that no register spills are occurring: most kernels can be written without any register spilling. Measure the shared memory bandwidth and efficiency: try to prevent the shared memory to be the performance bottleneck.","title":"Profiling on NVIDIA GPUs"},{"location":"gpu-tips-n-tricks/#optimizing-the-main-memory-usage","text":"The first thing we need to know is how far from peak throughput and how efficiently the main memory is accessed. For instance, with nvprof the following command nvprof --metrics gld_throughput,gst_throughput,gld_efficiency,gst_efficiency gives us the desired information. The sum of the load throughput ( gld_throughput ) and store throughput ( gst_throughput ) should be as close as possible to the main memory maximum bandwidth. gld_efficiency and gst_efficiency informs us on ratio of requested global memory load/store throughput to required global memory load/store throughput expressed as percentage. As mentioned above, efficiency issues are critical to achieve peak performance and are solved by coalescing memory access. Once we know how far we are from peak throughput, one should look at the main stall reasons to get an idea of what might be slowing down the kernels: Instruction Fetch \u2014 The next assembly instruction has not yet been fetched. Memory Throttle \u2014 A large number of pending memory operations prevent further forward progress. These can be reduced by combining several memory transactions into one. Memory Dependency \u2014 A load/store cannot be made because the required resources are not available or are fully utilized, or too many requests of a given type are outstanding. Memory dependency stalls can potentially be reduced by optimizing memory alignment and access patterns. Synchronization \u2014 The warp is blocked at a _syncthreads() call. Execution Dependency \u2014 An input required by the instruction is not yet available. Execution dependency stalls can potentially be reduced by increasing instruction-level parallelism. You can use nvprof --metrics with: stall_inst_fetch for the percentage of stalls occurring because of instruction fetch, stall_exec_dependency for the percentage of stalls occurring because of execution dependency, stall_memory_dependency for the percentage of stalls occurring because a memory dependency, stall_memory_throttle for the percentage of stalls occurring because of memory throttle, stall_sync for the percentage of stalls occurring because the warp is blocked at a __syncthreads() call.","title":"Optimizing the main memory usage"},{"location":"gpu-tips-n-tricks/#optimizing-the-register-usage","text":"Register spilling can be detected in two ways: Compile for CUDA with -Xptxas=\"-v\" which reports at compilation the register usage and spills for each kernel. Measure the local memory transfers with a profiler to check if there are register spills. nvprof --metrics local_load_transactions,local_store_transactions --kernels myKernel should be 0 . Register spills happen for two main reasons: Each thread uses too many registers, Array indices are not known at compilation time. When each thread uses too many registers it is often useful to redesign the kernel to use more threads per block to perform the computation, this lowers the amount of registers used per thread but usually increases the shared memory usage due to more distributed data. Computing indices at compilation can often be resolved by simply unrolling loops with MFEM_UNROLL and making sure that all the necessary information to compute the indices is known at compilation time.","title":"Optimizing the register usage"},{"location":"gpu-tips-n-tricks/#roofline-model","text":"A roofline model helps predicting the peak performance achievable by a specific algorithm. The arithmetic intensity is the ratio of the total number of operations divided by the amount of data movement from and to the main memory. By dividing the maximum FLOPs, by the maximum bandwidth we get an arithmetic intensity threshold value between the two main regime of a GPU. A kernel with an arithmetic intensity below or above the threshold value will be memory bound or computation bound respectively. For in depths performance analysis we recommend to look at efficiency issues The list of all the possible metrics for nvprof is available here .","title":"Roofline model"},{"location":"gpu-tips-n-tricks/#tips-tricks","text":"","title":"Tips &amp; Tricks"},{"location":"gpu-tips-n-tricks/#compile-in-debug-mode-when-developing-for-devices","text":"The memory manager performs checks that catches most of the misuse of the memory on host or device. When using device debug, if your code fails you can run gdb or lldb , and set a breakpoint at b mfem::mfem_error . The code will break as soon as it reaches this point and then you can backtrace bt from here to see what went wrong and where.","title":"Compile in debug mode when developing for devices"},{"location":"gpu-tips-n-tricks/#forcing-synchronization-with-the-host-or-the-device","text":"It is sometimes needed to force synchronization between host and device data. In order to make sure that the host data is synchronized one should use HostRead() , similarly to ensure synchronized data on the device one should use Read() .","title":"Forcing synchronization with the host or the device"},{"location":"gpu-tips-n-tricks/#do-not-use-getdata","text":"Do not use GetData() to access a pointer for device work since this will always return the host pointer without synchronizing the data with the device.","title":"Do not use GetData"},{"location":"gpu-tips-n-tricks/#tracking-data-movements-and-allocations","text":"Compiling MFEM with MFEM_TRACK_CUDA_MEM can help by printing when data is transferred, allocated, etc. Large amount of data movement between host and device should be avoided at all costs. Pinpoint where this is occurring and see if you can refactor your code so the data stays mainly on the device. Avoid allocating GPU memory too frequently, CUDA malloc calls are slow and can hinder performance. If you really need to allocate frequently GPU memory, consider using a memory pool (e.g. Umpire ), that way the mallocs are much cheaper on the GPU.","title":"Tracking data movements and allocations"},{"location":"gpu-tips-n-tricks/#the-usedevice-function","text":"It is a good practice to call UseDevice(true) on any Vector intended to go on device right after constructing it. Vector v; v.UseDevice(true); Be aware that UseDevice() is not the same as UseDevice(true) , the first one just returns a boolean that tells you whether the object is intended for computation on the device or not.","title":"The UseDevice function"},{"location":"gpu-tips-n-tricks/#using-constexpr-inside-mfem_forall","text":"constexpr P = ...; // Results in an error on MSVC MFEM_FORALL(I,N, { double my_data[P]; }); The MFEM_FORALL macro relies on lambda capturing in C++. One issue comes up with compilers such as MSVC is the capturing of constexpr variables inside MFEM_FORALL . According to the C++ standard, constexpr variables do not need to be captured, and should not lose their const-ness in a lambda. However, on MSVC (e.g. in the MFEM AppVeyor CI checks), this can result in errors like: error C2131: expression did not evaluate to a constant A simple fix for this error is to declare the constexpr variable as static constexpr . static constexpr P = ...; // Omitting the static results in an error on MSVC MFEM_FORALL(I,N, { double my_data[P]; }); Similar problems and workarounds are discussed here .","title":"Using constexpr inside MFEM_FORALL"},{"location":"gpu-tips-n-tricks/#error-alias-not-found","text":"This error message indicates that you are trying to move an \"alias\" Vector to GPU while its \"base\" Vector did not have a GPU allocation (valid or not) when the alias was created (and may still not have GPU allocation when the move of the \"alias\" was attempted). This is another case where we cannot update the \"base\" Vector because we do not have access to it (and even if we did, there are complications). This can be avoided if one follows the following rule: if you are creating an \"alias\" that will be used on device, you need to ensure that the \"base\" is allocated on that device. Depending on the context, one can use different methods to do that. For example, if the \"base\" is initialized (on host, otherwise there will be no issue) in the same function that will create the alias, one can call base.Write() to create the device allocation followed by base.HostWrite() and then initialize \"base\" on host -- this sequence avoids any unnecessary host-device transfers. Another example: if the \"base\" was initialized outside of the function where the \"alias\" is created, then the most appropriate choice probably is to call base.Read() before creating the \"alias\". Since the alias will need the data on device, the incurred host-to-device transfer is (at least partially) necessary anyway. Ideally, \"base\" Vectors that will be modified/accessed on device through aliases should be allocated on device to begin with, e.g. using Vector::SetSize(int s, MemoryType mt) typically with mt = Device::GetDeviceMemoryType() .","title":"Error: \"alias not found\""},{"location":"gpu-tips-n-tricks/#makeref-vectors-do-not-see-the-same-valid-hostdevice-data-as-their-base-vector","text":"Consider the following code snippet where the vector w is defined from v using the MakeRef() method: const int vSize = 10; Vector v; v.UseDevice(true); v.SetSize(vSize); v = 0.0; cout << \"IsHost(v) = \" << IsHostMemory(v.GetMemory().GetMemoryType()) << endl; Vector w; w.MakeRef(v, 0, vSize); cout << \"IsHost(w) = \" << IsHostMemory(w.GetMemory().GetMemoryType()) << endl; auto hv = v.HostWrite(); for (int j = 0; j < vSize; j++) { hv[j] = 1.0; } cout << \"IsHost(v) = \" << IsHostMemory(v.GetMemory().GetMemoryType()) << endl; cout << \"IsHost(w) = \" << IsHostMemory(w.GetMemory().GetMemoryType()) << endl; Vector z; z.UseDevice(true); z.SetSize(vSize); auto dz = z.Write(); auto dw = w.Read(); MFEM_FORALL(i, vSize, { dz[i] = dw[i]; }); z.HostRead(); cout << \"norm(z) = \" << z.Norml2() << endl; dz = z.Write(); auto dv = v.Read(); MFEM_FORALL(i, vSize, { dz[i] = dv[i]; }); z.HostRead(); cout << \"norm(z) = \" << z.Norml2() << endl; The resulting output may be unexpected: IsHost(v) = 0 IsHost(w) = 0 IsHost(v) = 1 IsHost(w) = 0 norm(z) = 0 norm(z) = 3.16228 Basically the issue is that the Memory objects (inside the Vector s) do not know about the other version, so they cannot update the validity flags (the host and device validity flags indicate which of the pointers has valid data) of the other Vector . Also such update may not make sense if you just moved the subvector. There is no easy way to keep the big \"base\" Vector v and the \"alias\" subvector w synchronized when they are being moved/copied between host and device. Therefore such synchronizations need to be done \"manually\" using the methods Vector::SyncMemory and Vector::SyncAliasMemory . In the example above, after you move the \"base\" Vector v to host, you need to \"inform\" the \"alias\" w that the validity flags of its base have been changed. This is done by calling w.SyncMemory(v) which simply copies the validity flags from v to w , there are no host-device memory transfers involved. On the other hand, if in the example you moved w to host and modified it there, and then you want to access the data through the base Vector v (you can think of the more general case here, when w is smaller than v ) then you need to call w.SyncAliasMemory(v) . In this particular case, the call will move the subvector described by w from host to device and update the validity flags of w to be the same as the ones of v . This way the whole Vector v gets the real data in one location -- before the call part of it was on device and the part described by w was on host. Both w.SyncMemory(v) and w.SyncAliasMemory(v) ensure that w gets the validity flags of v , the difference is where the real data is before the call -- in the first case the real data is in v and in the second, it is in w .","title":"MakeRef vectors do not see the same valid host/device data as their base vector"},{"location":"lininteg/","text":"Linear Form Integrators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Linear form integrators are the right-hand side companion to Bilinear Form Integrators that compute the integrals of products of a basis function and a given \"right-hand side\" function (coefficient) $\\,f$ over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions, therefore linear integrators simultaneously compute the integrals of all combinations of the relevant basis functions with the given input function $\\,f$. This produces a one dimensional array of results that is arranged into a small vector of integral (dual) values called a local element (load) vector . To put this another way, the LinearForm class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet whereas the LinearFormIntegrator class performs the nested inner loops to compute the local vector, loc_vec . for each elem in elements loc_vec = 0.0 for each pt in quadrature_points for each v_i in elem loc_vec(i) += w(pt) * rhs(pt) v_i(pt) end end glb_vec += loc_vec end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$ Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$ Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$ The LinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the LinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None Notation: $$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$ $$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$ For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Scalar Field Operators Domain Integrators Class Name Space Operator Continuous Op. Dimension DomainLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D DomainLFGradIntegrator H1 $(\\vec{f}, \\nabla v)$ $-\\nabla \\cdot \\vec{f}$ 1D, 2D, 3D Boundary Integrators Class Name Space Operator Continuous Op. Dimension BoundaryLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D BoundaryNormalLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{n}, v)$ $\\vec{f} \\cdot \\vec{n}$ 1D, 2D, 3D BoundaryTangentialLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{\\tau}, v)$ $\\vec{f} \\cdot \\vec{\\tau}$ 2D BoundaryFlowIntegrator H1, L2 $\\frac{\\alpha}{2}\\, \\left< (\\vec{u} \\cdot \\vec{n})\\, f, v \\right> - \\beta\\, \\left<\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right>$ $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$ 1D, 2D, 3D Face Integrators Class Name Space Operator Continuous Op. Dimension DGDirichletLFIntegrator L2 $\\sigma \\left< u_D, Q \\nabla v \\cdot \\vec{n} \\right> + \\kappa \\left< \\{h^{-1} Q\\} u_D, v \\right>$ DG essential BCs for $u_D$ 1D, 2D, 3D Vector Field Operators Domain Integrators Class Name Space Operator Continuous Op. Dimension VectorDomainLFIntegrator H1, L2 $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 1D, 2D, 3D VectorFEDomainLFIntegrator ND, RT $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 2D, 3D VectorFEDomainLFCurlIntegrator ND $(\\vec{f}, \\nabla \\times \\vec{v})$ $\\nabla \\times \\vec{f}$ 2D, 3D VectorFEDomainLFDivIntegrator RT $(f, \\nabla \\cdot \\vec{v})$ $ - \\nabla f$ 2D, 3D Boundary Integrators Class Name Space Operator Continuous Op. Dimension VectorBoundaryLFIntegrator H1, L2 $( \\vec{f}, \\vec{v} )$ $\\vec{f}$ 1D, 2D, 3D VectorBoundaryFluxLFIntegrator H1, L2 $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 1D, 2D, 3D VectorFEBoundaryFluxLFIntegrator RT $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 2D, 3D VectorFEBoundaryTangentLFIntegrator ND $( \\vec{n} \\times \\vec{f}, \\vec{v} )$ $\\vec{n} \\times \\vec{f}$ 2D, 3D Face Integrators Class Name Space Operator Continuous Op. Dimension DGElasticityDirichletLFIntegrator L2 $\\alpha\\left<\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right> \\\\ + \\kappa\\left< h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right>$ DG essential BCs for $\\vec{u_D}$ 1D, 2D, 3D MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Linear Form Integrators"},{"location":"lininteg/#linear-form-integrators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Linear form integrators are the right-hand side companion to Bilinear Form Integrators that compute the integrals of products of a basis function and a given \"right-hand side\" function (coefficient) $\\,f$ over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions, therefore linear integrators simultaneously compute the integrals of all combinations of the relevant basis functions with the given input function $\\,f$. This produces a one dimensional array of results that is arranged into a small vector of integral (dual) values called a local element (load) vector . To put this another way, the LinearForm class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet whereas the LinearFormIntegrator class performs the nested inner loops to compute the local vector, loc_vec . for each elem in elements loc_vec = 0.0 for each pt in quadrature_points for each v_i in elem loc_vec(i) += w(pt) * rhs(pt) v_i(pt) end end glb_vec += loc_vec end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$ Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$ Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$ The LinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the LinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None Notation: $$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$ $$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$ For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$.","title":"Linear Form Integrators"},{"location":"lininteg/#scalar-field-operators","text":"","title":"Scalar Field Operators"},{"location":"lininteg/#domain-integrators","text":"Class Name Space Operator Continuous Op. Dimension DomainLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D DomainLFGradIntegrator H1 $(\\vec{f}, \\nabla v)$ $-\\nabla \\cdot \\vec{f}$ 1D, 2D, 3D","title":"Domain Integrators"},{"location":"lininteg/#boundary-integrators","text":"Class Name Space Operator Continuous Op. Dimension BoundaryLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D BoundaryNormalLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{n}, v)$ $\\vec{f} \\cdot \\vec{n}$ 1D, 2D, 3D BoundaryTangentialLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{\\tau}, v)$ $\\vec{f} \\cdot \\vec{\\tau}$ 2D BoundaryFlowIntegrator H1, L2 $\\frac{\\alpha}{2}\\, \\left< (\\vec{u} \\cdot \\vec{n})\\, f, v \\right> - \\beta\\, \\left<\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right>$ $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$ 1D, 2D, 3D","title":"Boundary Integrators"},{"location":"lininteg/#face-integrators","text":"Class Name Space Operator Continuous Op. Dimension DGDirichletLFIntegrator L2 $\\sigma \\left< u_D, Q \\nabla v \\cdot \\vec{n} \\right> + \\kappa \\left< \\{h^{-1} Q\\} u_D, v \\right>$ DG essential BCs for $u_D$ 1D, 2D, 3D","title":"Face Integrators"},{"location":"lininteg/#vector-field-operators","text":"","title":"Vector Field Operators"},{"location":"lininteg/#domain-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension VectorDomainLFIntegrator H1, L2 $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 1D, 2D, 3D VectorFEDomainLFIntegrator ND, RT $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 2D, 3D VectorFEDomainLFCurlIntegrator ND $(\\vec{f}, \\nabla \\times \\vec{v})$ $\\nabla \\times \\vec{f}$ 2D, 3D VectorFEDomainLFDivIntegrator RT $(f, \\nabla \\cdot \\vec{v})$ $ - \\nabla f$ 2D, 3D","title":"Domain Integrators"},{"location":"lininteg/#boundary-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension VectorBoundaryLFIntegrator H1, L2 $( \\vec{f}, \\vec{v} )$ $\\vec{f}$ 1D, 2D, 3D VectorBoundaryFluxLFIntegrator H1, L2 $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 1D, 2D, 3D VectorFEBoundaryFluxLFIntegrator RT $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 2D, 3D VectorFEBoundaryTangentLFIntegrator ND $( \\vec{n} \\times \\vec{f}, \\vec{v} )$ $\\vec{n} \\times \\vec{f}$ 2D, 3D","title":"Boundary Integrators"},{"location":"lininteg/#face-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension DGElasticityDirichletLFIntegrator L2 $\\alpha\\left<\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right> \\\\ + \\kappa\\left< h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right>$ DG essential BCs for $\\vec{u_D}$ 1D, 2D, 3D MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Face Integrators"},{"location":"lininterp/","text":"Linear Interpolators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Linear interpolators can be very useful for interpolating one discrete representation of a field onto another set of basis functions to produce another representation. However, this must be done with care because different discrete representations are not completely interchangeable. As an example consider a scalar field projected onto either piece-wise linear ($H_1$) or piece-wise constant ($L_2$) basis functions. Interpolating from an $H_1$ representation to an $L_2$ representation should produce a reasonable result because the constant value needed in each element can be computed as a weighted sum of the $H_1$ basis functions in that element. On the other hand, if we try to interpolate from the $L_2$ representation to an $H_1$ representation we don't have enough information to determine reasonable values for the degrees of freedom which are shared between neighboring elements because linear interpolators can only access one element at a time. To accurately compute an $H_1$ representation from an $L_2$ representation requires the type of weighted average of values from neighboring elements that bilinear forms provide but this requires a linear solve and often suitable boundary conditions. The operators produced by the BilinearForm classes involve integrations and therefore they sum the various contributions from neighboring elements to compute a full integral. The DiscreteLinearOperator classes are not performing integrals but rather interpolations and as such they do not combine contributions from different elements in any way. Consequently if the LinearInterpolator s produce different results for entities that are shared between neighboring elements then the resulting representation will depend on the order in which the elements are processed. Such operators are not good candidates for DiscreteLinearOperator s. The sections below will offer some guidance on the appropriate use of these operators. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function Derivative Interpolators The $H(Curl)$ and $H(Div)$ spaces are specifically designed to support these derivative operators by having the necessary inter-element continuity. Other possible derivative operators would not possess the correct continuity and must therefore be implemented in a weak sense. Class Name Domain Range Operator GradientInterpolator H1 ND $\\grad u$ CurlInterpolator ND in 3D RT $\\curl\\vec{u}$ CurlInterpolator ND in 2D L2 $\\hat{z}\\cdot(\\curl\\vec{u})$ DivergenceInterpolator RT L2 $\\div\\vec{u}$ Product Interpolators These operators require a bit more care than the previous set. In order for these operators to produce valid results the product of the coefficient with the domain space must be uniquely representable within the desired range space. Additionally, it may sometimes be desirable for the range space to have a higher order than the domain space if the coefficient is not constant. For example if the domain space and the coefficient are both linear it might be desirable, though not necessary, for the range space to be quadratic. Class Name Domain Range Coef. Operator ScalarProductInterpolator H1,L2 H1,L2 S $\\lambda u$ ScalarVectorProductInterpolator ND,RT ND,RT S $\\lambda\\vec{u}$ VectorScalarProductInterpolator H1,L2 ND,RT V $\\vec{\\lambda}u$ VectorCrossProductInterpolator ND,RT in 3D ND,RT V $\\vec{\\lambda}\\times\\vec{u}$ ScalarCrossProductInterpolator ND,RT in 2D H1,L2 V $\\hat{z}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ VectorInnerProductInterpolator ND,RT H1,L2 V $\\vec{\\lambda}\\cdot\\vec{u}$ Special Purpose Interpolators Class Name Domain Range Operator IdentityInterpolator H1,L2 H1,L2 $u$ NormalInterpolator H1$^d$ RT_Trace $\\hat{n}\\cdot\\vec{u}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Linear Interpolators"},{"location":"lininterp/#linear-interpolators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Linear interpolators can be very useful for interpolating one discrete representation of a field onto another set of basis functions to produce another representation. However, this must be done with care because different discrete representations are not completely interchangeable. As an example consider a scalar field projected onto either piece-wise linear ($H_1$) or piece-wise constant ($L_2$) basis functions. Interpolating from an $H_1$ representation to an $L_2$ representation should produce a reasonable result because the constant value needed in each element can be computed as a weighted sum of the $H_1$ basis functions in that element. On the other hand, if we try to interpolate from the $L_2$ representation to an $H_1$ representation we don't have enough information to determine reasonable values for the degrees of freedom which are shared between neighboring elements because linear interpolators can only access one element at a time. To accurately compute an $H_1$ representation from an $L_2$ representation requires the type of weighted average of values from neighboring elements that bilinear forms provide but this requires a linear solve and often suitable boundary conditions. The operators produced by the BilinearForm classes involve integrations and therefore they sum the various contributions from neighboring elements to compute a full integral. The DiscreteLinearOperator classes are not performing integrals but rather interpolations and as such they do not combine contributions from different elements in any way. Consequently if the LinearInterpolator s produce different results for entities that are shared between neighboring elements then the resulting representation will depend on the order in which the elements are processed. Such operators are not good candidates for DiscreteLinearOperator s. The sections below will offer some guidance on the appropriate use of these operators. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function","title":"Linear Interpolators"},{"location":"lininterp/#derivative-interpolators","text":"The $H(Curl)$ and $H(Div)$ spaces are specifically designed to support these derivative operators by having the necessary inter-element continuity. Other possible derivative operators would not possess the correct continuity and must therefore be implemented in a weak sense. Class Name Domain Range Operator GradientInterpolator H1 ND $\\grad u$ CurlInterpolator ND in 3D RT $\\curl\\vec{u}$ CurlInterpolator ND in 2D L2 $\\hat{z}\\cdot(\\curl\\vec{u})$ DivergenceInterpolator RT L2 $\\div\\vec{u}$","title":"Derivative Interpolators"},{"location":"lininterp/#product-interpolators","text":"These operators require a bit more care than the previous set. In order for these operators to produce valid results the product of the coefficient with the domain space must be uniquely representable within the desired range space. Additionally, it may sometimes be desirable for the range space to have a higher order than the domain space if the coefficient is not constant. For example if the domain space and the coefficient are both linear it might be desirable, though not necessary, for the range space to be quadratic. Class Name Domain Range Coef. Operator ScalarProductInterpolator H1,L2 H1,L2 S $\\lambda u$ ScalarVectorProductInterpolator ND,RT ND,RT S $\\lambda\\vec{u}$ VectorScalarProductInterpolator H1,L2 ND,RT V $\\vec{\\lambda}u$ VectorCrossProductInterpolator ND,RT in 3D ND,RT V $\\vec{\\lambda}\\times\\vec{u}$ ScalarCrossProductInterpolator ND,RT in 2D H1,L2 V $\\hat{z}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ VectorInnerProductInterpolator ND,RT H1,L2 V $\\vec{\\lambda}\\cdot\\vec{u}$","title":"Product Interpolators"},{"location":"lininterp/#special-purpose-interpolators","text":"Class Name Domain Range Operator IdentityInterpolator H1,L2 H1,L2 $u$ NormalInterpolator H1$^d$ RT_Trace $\\hat{n}\\cdot\\vec{u}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Special Purpose Interpolators"},{"location":"mesh-format-v1.x/","text":"General MFEM Mesh Format The MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the nodes of the mesh. For simplicity, in this document we refer to this version of the format as MFEM mesh v1.x . The legacy version for meshes with straight edges we will call MFEM linear mesh format. A mesh in the MFEM mesh v1.x format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the beam-quad.mesh from MFEM's data/ directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments: The original linear mesh version of this file is given in Listing 1 . Topology The topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the vertices are just labels used to imply which elements share a vertex, an edge or a face. Some examples: General version of data/beam-quad.mesh Below is the annotated topological part of the MFEM mesh v1.x format for the beam mesh. The complete file is given in Listing 2 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary # Skipping the 18 boundary segments for simplicity vertices 18 # END Topology Part ... The element format above is: <attribute> <type> <vertex1> ... <vertexN> . Type 3 is quadrilateral, which requires 4 vertex indices. The attribute identify e.g. material sub-domains (2 in this case). NOTE: The topology part of this mesh will be the same, irrespective of the order. Compare e.g. Listing 2 , Listing 3 and Listing 4 . WARNING: The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh nodes not vertices . In particular, while the Mesh object can return vertex coordinates, they are not used an may be incorrect for high-order mesh. Periodic version of data/beam-quad.mesh The topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a cylinder. The complete file is given in Listing 5 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 # Last element uses vertices 0 and 9 # two vertical boundary have been removed boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 18 # END Topology Part ... Compared to the non-periodic version, e.g. Listing 2 , the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9. The difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh. In the periodic case we get: while the solution on the non-periodic mesh looks like: NOTE: Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh. Geometry The geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh nodes as a general finite element (vector) function. In MFEM, finite element functions are objects of type GridFunction which belong to discrete finite element spaces specified by objects FiniteElementSpace and FiniteElementCollection . The actual geometry of each element is obtained by extracting the local degrees of freedom from the global nodes , expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element. An example of a first order geometry is given in Listing 2 : ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # END Geometry Part Here VDim: 2 means that the nodes grid function is a vector field with two components (i.e. the mesh is embedded in R^2); H1_2D_P1 describes the finite element space (H1/continuous finite elements in 2D of order 1); Ordering refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates. Compare the above with the linear mesh vertex coordinates from Listing 1 : vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 In the MFEM mesh v1.x format, the nodes are a regular grid function, just like an other discretized field in a simulation, which has several advantages: The nodes can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation. Mesh optimization problems can be posed directly for the nodes variable. Since the nodes can be any finite element function, a wide variety of meshes are easily supported. As an illustration of the last point, consider the geometry of the periodic version of the mesh in Listing 5 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1 # END Geometry Part ... Note that the space here is L2 , which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions. Finite Element Spaces To fully specify the MFEM mesh v1.x format, we need to describe the degrees of freedom of the nodes finite element space and their global numbering. This is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach... Finite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements. There may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom. For example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points. These are just examples, many choices for the basis are actually possible to be encoded in the FiniteElementCollection string above. In general, based just on the mesh topology and the type of the space, the FiniteElementSpace object can determine a global set of dofs, that will be the values listed for the mesh nodes . The algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows: loop over elements loop over edges and faces inside each element (clock-wise) number currently the edges and faces that have not been numbered yet Here is the result of this numbering for the beam mesh In addition to a number, each edges and face is also given a global orientation. In 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id. In 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the fem/geom.cpp for the definitions of the tetrahedral and hexahedral mappings on the reference element, as well as the Mesh::GenerateFaces method in mesh/mesh.cpp . In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e. orientation here means permutation of vertices. The global numbering of degrees of freedom is now performed as follows: loop over vertices list the dofs associated with each vertex loop over edges list the dofs associated with the interior of the edge, lexicographically with respect to the edge orientation loop over faces list the dofs associated with the interior of the face, lexicographically with respect to the face orientation loop over elements list the dofs associated with the interior of the element An example of this is the quadratic mesh in Listing 3 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 # 18 vertex dofs 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # 25 edge dofs 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 # 8 element dofs 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 # END Geometry Part ... Listings Listing 1 This is the original version of the beam-quad.mesh using the linear mesh format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 Listing 2 This is a MFEM mesh v1.x version of the beam-quad.mesh which is first order. The mesh is identical to the one of Listing 1 , it is just described in a different format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 Listing 3 This is a second order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 Listing 4 This is a third order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P3 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.27639320225002 0 0.72360679774998 0 1 0.27639320225002 1 0.72360679774998 0.27639320225002 1 0.72360679774998 1 0 0.27639320225002 0 0.72360679774998 1.27639320225 0 1.72360679775 0 2 0.27639320225002 2 0.72360679774998 1.27639320225 1 1.72360679775 1 2.27639320225 0 2.72360679775 0 3 0.27639320225002 3 0.72360679774998 2.27639320225 1 2.72360679775 1 3.27639320225 0 3.72360679775 0 4 0.27639320225002 4 0.72360679774998 3.27639320225 1 3.72360679775 1 4.27639320225 0 4.72360679775 0 5 0.27639320225002 5 0.72360679774998 4.27639320225 1 4.72360679775 1 5.27639320225 0 5.72360679775 0 6 0.27639320225002 6 0.72360679774998 5.27639320225 1 5.72360679775 1 6.27639320225 0 6.72360679775 0 7 0.27639320225002 7 0.72360679774998 6.27639320225 1 6.72360679775 1 7.27639320225 0 7.72360679775 0 8 0.27639320225002 8 0.72360679774998 7.27639320225 1 7.72360679775 1 0.27639320225002 0.27639320225002 0.72360679774998 0.27639320225002 0.27639320225002 0.72360679774998 0.72360679774998 0.72360679774998 1.27639320225 0.27639320225002 1.72360679775 0.27639320225002 1.27639320225 0.72360679774998 1.72360679775 0.72360679774998 2.27639320225 0.27639320225002 2.72360679775 0.27639320225002 2.27639320225 0.72360679774998 2.72360679775 0.72360679774998 3.27639320225 0.27639320225002 3.72360679775 0.27639320225002 3.27639320225 0.72360679774998 3.72360679775 0.72360679774998 4.27639320225 0.27639320225002 4.72360679775 0.27639320225002 4.27639320225 0.72360679774998 4.72360679775 0.72360679774998 5.27639320225 0.27639320225002 5.72360679775 0.27639320225002 5.27639320225 0.72360679774998 5.72360679775 0.72360679774998 6.27639320225 0.27639320225002 6.72360679775 0.27639320225002 6.27639320225 0.72360679774998 6.72360679775 0.72360679774998 7.27639320225 0.27639320225002 7.72360679775 0.27639320225002 7.27639320225 0.72360679774998 7.72360679775 0.72360679774998 Listing 5 Periodic version of the first-order mesh from Listing 1 . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 18 nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1","title":"_Mesh Format v1.x"},{"location":"mesh-format-v1.x/#general-mfem-mesh-format","text":"The MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the nodes of the mesh. For simplicity, in this document we refer to this version of the format as MFEM mesh v1.x . The legacy version for meshes with straight edges we will call MFEM linear mesh format. A mesh in the MFEM mesh v1.x format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the beam-quad.mesh from MFEM's data/ directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments: The original linear mesh version of this file is given in Listing 1 .","title":"General MFEM Mesh Format"},{"location":"mesh-format-v1.x/#topology","text":"The topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the vertices are just labels used to imply which elements share a vertex, an edge or a face. Some examples:","title":"Topology"},{"location":"mesh-format-v1.x/#general-version-of-databeam-quadmesh","text":"Below is the annotated topological part of the MFEM mesh v1.x format for the beam mesh. The complete file is given in Listing 2 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary # Skipping the 18 boundary segments for simplicity vertices 18 # END Topology Part ... The element format above is: <attribute> <type> <vertex1> ... <vertexN> . Type 3 is quadrilateral, which requires 4 vertex indices. The attribute identify e.g. material sub-domains (2 in this case). NOTE: The topology part of this mesh will be the same, irrespective of the order. Compare e.g. Listing 2 , Listing 3 and Listing 4 . WARNING: The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh nodes not vertices . In particular, while the Mesh object can return vertex coordinates, they are not used an may be incorrect for high-order mesh.","title":"General version of data/beam-quad.mesh"},{"location":"mesh-format-v1.x/#periodic-version-of-databeam-quadmesh","text":"The topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a cylinder. The complete file is given in Listing 5 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 # Last element uses vertices 0 and 9 # two vertical boundary have been removed boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 18 # END Topology Part ... Compared to the non-periodic version, e.g. Listing 2 , the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9. The difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh. In the periodic case we get: while the solution on the non-periodic mesh looks like: NOTE: Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh.","title":"Periodic version of data/beam-quad.mesh"},{"location":"mesh-format-v1.x/#geometry","text":"The geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh nodes as a general finite element (vector) function. In MFEM, finite element functions are objects of type GridFunction which belong to discrete finite element spaces specified by objects FiniteElementSpace and FiniteElementCollection . The actual geometry of each element is obtained by extracting the local degrees of freedom from the global nodes , expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element. An example of a first order geometry is given in Listing 2 : ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # END Geometry Part Here VDim: 2 means that the nodes grid function is a vector field with two components (i.e. the mesh is embedded in R^2); H1_2D_P1 describes the finite element space (H1/continuous finite elements in 2D of order 1); Ordering refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates. Compare the above with the linear mesh vertex coordinates from Listing 1 : vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 In the MFEM mesh v1.x format, the nodes are a regular grid function, just like an other discretized field in a simulation, which has several advantages: The nodes can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation. Mesh optimization problems can be posed directly for the nodes variable. Since the nodes can be any finite element function, a wide variety of meshes are easily supported. As an illustration of the last point, consider the geometry of the periodic version of the mesh in Listing 5 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1 # END Geometry Part ... Note that the space here is L2 , which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions.","title":"Geometry"},{"location":"mesh-format-v1.x/#finite-element-spaces","text":"To fully specify the MFEM mesh v1.x format, we need to describe the degrees of freedom of the nodes finite element space and their global numbering. This is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach... Finite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements. There may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom. For example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points. These are just examples, many choices for the basis are actually possible to be encoded in the FiniteElementCollection string above. In general, based just on the mesh topology and the type of the space, the FiniteElementSpace object can determine a global set of dofs, that will be the values listed for the mesh nodes . The algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows: loop over elements loop over edges and faces inside each element (clock-wise) number currently the edges and faces that have not been numbered yet Here is the result of this numbering for the beam mesh In addition to a number, each edges and face is also given a global orientation. In 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id. In 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the fem/geom.cpp for the definitions of the tetrahedral and hexahedral mappings on the reference element, as well as the Mesh::GenerateFaces method in mesh/mesh.cpp . In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e. orientation here means permutation of vertices. The global numbering of degrees of freedom is now performed as follows: loop over vertices list the dofs associated with each vertex loop over edges list the dofs associated with the interior of the edge, lexicographically with respect to the edge orientation loop over faces list the dofs associated with the interior of the face, lexicographically with respect to the face orientation loop over elements list the dofs associated with the interior of the element An example of this is the quadratic mesh in Listing 3 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 # 18 vertex dofs 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # 25 edge dofs 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 # 8 element dofs 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 # END Geometry Part ...","title":"Finite Element Spaces"},{"location":"mesh-format-v1.x/#listings","text":"","title":"Listings"},{"location":"mesh-format-v1.x/#listing-1","text":"This is the original version of the beam-quad.mesh using the linear mesh format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1","title":"Listing 1"},{"location":"mesh-format-v1.x/#listing-2","text":"This is a MFEM mesh v1.x version of the beam-quad.mesh which is first order. The mesh is identical to the one of Listing 1 , it is just described in a different format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1","title":"Listing 2"},{"location":"mesh-format-v1.x/#listing-3","text":"This is a second order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5","title":"Listing 3"},{"location":"mesh-format-v1.x/#listing-4","text":"This is a third order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P3 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.27639320225002 0 0.72360679774998 0 1 0.27639320225002 1 0.72360679774998 0.27639320225002 1 0.72360679774998 1 0 0.27639320225002 0 0.72360679774998 1.27639320225 0 1.72360679775 0 2 0.27639320225002 2 0.72360679774998 1.27639320225 1 1.72360679775 1 2.27639320225 0 2.72360679775 0 3 0.27639320225002 3 0.72360679774998 2.27639320225 1 2.72360679775 1 3.27639320225 0 3.72360679775 0 4 0.27639320225002 4 0.72360679774998 3.27639320225 1 3.72360679775 1 4.27639320225 0 4.72360679775 0 5 0.27639320225002 5 0.72360679774998 4.27639320225 1 4.72360679775 1 5.27639320225 0 5.72360679775 0 6 0.27639320225002 6 0.72360679774998 5.27639320225 1 5.72360679775 1 6.27639320225 0 6.72360679775 0 7 0.27639320225002 7 0.72360679774998 6.27639320225 1 6.72360679775 1 7.27639320225 0 7.72360679775 0 8 0.27639320225002 8 0.72360679774998 7.27639320225 1 7.72360679775 1 0.27639320225002 0.27639320225002 0.72360679774998 0.27639320225002 0.27639320225002 0.72360679774998 0.72360679774998 0.72360679774998 1.27639320225 0.27639320225002 1.72360679775 0.27639320225002 1.27639320225 0.72360679774998 1.72360679775 0.72360679774998 2.27639320225 0.27639320225002 2.72360679775 0.27639320225002 2.27639320225 0.72360679774998 2.72360679775 0.72360679774998 3.27639320225 0.27639320225002 3.72360679775 0.27639320225002 3.27639320225 0.72360679774998 3.72360679775 0.72360679774998 4.27639320225 0.27639320225002 4.72360679775 0.27639320225002 4.27639320225 0.72360679774998 4.72360679775 0.72360679774998 5.27639320225 0.27639320225002 5.72360679775 0.27639320225002 5.27639320225 0.72360679774998 5.72360679775 0.72360679774998 6.27639320225 0.27639320225002 6.72360679775 0.27639320225002 6.27639320225 0.72360679774998 6.72360679775 0.72360679774998 7.27639320225 0.27639320225002 7.72360679775 0.27639320225002 7.27639320225 0.72360679774998 7.72360679775 0.72360679774998","title":"Listing 4"},{"location":"mesh-format-v1.x/#listing-5","text":"Periodic version of the first-order mesh from Listing 1 . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 18 nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1","title":"Listing 5"},{"location":"mesh-formats/","text":"Mesh Formats MFEM mesh v1.0 This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes. Straight meshes In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 PRISM = 6 see the comments in this source file for more details. For example, the beam-quad.mesh file from the data directory looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\" Curvilinear and more general meshes The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the General Mesh Format page . MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaoooooooooo**************tt\" we get: Topologically periodic meshes can also be described in this format, see for example the periodic-segment , periodic-square , and periodic-cube meshes in the data directory, as well as Example 9 . MFEM NC mesh v1.0 The MFEM NC mesh v1.0 is a format for nonconfoming meshes in MFEM. It is similar in style to the default (conforming) MFEM mesh v1.0 format, but is in fact independent and supports advanced AMR features such as storing refined elements and the refinement hierarchy, anisotropic element refinement, hanging nodes (vertices), parallel partitioning. The file starts with a signature and the mesh dimension: MFEM NC mesh v1.0 # NCMesh supported geometry types: # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # PRISM = 6 # mesh dimension 1, 2 or 3 dimension <dimension> # optional rank for parallel files, defaults to 0 rank <MPI rank> The rank section defines the MPI rank of the process that saved the file. This section can be omitted in serial meshes. Similarly to the conforming format, the next section lists all elements. This time however, we recognize two kinds of elements: Regular, active elements ( refinement type == 0 ). These elements participate in the computation (are listed in the Mesh class) and reference vertex indices. Inactive, previously refined elements ( refinement type > 0 ). Instead of vertices, these elements contain links to their child elements, and are not visible in the Mesh class. All elements also have their geometry type and user attribute defined, as well as the MPI rank of their owner process (only used in parallel meshes). # mesh elements, both regular and refined elements <number of elements> <owner rank> <attribute> <geometry type> 0 <vertex indices> <owner rank> <attribute> <geometry type> <refinement type> <child indices> ... Storing the complete refinement hierarchy allows MFEM to coarsen some of the fine elements if necessary, and also to naturally define an ordering of the fine elements that can be used for fast parallel partitioning of the mesh (a depth-first traversal of all refinement trees defines a space-filling curve (SFC) that can be easily partitioned among parallel processes). The following picture illustrates the refinement hierarchy of a mesh that started as two quadrilaterals and then underwent two anisotropic refinements (blue numbers are vertex indices): The corresponding elements section of the mesh file could look like this: elements 6 0 1 3 2 2 3 # element 0: refinement 2 (Y), children 2, 3 0 1 3 0 1 2 5 4 # element 1: no refinement, vertices 1, 2, 5, 4 0 1 3 1 4 5 # element 2: refinement 1 (X), children 4, 5 0 1 3 0 6 7 4 3 # element 3: no refinement, vertices 6, 7, 4, 3 0 1 3 0 0 8 9 6 # element 4: no refinement, vertices 0, 8, 9, 6 0 1 3 0 8 1 7 9 # element 5: no refinement, vertices 8, 1, 7, 9 The refinement types are numbered as follows: Note that the type is encoded as a 3-bit number, where bits 0, 1, 2 correspond to the X, Y, Z axes, respectively. Other element geometries allow fewer but similar refinement types: triangle (3), square (1, 2, 3), tetrahedron (7), prism (3, 4, 7). The next section is the boundary section, which is exactly the same as in the conforming format: boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex indices> ... The nonconfoming mesh however needs to identify hanging vertices, which may occur in the middle of edges or faces as elements are refined. A hanging vertex always has two \"parent\" vertices. vertex_parents <number of records> <vertex number> <parent 1 number> <parent 2 number> ... In our example above, vertices 6, 7, 8, 9 are hanging vertices, so the vertex_parents section would look like this: vertex_parents 4 6 0 3 7 1 4 8 0 1 9 6 7 The hanging vertices can appear in any order in this section. The only limitation is that the first N vertex indices (not listed in this section) be reserved for the top-level vertices (those with no parents, typically the vertices of the coarse mesh). The next section is optional and can be safely omitted when creating the mesh file manually. The root_state section affects leaf ordering when traversing the refinement trees and is used to optimize the SFC-based partitioning. There is one number per root element. The default state for all root elements is zero. root_state <number of records> <root element state> ... Finally, we have the coordinates section which assigns physical positions to the N top-level vertices. Note that the positions of hanging vertices are always derived from their parent vertices and are not listed in the mesh file. coordinates <number of top-level vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... If the mesh is curvilinear, the coordinates section can be replaced with an alternative section called nodes . The nodes keyword is then followed by a serialized GridFunction representing a vector-valued finite element function defining the curvature of the elements, similarly as in the conforming case. The end of the mesh file is marked with the line mfem_mesh_end . For examples of meshes using the NC mesh v1.0 format, see amr-quad.mesh , amr-hex.mesh and fichera-amr.mesh (visualized below) in the data directory of MFEM. NURBS meshes MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after several refinements with the \" i \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Some examples of VTK meshes can be found in MFEM's data directory . Here is one of the 3D NURBS meshes The image above was produced with some refinement (key \" o \") and mouse manipulations from glvis -m pipe-nurbs.mesh Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf Curvilinear VTK meshes MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get: The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g., glvis -m quad.vtk -k \"AemIIiii\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" MFEM and GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaooooo******\"","title":"_Mesh Formats"},{"location":"mesh-formats/#mesh-formats","text":"","title":"Mesh Formats"},{"location":"mesh-formats/#mfem-mesh-v10","text":"This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.","title":"MFEM mesh v1.0"},{"location":"mesh-formats/#straight-meshes","text":"In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 PRISM = 6 see the comments in this source file for more details. For example, the beam-quad.mesh file from the data directory looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\"","title":"Straight meshes"},{"location":"mesh-formats/#curvilinear-and-more-general-meshes","text":"The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the General Mesh Format page . MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaoooooooooo**************tt\" we get: Topologically periodic meshes can also be described in this format, see for example the periodic-segment , periodic-square , and periodic-cube meshes in the data directory, as well as Example 9 .","title":"Curvilinear and more general meshes"},{"location":"mesh-formats/#mfem-nc-mesh-v10","text":"The MFEM NC mesh v1.0 is a format for nonconfoming meshes in MFEM. It is similar in style to the default (conforming) MFEM mesh v1.0 format, but is in fact independent and supports advanced AMR features such as storing refined elements and the refinement hierarchy, anisotropic element refinement, hanging nodes (vertices), parallel partitioning. The file starts with a signature and the mesh dimension: MFEM NC mesh v1.0 # NCMesh supported geometry types: # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # PRISM = 6 # mesh dimension 1, 2 or 3 dimension <dimension> # optional rank for parallel files, defaults to 0 rank <MPI rank> The rank section defines the MPI rank of the process that saved the file. This section can be omitted in serial meshes. Similarly to the conforming format, the next section lists all elements. This time however, we recognize two kinds of elements: Regular, active elements ( refinement type == 0 ). These elements participate in the computation (are listed in the Mesh class) and reference vertex indices. Inactive, previously refined elements ( refinement type > 0 ). Instead of vertices, these elements contain links to their child elements, and are not visible in the Mesh class. All elements also have their geometry type and user attribute defined, as well as the MPI rank of their owner process (only used in parallel meshes). # mesh elements, both regular and refined elements <number of elements> <owner rank> <attribute> <geometry type> 0 <vertex indices> <owner rank> <attribute> <geometry type> <refinement type> <child indices> ... Storing the complete refinement hierarchy allows MFEM to coarsen some of the fine elements if necessary, and also to naturally define an ordering of the fine elements that can be used for fast parallel partitioning of the mesh (a depth-first traversal of all refinement trees defines a space-filling curve (SFC) that can be easily partitioned among parallel processes). The following picture illustrates the refinement hierarchy of a mesh that started as two quadrilaterals and then underwent two anisotropic refinements (blue numbers are vertex indices): The corresponding elements section of the mesh file could look like this: elements 6 0 1 3 2 2 3 # element 0: refinement 2 (Y), children 2, 3 0 1 3 0 1 2 5 4 # element 1: no refinement, vertices 1, 2, 5, 4 0 1 3 1 4 5 # element 2: refinement 1 (X), children 4, 5 0 1 3 0 6 7 4 3 # element 3: no refinement, vertices 6, 7, 4, 3 0 1 3 0 0 8 9 6 # element 4: no refinement, vertices 0, 8, 9, 6 0 1 3 0 8 1 7 9 # element 5: no refinement, vertices 8, 1, 7, 9 The refinement types are numbered as follows: Note that the type is encoded as a 3-bit number, where bits 0, 1, 2 correspond to the X, Y, Z axes, respectively. Other element geometries allow fewer but similar refinement types: triangle (3), square (1, 2, 3), tetrahedron (7), prism (3, 4, 7). The next section is the boundary section, which is exactly the same as in the conforming format: boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex indices> ... The nonconfoming mesh however needs to identify hanging vertices, which may occur in the middle of edges or faces as elements are refined. A hanging vertex always has two \"parent\" vertices. vertex_parents <number of records> <vertex number> <parent 1 number> <parent 2 number> ... In our example above, vertices 6, 7, 8, 9 are hanging vertices, so the vertex_parents section would look like this: vertex_parents 4 6 0 3 7 1 4 8 0 1 9 6 7 The hanging vertices can appear in any order in this section. The only limitation is that the first N vertex indices (not listed in this section) be reserved for the top-level vertices (those with no parents, typically the vertices of the coarse mesh). The next section is optional and can be safely omitted when creating the mesh file manually. The root_state section affects leaf ordering when traversing the refinement trees and is used to optimize the SFC-based partitioning. There is one number per root element. The default state for all root elements is zero. root_state <number of records> <root element state> ... Finally, we have the coordinates section which assigns physical positions to the N top-level vertices. Note that the positions of hanging vertices are always derived from their parent vertices and are not listed in the mesh file. coordinates <number of top-level vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... If the mesh is curvilinear, the coordinates section can be replaced with an alternative section called nodes . The nodes keyword is then followed by a serialized GridFunction representing a vector-valued finite element function defining the curvature of the elements, similarly as in the conforming case. The end of the mesh file is marked with the line mfem_mesh_end . For examples of meshes using the NC mesh v1.0 format, see amr-quad.mesh , amr-hex.mesh and fichera-amr.mesh (visualized below) in the data directory of MFEM.","title":"MFEM NC mesh v1.0"},{"location":"mesh-formats/#nurbs-meshes","text":"MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after several refinements with the \" i \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Some examples of VTK meshes can be found in MFEM's data directory . Here is one of the 3D NURBS meshes The image above was produced with some refinement (key \" o \") and mouse manipulations from glvis -m pipe-nurbs.mesh Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf","title":"NURBS meshes"},{"location":"mesh-formats/#curvilinear-vtk-meshes","text":"MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get: The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g., glvis -m quad.vtk -k \"AemIIiii\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" MFEM and GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaooooo******\"","title":"Curvilinear VTK meshes"},{"location":"meshing/","text":"Meshing This page provides a brief description of MFEM's mesh formats and meshing mini applications. Mesh formats MFEM supports a number of mesh formats, including: MFEM's mesh v1.0 format for straight meshes, MFEM's mesh v1.0 format for arbitrary high-order curvilinear and more general meshes, MFEM's mesh v1.2 format, which adds support for parallel meshes, MFEM's NC mesh v1.0 format , supporting non-conforming (AMR) meshes, MFEM's format for NURBS meshes, The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes, The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats, The TrueGrid hexahedral mesh format. Detailed description of these formats can be found on the mesh formats page. These formats are also supported by MFEM's native visualization tool, GLVis . Meshing miniapps The miniapps/meshing directory contains a collection of meshing-related miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current meshing miniapps are described below. Mobius Strip This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. Klein Bottle This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. Toroid This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. A wide variety of toroidal meshes can be generated by varying the amount of twist as well as the major and minor radii and other variables. The toroid-wedge and toroid-hex meshes in the data directory were generated with this miniapp. Twist This miniapp generates simple periodic meshes made from different types of elements. A wide variety of twisted meshes can be generated by varying the amount of twist as well as the dimensions, element types, and other variables. Extruder This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and then in the z-direction. 2D meshes can be triangular, quadrilateral, or contain both element types. Polar-NC This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra: The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM. Shaper This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material() function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. Mesh Explorer This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality Mesh Optimizer This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. Minimal Surface This miniapp solves Plateau's nonlinear elliptic problem: the Dirichlet problem for the minimal surface equation. The weak form of the equation, with prescribed boundary conditions, is given by: $$\\int_\\Omega\\frac{\\nabla{u}\\cdot\\nabla{v}}{\\sqrt{1+|\\nabla{u}|^2}}dx = 0$$ Two problems can be run: Problem 0 solves the minimal surface equation of parametric surfaces . The command line options allow the selection of different parametrization: Catenoid, Helicoid, Enneper, Hold, Costa, Shell, Scherk or simply one from an input mesh file. Problem 1 solves the minimal surface equation for surfaces restricted to be graphs of the form $z=f(x,y)$ . This problem is solved using the Picard iterations: $$\\int_\\Omega\\frac{\\nabla{u_{n+1}}\\cdot\\nabla{v}}{\\sqrt{1+|\\nabla{u_n}|^2}}dx = 0$$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Meshing"},{"location":"meshing/#meshing","text":"This page provides a brief description of MFEM's mesh formats and meshing mini applications.","title":"Meshing"},{"location":"meshing/#mesh-formats","text":"MFEM supports a number of mesh formats, including: MFEM's mesh v1.0 format for straight meshes, MFEM's mesh v1.0 format for arbitrary high-order curvilinear and more general meshes, MFEM's mesh v1.2 format, which adds support for parallel meshes, MFEM's NC mesh v1.0 format , supporting non-conforming (AMR) meshes, MFEM's format for NURBS meshes, The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes, The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats, The TrueGrid hexahedral mesh format. Detailed description of these formats can be found on the mesh formats page. These formats are also supported by MFEM's native visualization tool, GLVis .","title":"Mesh formats"},{"location":"meshing/#meshing-miniapps","text":"The miniapps/meshing directory contains a collection of meshing-related miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current meshing miniapps are described below.","title":"Meshing miniapps"},{"location":"meshing/#mobius-strip","text":"This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp.","title":"Mobius Strip"},{"location":"meshing/#klein-bottle","text":"This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp.","title":"Klein Bottle"},{"location":"meshing/#toroid","text":"This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. A wide variety of toroidal meshes can be generated by varying the amount of twist as well as the major and minor radii and other variables. The toroid-wedge and toroid-hex meshes in the data directory were generated with this miniapp.","title":"Toroid"},{"location":"meshing/#twist","text":"This miniapp generates simple periodic meshes made from different types of elements. A wide variety of twisted meshes can be generated by varying the amount of twist as well as the dimensions, element types, and other variables.","title":"Twist"},{"location":"meshing/#extruder","text":"This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and then in the z-direction. 2D meshes can be triangular, quadrilateral, or contain both element types.","title":"Extruder"},{"location":"meshing/#polar-nc","text":"This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra: The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM.","title":"Polar-NC"},{"location":"meshing/#shaper","text":"This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material() function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported.","title":"Shaper"},{"location":"meshing/#mesh-explorer","text":"This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality","title":"Mesh Explorer"},{"location":"meshing/#mesh-optimizer","text":"This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets.","title":"Mesh Optimizer"},{"location":"meshing/#minimal-surface","text":"This miniapp solves Plateau's nonlinear elliptic problem: the Dirichlet problem for the minimal surface equation. The weak form of the equation, with prescribed boundary conditions, is given by: $$\\int_\\Omega\\frac{\\nabla{u}\\cdot\\nabla{v}}{\\sqrt{1+|\\nabla{u}|^2}}dx = 0$$ Two problems can be run: Problem 0 solves the minimal surface equation of parametric surfaces . The command line options allow the selection of different parametrization: Catenoid, Helicoid, Enneper, Hold, Costa, Shell, Scherk or simply one from an input mesh file. Problem 1 solves the minimal surface equation for surfaces restricted to be graphs of the form $z=f(x,y)$ . This problem is solved using the Picard iterations: $$\\int_\\Omega\\frac{\\nabla{u_{n+1}}\\cdot\\nabla{v}}{\\sqrt{1+|\\nabla{u_n}|^2}}dx = 0$$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Minimal Surface"},{"location":"news/","text":"All News Updates Apr 22, 2021 MFEM featured on S&TR magazine cover . Mar 1, 2021 Logo featured throughout LLNL 2020 annual report . Feb 16, 2021 New documentation page on GPU performance . Dec 19, 2020 PyMFEM available with pip install mfem . Oct 30, 2020 Version 4.2 released . Jul 11, 2020 MFEM paper in Computers & Mathematics with Applications. Jun 24, 2020 MFEM video available on YouTube. Jun 8, 2020 ECP podcast about mfem-4.1. Jun 8, 2020 Matrix-free high-order solvers research highlighted in CASC Newsletter #9. Mar 30, 2020 Remhos a new MFEM-based miniapp for high-order DG remap released. Mar 29, 2020 CEED v3.0 and libCEED v0.6 released with updated MFEM support. Mar 27, 2020 Laghos v3.0 released with direct device support based on MFEM-4.1. Mar 10, 2020 Version 4.1 released . Nov 20, 2019 MFEM overview paper available on arXiv. May 24, 2019 Version 4.0 released with initial GPU support. May 10, 2019 AMR and TMOP papers available on arXiv. Mar 30, 2019 CEED v2.0 and libCEED v0.4 released with MFEM support. Mar 22, 2019 A version of the Laghos miniapp released for use in the second edition of the Commodity Technology Systems procurement process. Nov 19, 2018 Laghos v2.0 released with CUDA, RAJA, OCCA and AMR versions. Nov 9, 2018 MFEM part of the first release of the Extreme-Scale Scientific Software Stack (E4S) by the Software Technologies focus area of the ECP. Aug 6, 2018 Unstructured technologies presentation at ATPESC18 . May 29, 2018 Version 3.4 released . Apr 2, 2018 MFEM part of OpenHPC , a Linux Foundation project for software components required to deploy and manage HPC Linux clusters. Mar 30, 2018 CEED v1.0 and libCEED v0.2 released with MFEM support. Mar 1, 2018 MFEM highlighted in LLNL's Science & Technology Review magazine, including on the cover . Dec 30, 2017 Initial version of libCEED , the low-level CEED API, released. Nov 10, 2017 Version 3.3.2 released . Nov 7, 2017 ECP article: Co-Design Center Develops Next-Generation Simulation Tools , also in HPCwire . Oct 30, 2017 Laghos part of the ECP Proxy App Suite 1.0 , CORAL-2 Benchmarks and ASC co-design miniapps . Oct 16, 2017 Postdoc position available for electromagnetic simulations with MFEM. Sep 22, 2017 LLNL Newsline: LLNL gears up for next generation of computer-aided design and engineering . Jun 15, 2017 Laghos miniapp and CEED benchmarks released. May 8, 2017 News highlight: Accelerating Simulation Software with Graphics Processing Units . Feb 16, 2017 Moved main development to GitHub. Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Nov 11, 2016 MFEM part of the new ECP co-design Center for Efficient Exascale Discretizations (CEED) . Nov 11, 2016 LLNL Newsline: Lawrence Livermore tapped to lead co-design center for exascale computing ecosystem . Oct 6, 2016 Science & Technology Review article: Laying the Groundwork for Extreme-Scale Computing , see also the YouTube preview . Sep 19, 2016 PyMFEM - a Python wrapper for MFEM by Syun'ichi Shiraiwa from MIT's Plasma Science and Fusion Center released. Jun 30, 2016 Version 3.2 released . May 6, 2016 MFEM packages available in homebrew and spack . Mar 9, 2016 VisIt 2.10.1 released with MFEM 3.1 support. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 16, 2016 Version 3.1 released . Feb 5, 2016 MFEM simulation images part of the Art of Science exhibition at the Livermore public library. Jan 6, 2016 News highlight: High-order finite element library provides scientists with access to cutting-edge algorithms . Aug 18, 2015 Moved to GitHub and mfem.org . Jan 26, 2015 Version 3.0 released .","title":"_News"},{"location":"news/#all-news-updates","text":"Apr 22, 2021 MFEM featured on S&TR magazine cover . Mar 1, 2021 Logo featured throughout LLNL 2020 annual report . Feb 16, 2021 New documentation page on GPU performance . Dec 19, 2020 PyMFEM available with pip install mfem . Oct 30, 2020 Version 4.2 released . Jul 11, 2020 MFEM paper in Computers & Mathematics with Applications. Jun 24, 2020 MFEM video available on YouTube. Jun 8, 2020 ECP podcast about mfem-4.1. Jun 8, 2020 Matrix-free high-order solvers research highlighted in CASC Newsletter #9. Mar 30, 2020 Remhos a new MFEM-based miniapp for high-order DG remap released. Mar 29, 2020 CEED v3.0 and libCEED v0.6 released with updated MFEM support. Mar 27, 2020 Laghos v3.0 released with direct device support based on MFEM-4.1. Mar 10, 2020 Version 4.1 released . Nov 20, 2019 MFEM overview paper available on arXiv. May 24, 2019 Version 4.0 released with initial GPU support. May 10, 2019 AMR and TMOP papers available on arXiv. Mar 30, 2019 CEED v2.0 and libCEED v0.4 released with MFEM support. Mar 22, 2019 A version of the Laghos miniapp released for use in the second edition of the Commodity Technology Systems procurement process. Nov 19, 2018 Laghos v2.0 released with CUDA, RAJA, OCCA and AMR versions. Nov 9, 2018 MFEM part of the first release of the Extreme-Scale Scientific Software Stack (E4S) by the Software Technologies focus area of the ECP. Aug 6, 2018 Unstructured technologies presentation at ATPESC18 . May 29, 2018 Version 3.4 released . Apr 2, 2018 MFEM part of OpenHPC , a Linux Foundation project for software components required to deploy and manage HPC Linux clusters. Mar 30, 2018 CEED v1.0 and libCEED v0.2 released with MFEM support. Mar 1, 2018 MFEM highlighted in LLNL's Science & Technology Review magazine, including on the cover . Dec 30, 2017 Initial version of libCEED , the low-level CEED API, released. Nov 10, 2017 Version 3.3.2 released . Nov 7, 2017 ECP article: Co-Design Center Develops Next-Generation Simulation Tools , also in HPCwire . Oct 30, 2017 Laghos part of the ECP Proxy App Suite 1.0 , CORAL-2 Benchmarks and ASC co-design miniapps . Oct 16, 2017 Postdoc position available for electromagnetic simulations with MFEM. Sep 22, 2017 LLNL Newsline: LLNL gears up for next generation of computer-aided design and engineering . Jun 15, 2017 Laghos miniapp and CEED benchmarks released. May 8, 2017 News highlight: Accelerating Simulation Software with Graphics Processing Units . Feb 16, 2017 Moved main development to GitHub. Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Nov 11, 2016 MFEM part of the new ECP co-design Center for Efficient Exascale Discretizations (CEED) . Nov 11, 2016 LLNL Newsline: Lawrence Livermore tapped to lead co-design center for exascale computing ecosystem . Oct 6, 2016 Science & Technology Review article: Laying the Groundwork for Extreme-Scale Computing , see also the YouTube preview . Sep 19, 2016 PyMFEM - a Python wrapper for MFEM by Syun'ichi Shiraiwa from MIT's Plasma Science and Fusion Center released. Jun 30, 2016 Version 3.2 released . May 6, 2016 MFEM packages available in homebrew and spack . Mar 9, 2016 VisIt 2.10.1 released with MFEM 3.1 support. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 16, 2016 Version 3.1 released . Feb 5, 2016 MFEM simulation images part of the Art of Science exhibition at the Livermore public library. Jan 6, 2016 News highlight: High-order finite element library provides scientists with access to cutting-edge algorithms . Aug 18, 2015 Moved to GitHub and mfem.org . Jan 26, 2015 Version 3.0 released .","title":"All News Updates"},{"location":"nonlininteg/","text":"Nonlinear Form Integrators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Nonlinear form integrators are used to express the local action of a general nonlinear finite element operator. Depending on the implementation they can also provide the capability to assemble the local gradient operator or to compute the local energy. TMOP integrator for variational minimization The TMOP_Integrator is used for mesh optimization by node movement. It represents the nonlinear objective function that arises in the Target-Matrix Optimization Paradigm (TMOP), as described in this publication . The local action and gradient, for an element $E_p$ in physical space, of the integrator compute \\begin{equation} F(x) = \\int_{E_t} \\frac{\\partial \\mu(J_{pt})}{\\partial x} ~ d x_t \\,, \\quad \\partial F(x) = \\int_{E_t} \\frac{\\partial^2 \\mu(J_{pt})}{\\partial{x^2}} ~ d x_t \\,, \\end{equation} where $x$ is the vector of positions for the mesh nodes of $E_p$; $x_t$ are positions in the target element $E_t$, which corresponds to $E_p$ (see class TargetConstructor ), and $J_{pt}$ is the Jacobian of the transformation from $E_t$ to $E_p$; and $\\mu$ is a mesh quality metric that is evaluated at quadrature points (see class TMOP_QualityMetric ). The local energy of the integrator represents the integral of $\\mu$ over the target element. Convective acceleration The VectorConvectionNLFIntegrator implements the local action of $(u \\cdot \\grad u, v)$, where $u, v \\in H_1^d$ for $d = 2, 3$. This term arises e.g. in the weak form of the Navier-Stokes equations. It also allows to assemble the local gradient which is represented by the linearization of the local action around $\\delta u$. Using the definition of the Gateaux derivative for functions \\begin{equation} F'(u, \\delta u) = \\lim_{\\epsilon \\to \\infty} \\frac{F(u + \\epsilon \\delta u) - F(u)}{\\epsilon} \\end{equation} with $F(u) = u \\cdot \\grad u$, we arrive at \\begin{equation} F'(u, \\delta u) = u \\cdot \\grad \\delta u + \\delta u \\cdot \\grad u. \\end{equation} The local gradient $(F'(u, \\delta u), v)$ can be computed by calling the GetGradient method of NonlinearForm . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Nonlinear Form Integrators"},{"location":"nonlininteg/#nonlinear-form-integrators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Nonlinear form integrators are used to express the local action of a general nonlinear finite element operator. Depending on the implementation they can also provide the capability to assemble the local gradient operator or to compute the local energy.","title":"Nonlinear Form Integrators"},{"location":"nonlininteg/#tmop-integrator-for-variational-minimization","text":"The TMOP_Integrator is used for mesh optimization by node movement. It represents the nonlinear objective function that arises in the Target-Matrix Optimization Paradigm (TMOP), as described in this publication . The local action and gradient, for an element $E_p$ in physical space, of the integrator compute \\begin{equation} F(x) = \\int_{E_t} \\frac{\\partial \\mu(J_{pt})}{\\partial x} ~ d x_t \\,, \\quad \\partial F(x) = \\int_{E_t} \\frac{\\partial^2 \\mu(J_{pt})}{\\partial{x^2}} ~ d x_t \\,, \\end{equation} where $x$ is the vector of positions for the mesh nodes of $E_p$; $x_t$ are positions in the target element $E_t$, which corresponds to $E_p$ (see class TargetConstructor ), and $J_{pt}$ is the Jacobian of the transformation from $E_t$ to $E_p$; and $\\mu$ is a mesh quality metric that is evaluated at quadrature points (see class TMOP_QualityMetric ). The local energy of the integrator represents the integral of $\\mu$ over the target element.","title":"TMOP integrator for variational minimization"},{"location":"nonlininteg/#convective-acceleration","text":"The VectorConvectionNLFIntegrator implements the local action of $(u \\cdot \\grad u, v)$, where $u, v \\in H_1^d$ for $d = 2, 3$. This term arises e.g. in the weak form of the Navier-Stokes equations. It also allows to assemble the local gradient which is represented by the linearization of the local action around $\\delta u$. Using the definition of the Gateaux derivative for functions \\begin{equation} F'(u, \\delta u) = \\lim_{\\epsilon \\to \\infty} \\frac{F(u + \\epsilon \\delta u) - F(u)}{\\epsilon} \\end{equation} with $F(u) = u \\cdot \\grad u$, we arrive at \\begin{equation} F'(u, \\delta u) = u \\cdot \\grad \\delta u + \\delta u \\cdot \\grad u. \\end{equation} The local gradient $(F'(u, \\delta u), v)$ can be computed by calling the GetGradient method of NonlinearForm . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Convective acceleration"},{"location":"parallel-tutorial/","text":"Parallel Tutorial Summary This tutorial illustrates the building and sample use of the following MFEM parallel example codes: Example 1p Example 2p Example 3p An interactive documentation of all example codes is available here . Building Follow the building instructions to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the parallel example codes, type make in MFEM's examples directory: ~/mfem/examples> make mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ... Example 1p This is a parallel version of Example 1 using hypre 's BoomerAMG preconditioner. Run this example as follows: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/square-disc.mesh ... PCG Iterations = 26 Final PCG Relative Residual Norm = 4.30922e-13 If a GLVis server is running, the computed finite element solution combined from all processors , will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . To view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button. To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example was produced by glvis -np 16 -m mesh -g sol -k \"RAjlb\" followed by F9 and scaling/position adjustment with the mouse. Three-dimensional and curvilinear meshes are also supported in parallel: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/escher-p3.mesh ... PCG Iterations = 24 Final PCG Relative Residual Norm = 3.59964e-13 ~/mfem/examples> glvis -np 16 -m mesh -g sol -k \"Aooogtt\" The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments): Example 2p This is a parallel version of Example 2 using the systems version of hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case: ~/mfem/examples> mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1 ... PCG Iterations = 39 Final PCG Relative Residual Norm = 2.91528e-09 To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse: Example 3p This is a parallel version of Example 3 using hypre 's AMS preconditioner. Its use is analogous to the serial case: /mfem/examples> mpirun -np 16 ex3p -m ../data/fichera-q3.mesh ... PCG Iterations = 17 Final PCG Relative Residual Norm = 7.61595e-13 || E_h - E ||_{L^2} = 0.0821685 Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12: One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries: glvis -np 16 -m mesh -g sol -k \"ooottmiEF\"","title":"Parallel Tutorial"},{"location":"parallel-tutorial/#parallel-tutorial","text":"","title":"Parallel Tutorial"},{"location":"parallel-tutorial/#summary","text":"This tutorial illustrates the building and sample use of the following MFEM parallel example codes: Example 1p Example 2p Example 3p An interactive documentation of all example codes is available here .","title":"Summary"},{"location":"parallel-tutorial/#building","text":"Follow the building instructions to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the parallel example codes, type make in MFEM's examples directory: ~/mfem/examples> make mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ...","title":"Building"},{"location":"parallel-tutorial/#example-1p","text":"This is a parallel version of Example 1 using hypre 's BoomerAMG preconditioner. Run this example as follows: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/square-disc.mesh ... PCG Iterations = 26 Final PCG Relative Residual Norm = 4.30922e-13 If a GLVis server is running, the computed finite element solution combined from all processors , will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . To view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button. To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example was produced by glvis -np 16 -m mesh -g sol -k \"RAjlb\" followed by F9 and scaling/position adjustment with the mouse. Three-dimensional and curvilinear meshes are also supported in parallel: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/escher-p3.mesh ... PCG Iterations = 24 Final PCG Relative Residual Norm = 3.59964e-13 ~/mfem/examples> glvis -np 16 -m mesh -g sol -k \"Aooogtt\" The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments):","title":"Example 1p"},{"location":"parallel-tutorial/#example-2p","text":"This is a parallel version of Example 2 using the systems version of hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case: ~/mfem/examples> mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1 ... PCG Iterations = 39 Final PCG Relative Residual Norm = 2.91528e-09 To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:","title":"Example 2p"},{"location":"parallel-tutorial/#example-3p","text":"This is a parallel version of Example 3 using hypre 's AMS preconditioner. Its use is analogous to the serial case: /mfem/examples> mpirun -np 16 ex3p -m ../data/fichera-q3.mesh ... PCG Iterations = 17 Final PCG Relative Residual Norm = 7.61595e-13 || E_h - E ||_{L^2} = 0.0821685 Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12: One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries: glvis -np 16 -m mesh -g sol -k \"ooottmiEF\"","title":"Example 3p"},{"location":"performance/","text":"Performance and Partial Assembly This document provides a brief overview of the tensor-based high-performance and partial assembly features in MFEM. In the traditional finite element setting, the operator is assembled in the form of a matrix. The action of the operator is computed by multiplying with this matrix. At high orders this requires both a large amount of memory to store the matrix, as well as many floating point operations to compute and apply it. Partial assembly is a technique that allows for efficiently applying the action of finite element operators without forming the corresponding matrix. This is particularly important when running on GPUs . Partial assembly is enabled at the level of the BilinearForm by setting the assembly level: a->SetAssemblyLevel(AssemblyLevel::PARTIAL); Once partial assembly is enabled, subsequent calls to member functions such as FormLinearSystem will result in an Operator that represents the action of the bilinear form a , without assembling a matrix. This functionality is illustrated in several MFEM examples , including examples 1, 3, 4, 5, 6, 9, 24, and 26. Note that partial assembly is currently implemented for tensor-product elements (i.e. quadrilaterals and hexahedra). Partial assembly for simplex elements (triangles and tetrahedra) is planned. Preconditioning with Partial Assembly When using partial assembly, the system matrix is no longer available for constructing preconditioners. This means that some of the standard preconditioners in MFEM such as HypreBoomerAMG and GSSmoother cannot be used. MFEM allows for the efficient construction of diagonal (Jacobi) smoothers for partially assembled operators on quad and hex meshes using the class OperatorJacobiSmoother . This class efficiently assembles the diagonal of the corresponding matrix, exploiting the tensor-product structure for efficient evaluation. MFEM also allows for Chebyshev smoothing with partial assembly using the class OperatorChebyshevSmoother . This smoother uses estimates of the eigenvalues of the operator computed using the power method , and is built upon the functionality of OperatorJacobiSmoother . Very efficient partially assembled h-multigrid and p-multigrid preconditioners can be constructed by leveraging a hierarchy of discretizations and the smoothers described above. This functionality is illustrated in Example 26 . Finite Element Operator Decomposition The partial assembly functionality in MFEM is based on decomposing the finite element operator into a nested sequence of operations that act on different levels of the discretization. Finite element operators are typically defined through weak formulations of partial differential equations that involve integration over a computational mesh. The required integrals are computed by splitting them as a sum over the mesh elements, mapping each element to a simple reference element (e.g. the unit square) and applying a quadrature rule in reference space. This sequence of operations highlights an inherent hierarchical structure present in all finite element operators where the evaluation starts on global (trial) degrees of freedom (dofs) on the whole mesh , restricts to degrees of freedom on subdomains (groups of elements), then moves to independent degrees of freedom on each element , transitions to independent quadrature points in reference space, performs the integration, and then goes back in reverse order to global (test) degrees of freedom on the whole mesh. This is illustrated below for the case of a symmetric linear operator. We use the notions T-vector , L-vector , E-vector and Q-vector to represent the sets corresponding to the (true) degrees of freedom on the global mesh, the split local degrees of freedom on the subdomains, the split degrees of freedom on the mesh elements, and the values at quadrature points, respectively. We refer to the operators that connect the different types of vectors as: Subdomain restriction P Element restriction G Basis (Dofs-to-Qpts) evaluator B Operator at quadrature points D More generally, if the operator is nonsymmetric or the test and trial space differ, then the operators mapping back from quadrature points to test spaces may not be transposes of P , G and B , but they still have the same basic structure and interpretation. Note that in the case of adaptive mesh refinement (AMR), the prolongation operator P involves not only extracting sub-vectors, but evaluating values at constrained degrees of freedom through the AMR interpolation. There can also be several levels of subdomains ( P1 , P2 , etc.), and it may be convenient to split D as the product of several operators ( D1 , D2 , etc.). Partial Assembly in MFEM Since the global operator A is just a series of variational restrictions with B , G and P , starting from its point-wise kernel D , a \"matrix-vector product\" with A can be performed by evaluating and storing some of the innermost variational restriction matrices, and applying the rest of the operators \"on-the-fly\". For example, one can compute and store a global matrix on T-vector level. Alternatively, one can compute and store only the subdomain (L-vector) or element (E-vector) matrices and perform the action of A using matvecs with P or P and G . While these options are natural for low-order discretizations, they are not a good fit for high-order methods due to the amount of FLOPs needed for their evaluation, as well as the memory transfer needed for a matvec. MFEM's partial assembly functionality computes and stores only D (or portions of it) and evaluates the actions of P , G and B on-the-fly. Critically for performance, MFEM takes advantage of the tensor-product structure of the degrees of freedom and quadrature points on quadrilateral and hexahedral elements to perform the action of B without storing it as a matrix. Note that the action of B is performed element-wise (it corresponds to a block-diagonal matrix), and the blocks depend only on the element order and reference geometry. Currently, only fixed order and geometry is supported, meaning that all the blocks of B are identical. The partial assembly algorithm requires the optimal amount of memory transfers (with respect to the polynomial order) and near-optimal FLOPs for operator evaluation. It consists of an operator setup phase, that evaluates and stores D and an operator apply (evaluation) phase that computes the action of A on an input vector. When desired, the setup phase may be done as a side-effect of evaluating a different operator, such as a nonlinear residual. The relative costs of the setup and apply phases are different depending on the physics being expressed and the representation of D . Parallel Decomposition After the application of each of the first three transition operators, P , G and B , the operator evaluation is decoupled on their ranges, so P , G and B allow us to \"zoom-in\" to subdomain, element and quadrature point level, ignoring the coupling at higher levels. Thus, a natural mapping of A on a parallel computer is to split the T-vector over MPI ranks (a non-overlapping decomposition, as is typically used for sparse matrices), and then split the rest of the vector types over computational devices (CPUs, GPUs, etc.) as indicated by the shaded regions in the diagram above. One of the advantages of the decomposition perspective in these settings is that the operators P , G , B and D clearly separate the MPI parallelism in the operator ( P ) from the unstructured mesh topology ( G ), the choice of the finite element space/basis ( B ) and the geometry and point-wise physics D . These components also naturally fall in different classes of numerical algorithms: parallel (multi-device) linear algebra for P , sparse (on-device) linear algebra for G , dense/structured linear algebra (tensor contractions) for B and parallel point-wise evaluations for D . Essential Boundary Conditions Essential boundary conditions for partially assembled operators are enforced using the class ConstrainedOperator (or, for rectangular systems, RectangularConstrainedOperator ). These operators represent the action of the partially assembled operator, together with specified constraints on essential degrees of freedom. The Operator returned from, for example, BilinearForm::FormLinearSystem or BilinearForm::FormSystemMatrix will in fact be a ConstrainedOperator . The Operator returned from MixedBilinearForm::FormRectangularSystemMatrix will be a RectangularConstrainedOperator . These classes perform the matrix-free equivalent of eliminating the rows and columns of the system matrix corresponding to the essential degrees of freedom. Partial Assembly for Discontinuous Galerkin methods A complementary partial assembly decomposition is used for Discontinuous Galerkin methods to handle face terms, where a similar sequence of operators is applied on the faces to compute the numerical fluxes. However, since elements are decoupled, the element restriction G is the identity, and a face restriction G F is used instead to compute the numerical fluxes and couple elements together. This face restriction G F goes from element degrees of freedom to face degrees of freedom. Then a B F operator can be applied on the faces. An analogous D F operator is then applied at the face quadrature points. Currently, we support partial assembly only for Gauss-Lobatto and Bernstein bases, with integrators that don't require derivatives on the faces. High-Performance Templated Operators MFEM also offers a set of templated classes to evaluate finite element operators on tensor-product (quadrilateral and hexahedral) meshes, described in further detail here .","title":"Performance"},{"location":"performance/#performance-and-partial-assembly","text":"This document provides a brief overview of the tensor-based high-performance and partial assembly features in MFEM. In the traditional finite element setting, the operator is assembled in the form of a matrix. The action of the operator is computed by multiplying with this matrix. At high orders this requires both a large amount of memory to store the matrix, as well as many floating point operations to compute and apply it. Partial assembly is a technique that allows for efficiently applying the action of finite element operators without forming the corresponding matrix. This is particularly important when running on GPUs . Partial assembly is enabled at the level of the BilinearForm by setting the assembly level: a->SetAssemblyLevel(AssemblyLevel::PARTIAL); Once partial assembly is enabled, subsequent calls to member functions such as FormLinearSystem will result in an Operator that represents the action of the bilinear form a , without assembling a matrix. This functionality is illustrated in several MFEM examples , including examples 1, 3, 4, 5, 6, 9, 24, and 26. Note that partial assembly is currently implemented for tensor-product elements (i.e. quadrilaterals and hexahedra). Partial assembly for simplex elements (triangles and tetrahedra) is planned.","title":"Performance and Partial Assembly"},{"location":"performance/#preconditioning-with-partial-assembly","text":"When using partial assembly, the system matrix is no longer available for constructing preconditioners. This means that some of the standard preconditioners in MFEM such as HypreBoomerAMG and GSSmoother cannot be used. MFEM allows for the efficient construction of diagonal (Jacobi) smoothers for partially assembled operators on quad and hex meshes using the class OperatorJacobiSmoother . This class efficiently assembles the diagonal of the corresponding matrix, exploiting the tensor-product structure for efficient evaluation. MFEM also allows for Chebyshev smoothing with partial assembly using the class OperatorChebyshevSmoother . This smoother uses estimates of the eigenvalues of the operator computed using the power method , and is built upon the functionality of OperatorJacobiSmoother . Very efficient partially assembled h-multigrid and p-multigrid preconditioners can be constructed by leveraging a hierarchy of discretizations and the smoothers described above. This functionality is illustrated in Example 26 .","title":"Preconditioning with Partial Assembly"},{"location":"performance/#finite-element-operator-decomposition","text":"The partial assembly functionality in MFEM is based on decomposing the finite element operator into a nested sequence of operations that act on different levels of the discretization. Finite element operators are typically defined through weak formulations of partial differential equations that involve integration over a computational mesh. The required integrals are computed by splitting them as a sum over the mesh elements, mapping each element to a simple reference element (e.g. the unit square) and applying a quadrature rule in reference space. This sequence of operations highlights an inherent hierarchical structure present in all finite element operators where the evaluation starts on global (trial) degrees of freedom (dofs) on the whole mesh , restricts to degrees of freedom on subdomains (groups of elements), then moves to independent degrees of freedom on each element , transitions to independent quadrature points in reference space, performs the integration, and then goes back in reverse order to global (test) degrees of freedom on the whole mesh. This is illustrated below for the case of a symmetric linear operator. We use the notions T-vector , L-vector , E-vector and Q-vector to represent the sets corresponding to the (true) degrees of freedom on the global mesh, the split local degrees of freedom on the subdomains, the split degrees of freedom on the mesh elements, and the values at quadrature points, respectively. We refer to the operators that connect the different types of vectors as: Subdomain restriction P Element restriction G Basis (Dofs-to-Qpts) evaluator B Operator at quadrature points D More generally, if the operator is nonsymmetric or the test and trial space differ, then the operators mapping back from quadrature points to test spaces may not be transposes of P , G and B , but they still have the same basic structure and interpretation. Note that in the case of adaptive mesh refinement (AMR), the prolongation operator P involves not only extracting sub-vectors, but evaluating values at constrained degrees of freedom through the AMR interpolation. There can also be several levels of subdomains ( P1 , P2 , etc.), and it may be convenient to split D as the product of several operators ( D1 , D2 , etc.).","title":"Finite Element Operator Decomposition"},{"location":"performance/#partial-assembly-in-mfem","text":"Since the global operator A is just a series of variational restrictions with B , G and P , starting from its point-wise kernel D , a \"matrix-vector product\" with A can be performed by evaluating and storing some of the innermost variational restriction matrices, and applying the rest of the operators \"on-the-fly\". For example, one can compute and store a global matrix on T-vector level. Alternatively, one can compute and store only the subdomain (L-vector) or element (E-vector) matrices and perform the action of A using matvecs with P or P and G . While these options are natural for low-order discretizations, they are not a good fit for high-order methods due to the amount of FLOPs needed for their evaluation, as well as the memory transfer needed for a matvec. MFEM's partial assembly functionality computes and stores only D (or portions of it) and evaluates the actions of P , G and B on-the-fly. Critically for performance, MFEM takes advantage of the tensor-product structure of the degrees of freedom and quadrature points on quadrilateral and hexahedral elements to perform the action of B without storing it as a matrix. Note that the action of B is performed element-wise (it corresponds to a block-diagonal matrix), and the blocks depend only on the element order and reference geometry. Currently, only fixed order and geometry is supported, meaning that all the blocks of B are identical. The partial assembly algorithm requires the optimal amount of memory transfers (with respect to the polynomial order) and near-optimal FLOPs for operator evaluation. It consists of an operator setup phase, that evaluates and stores D and an operator apply (evaluation) phase that computes the action of A on an input vector. When desired, the setup phase may be done as a side-effect of evaluating a different operator, such as a nonlinear residual. The relative costs of the setup and apply phases are different depending on the physics being expressed and the representation of D .","title":"Partial Assembly in MFEM"},{"location":"performance/#parallel-decomposition","text":"After the application of each of the first three transition operators, P , G and B , the operator evaluation is decoupled on their ranges, so P , G and B allow us to \"zoom-in\" to subdomain, element and quadrature point level, ignoring the coupling at higher levels. Thus, a natural mapping of A on a parallel computer is to split the T-vector over MPI ranks (a non-overlapping decomposition, as is typically used for sparse matrices), and then split the rest of the vector types over computational devices (CPUs, GPUs, etc.) as indicated by the shaded regions in the diagram above. One of the advantages of the decomposition perspective in these settings is that the operators P , G , B and D clearly separate the MPI parallelism in the operator ( P ) from the unstructured mesh topology ( G ), the choice of the finite element space/basis ( B ) and the geometry and point-wise physics D . These components also naturally fall in different classes of numerical algorithms: parallel (multi-device) linear algebra for P , sparse (on-device) linear algebra for G , dense/structured linear algebra (tensor contractions) for B and parallel point-wise evaluations for D .","title":"Parallel Decomposition"},{"location":"performance/#essential-boundary-conditions","text":"Essential boundary conditions for partially assembled operators are enforced using the class ConstrainedOperator (or, for rectangular systems, RectangularConstrainedOperator ). These operators represent the action of the partially assembled operator, together with specified constraints on essential degrees of freedom. The Operator returned from, for example, BilinearForm::FormLinearSystem or BilinearForm::FormSystemMatrix will in fact be a ConstrainedOperator . The Operator returned from MixedBilinearForm::FormRectangularSystemMatrix will be a RectangularConstrainedOperator . These classes perform the matrix-free equivalent of eliminating the rows and columns of the system matrix corresponding to the essential degrees of freedom.","title":"Essential Boundary Conditions"},{"location":"performance/#partial-assembly-for-discontinuous-galerkin-methods","text":"A complementary partial assembly decomposition is used for Discontinuous Galerkin methods to handle face terms, where a similar sequence of operators is applied on the faces to compute the numerical fluxes. However, since elements are decoupled, the element restriction G is the identity, and a face restriction G F is used instead to compute the numerical fluxes and couple elements together. This face restriction G F goes from element degrees of freedom to face degrees of freedom. Then a B F operator can be applied on the faces. An analogous D F operator is then applied at the face quadrature points. Currently, we support partial assembly only for Gauss-Lobatto and Bernstein bases, with integrators that don't require derivatives on the faces.","title":"Partial Assembly for Discontinuous Galerkin methods"},{"location":"performance/#high-performance-templated-operators","text":"MFEM also offers a set of templated classes to evaluate finite element operators on tensor-product (quadrilateral and hexahedral) meshes, described in further detail here .","title":"High-Performance Templated Operators"},{"location":"pri-dual-vec/","text":"Primal and Dual Vectors The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Graphical summary of Primal, Dual, DoF (dofs), and True DoF (tdofs) vectors Primal Vectors The finite element method is based on the notion that a smooth function can be approximated by a sum of piece-wise smooth functions (typically piece-wise polynomials) called basis functions : $$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$ The support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be a single zone or a collection of zones that share a common vertex, edge, or face. The expansion coefficients, $\\;f_i$, are linear functionals of the field being approximated, $\\;f(\\vec{x})$ in this case. The $\\;f_i$ could be as simple as values of the function at particular points, called interpolation points, e.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over submanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$. There are many possibilities but the expansion coefficients must be linear functionals of $\\;f(\\vec{x})$. The expansion coefficients are often called degrees of freedom , or DoFs for short, though in certain cases they may not be actually independent because of some problem specific constraints. We'll discuss this more in a later section on True DoFs . Once the basis functions are defined, with some unique ordering, the expansion coefficients can be stored in a vector using the same order. Such a vector of coefficients is called a primal vector . The original function, $\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}. In practice this requires not only the primal vector of coefficients but also knowledge of the mesh and the basis functions for each element of the mesh. In MFEM these collections of information are combined into GridFunction objects (or ParGridFunction objects when used in parallel) which represent piece-wise functions belonging to a finite element approximation space. The GridFunction class contains many Get methods which can compute the expansion \\eqref{expan} at particular locations within an element. The primal vector of expansion coefficients can be computed by solving a linear system or by using any of the various Project methods provided by the GridFunction class. These methods compute the degrees of freedom, $\\;f_i$, or some subset of them, from a Coefficient object representing $\\;f(\\vec{x})$. Other methods in this class can be used to compute various measures of the error in the finite element approximation of $\\;f(\\vec{x})$. Dual Vectors Any vector space, such as the space of primal vectors , has a dual space containing co-vectors a.k.a. dual vectors . In this context a dual vector is a linear functional of a primal vector meaning that the action of a dual vector upon a primal vector is a real number. For example, the integral of a field over a domain, $\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the integral is linear with respect to the function being integrated and the result is a real number. Indeed we can derive similar linear functionals using compatible functions, $\\;g(\\vec{x})$, in this way $G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our functional on the finite element basis functions, $$G_i=G(\\phi_i(\\vec{x})) = \\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$ and we collect the results into a vector we call this a dual vector . Integrals such as this often arise when enforcing energy balance in physical systems. For example, if $\\vec{J}$ is a current density describing a flow of charged particles and $\\vec{E}$ is an electric field acting upon those particles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which work is being done by the field on the charged particles. MFEM provides LinearForm objects (or ParLinearForm objects in parallel) which can compute dual vectors from a given function, $\\;g(\\vec{x})$. These objects require not only the mesh, basis functions, and the field $\\;g(\\vec{x})$ but also a LinearFormIntegrator which defines precisely what type of linear functional is being computed. See Linear Form Integrators for more information about MFEM's linear form integrators. A LinearForm objects provide one means for computing dual vectors if you have a Coefficient describing the function $\\;g(\\vec{x})$. If, on the other hand, you have a primal vector , $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a dual vector by multiplying $\\;g_i$ by a bilinear form, see Bilinear Form Integrators for more information on bilinear forms. To understand why this is so, consider inserting the expansion \\eqref{expan} into \\eqref{dualvec}. $$ G_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x} = \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j \\label{dualvecprod}$$ The last integral contains two indices and can therefore be viewed as an entry in a square matrix. Furthermore each dual vector entry, $\\;G_i$, is equivalent to one row of a matrix-vector product between this matrix of basis function integrals and the primal vector $\\;g_i$. This particular matrix, involving only the product of basis functions, is traditionally called a mass matrix . However, the action of any matrix, resulting from a bilinear form, upon a primal vector will produce a dual vector . In general, such dual vectors will have more complicated definitions than \\eqref{dualvec} or \\eqref{dualvecprod} but they will still be linear functionals of primal vectors . True Degree-of-Freedom Vectors Primal vectors contain all of the expansion coefficients needed to compute the finite element approximation of a function in each element of a mesh. When run in parallel, the local portion of a primal vector only contains data for the locally owned elements. Regardless of whether or not the simulation is being run in parallel, some of these coefficients may in fact be redundant or interdependent. Sources of redundancy: In parallel some coefficients must be shared between processors. When using static condensation or hybridization many coefficients will depend upon the coefficients which are associated with the skeleton of the mesh as well as upon other data. When using non-conforming meshes some of the coefficients on the finer side of a non-conforming interface between elements will depend upon those on the coarser side of the interface. For any or all of these reasons primal vectors may not contain the true degrees-of-freedom for describing a finite element approximation of a field. The true set of degrees-of-freedom may in fact be much smaller than the size of the primal vector. When setting up and solving a linear system to determine the finite element approximation of a field, the size of the linear system is determined by the number of true degrees-of-freedom . The details of creating this linear system are mostly hidden within the BilinearForm object. To convert individual bilinear form objects the user can call the BilinearForm::FormSystemMatrix() method, however, the more common task is to form the entire linear system with BilinearForm::FormLinearSystem() . As input, this method requires a primal vector , a dual vector , and an array of Dirichlet boundary degree-of-freedom indices. The degree-of-freedom array contains the true degrees-of-freedom, as obtained from a FiniteElementSpace object, which coincide with the Dirichlet, a.k.a. essential , boundaries. // Given a bilinear form 'a', a primal vector 'x', a dual vector 'b', // and an array of essential boundary true dof indices... SparseMatrix A; Vector B, X; a.FormLinearSystem(ess_tdof_list, x, b, A, X, B); // Solve X = A^{-1}B ... a.RecoverFEMSolution(X, b, x); The primal vector must contain the appropriate values for the solution on the essential boundaries. The interior of the primal vector is ignored by default although it can be used to supply an initial guess when using certain solvers. The dual vector should be an assembled LinearForm object or the product of a GridFunction and a BilinearForm . As output, BilinearForm::FormLinearSystem() produces the objects $A$, $X$, and $B$ in the linear system $A X=B$. Where $A$ is ready to be passed to the appropriate MFEM solver, $X$ is properly initialized, and $B$ has been modified to incorporate the essential boundary conditions. After the linear system has been solved the primal vector representing the solution must be built from $X$ and the original dual vector by calling BilinearForm::RecoverFEMSolution() . Technical Details Constructing Dual Vectors It was mentioned above, in the section on Dual Vectors , that you can create a dual vector by multiplying a primal vector by a bilinear form. But of course if you have a primal vector you can also use a GridFunctionCoefficient to create a dual vector using a LinearForm and an appropriate LinearFormIntegrator . These two choices should produce nearly identical results if the BilinearFormIntegrator and the LinearFormIntegrator use the same integration rule order. The order of the summation might differ between BilinearFormIntegrator and LinearFormIntegrator , potentially resulting in round-off errors differences. When considering to use a BilinearForm or a LinearForm, one must be aware of their different computational and memory costs. A bilinear form must create a sparse matrix which can require a great deal of memory. Integrating a GridFunctionCoefficient in a LinearForm object will require very little memory. On the other hand, computing the integrals inside a LinearForm object can be computationally expensive even in comparison to assembling the bilinear form. Which is the better option? As always, there are trade-offs. The answer depends on many variables; the complexities of the BilinearFormIntegrator and the LinearFormIntegrator , the complexity of other coefficients that may be present, the order of the basis functions, can the bilinear form be reused or is this a one-time calculation, whether the code runs on a CPU or GPU , etc. On some architectures the motion of data through memory during a matrix-vector multiplication may be expensive enough that using a LinearForm and recomputing the integrals is more efficient. Often the construction of dual vectors is a small portion of the overall compute time so this choice may not be critical. The best choice is to test your application and determine which method is more appropriate for your algorithm on your hardware. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Primal and Dual Vectors"},{"location":"pri-dual-vec/#primal-and-dual-vectors","text":"The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Graphical summary of Primal, Dual, DoF (dofs), and True DoF (tdofs) vectors","title":"Primal and Dual Vectors"},{"location":"pri-dual-vec/#primal-vectors","text":"The finite element method is based on the notion that a smooth function can be approximated by a sum of piece-wise smooth functions (typically piece-wise polynomials) called basis functions : $$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$ The support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be a single zone or a collection of zones that share a common vertex, edge, or face. The expansion coefficients, $\\;f_i$, are linear functionals of the field being approximated, $\\;f(\\vec{x})$ in this case. The $\\;f_i$ could be as simple as values of the function at particular points, called interpolation points, e.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over submanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$. There are many possibilities but the expansion coefficients must be linear functionals of $\\;f(\\vec{x})$. The expansion coefficients are often called degrees of freedom , or DoFs for short, though in certain cases they may not be actually independent because of some problem specific constraints. We'll discuss this more in a later section on True DoFs . Once the basis functions are defined, with some unique ordering, the expansion coefficients can be stored in a vector using the same order. Such a vector of coefficients is called a primal vector . The original function, $\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}. In practice this requires not only the primal vector of coefficients but also knowledge of the mesh and the basis functions for each element of the mesh. In MFEM these collections of information are combined into GridFunction objects (or ParGridFunction objects when used in parallel) which represent piece-wise functions belonging to a finite element approximation space. The GridFunction class contains many Get methods which can compute the expansion \\eqref{expan} at particular locations within an element. The primal vector of expansion coefficients can be computed by solving a linear system or by using any of the various Project methods provided by the GridFunction class. These methods compute the degrees of freedom, $\\;f_i$, or some subset of them, from a Coefficient object representing $\\;f(\\vec{x})$. Other methods in this class can be used to compute various measures of the error in the finite element approximation of $\\;f(\\vec{x})$.","title":"Primal Vectors"},{"location":"pri-dual-vec/#dual-vectors","text":"Any vector space, such as the space of primal vectors , has a dual space containing co-vectors a.k.a. dual vectors . In this context a dual vector is a linear functional of a primal vector meaning that the action of a dual vector upon a primal vector is a real number. For example, the integral of a field over a domain, $\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the integral is linear with respect to the function being integrated and the result is a real number. Indeed we can derive similar linear functionals using compatible functions, $\\;g(\\vec{x})$, in this way $G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our functional on the finite element basis functions, $$G_i=G(\\phi_i(\\vec{x})) = \\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$ and we collect the results into a vector we call this a dual vector . Integrals such as this often arise when enforcing energy balance in physical systems. For example, if $\\vec{J}$ is a current density describing a flow of charged particles and $\\vec{E}$ is an electric field acting upon those particles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which work is being done by the field on the charged particles. MFEM provides LinearForm objects (or ParLinearForm objects in parallel) which can compute dual vectors from a given function, $\\;g(\\vec{x})$. These objects require not only the mesh, basis functions, and the field $\\;g(\\vec{x})$ but also a LinearFormIntegrator which defines precisely what type of linear functional is being computed. See Linear Form Integrators for more information about MFEM's linear form integrators. A LinearForm objects provide one means for computing dual vectors if you have a Coefficient describing the function $\\;g(\\vec{x})$. If, on the other hand, you have a primal vector , $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a dual vector by multiplying $\\;g_i$ by a bilinear form, see Bilinear Form Integrators for more information on bilinear forms. To understand why this is so, consider inserting the expansion \\eqref{expan} into \\eqref{dualvec}. $$ G_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x} = \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j \\label{dualvecprod}$$ The last integral contains two indices and can therefore be viewed as an entry in a square matrix. Furthermore each dual vector entry, $\\;G_i$, is equivalent to one row of a matrix-vector product between this matrix of basis function integrals and the primal vector $\\;g_i$. This particular matrix, involving only the product of basis functions, is traditionally called a mass matrix . However, the action of any matrix, resulting from a bilinear form, upon a primal vector will produce a dual vector . In general, such dual vectors will have more complicated definitions than \\eqref{dualvec} or \\eqref{dualvecprod} but they will still be linear functionals of primal vectors .","title":"Dual Vectors"},{"location":"pri-dual-vec/#true-degree-of-freedom-vectors","text":"Primal vectors contain all of the expansion coefficients needed to compute the finite element approximation of a function in each element of a mesh. When run in parallel, the local portion of a primal vector only contains data for the locally owned elements. Regardless of whether or not the simulation is being run in parallel, some of these coefficients may in fact be redundant or interdependent. Sources of redundancy: In parallel some coefficients must be shared between processors. When using static condensation or hybridization many coefficients will depend upon the coefficients which are associated with the skeleton of the mesh as well as upon other data. When using non-conforming meshes some of the coefficients on the finer side of a non-conforming interface between elements will depend upon those on the coarser side of the interface. For any or all of these reasons primal vectors may not contain the true degrees-of-freedom for describing a finite element approximation of a field. The true set of degrees-of-freedom may in fact be much smaller than the size of the primal vector. When setting up and solving a linear system to determine the finite element approximation of a field, the size of the linear system is determined by the number of true degrees-of-freedom . The details of creating this linear system are mostly hidden within the BilinearForm object. To convert individual bilinear form objects the user can call the BilinearForm::FormSystemMatrix() method, however, the more common task is to form the entire linear system with BilinearForm::FormLinearSystem() . As input, this method requires a primal vector , a dual vector , and an array of Dirichlet boundary degree-of-freedom indices. The degree-of-freedom array contains the true degrees-of-freedom, as obtained from a FiniteElementSpace object, which coincide with the Dirichlet, a.k.a. essential , boundaries. // Given a bilinear form 'a', a primal vector 'x', a dual vector 'b', // and an array of essential boundary true dof indices... SparseMatrix A; Vector B, X; a.FormLinearSystem(ess_tdof_list, x, b, A, X, B); // Solve X = A^{-1}B ... a.RecoverFEMSolution(X, b, x); The primal vector must contain the appropriate values for the solution on the essential boundaries. The interior of the primal vector is ignored by default although it can be used to supply an initial guess when using certain solvers. The dual vector should be an assembled LinearForm object or the product of a GridFunction and a BilinearForm . As output, BilinearForm::FormLinearSystem() produces the objects $A$, $X$, and $B$ in the linear system $A X=B$. Where $A$ is ready to be passed to the appropriate MFEM solver, $X$ is properly initialized, and $B$ has been modified to incorporate the essential boundary conditions. After the linear system has been solved the primal vector representing the solution must be built from $X$ and the original dual vector by calling BilinearForm::RecoverFEMSolution() .","title":"True Degree-of-Freedom Vectors"},{"location":"pri-dual-vec/#technical-details","text":"","title":"Technical Details"},{"location":"pri-dual-vec/#constructing-dual-vectors","text":"It was mentioned above, in the section on Dual Vectors , that you can create a dual vector by multiplying a primal vector by a bilinear form. But of course if you have a primal vector you can also use a GridFunctionCoefficient to create a dual vector using a LinearForm and an appropriate LinearFormIntegrator . These two choices should produce nearly identical results if the BilinearFormIntegrator and the LinearFormIntegrator use the same integration rule order. The order of the summation might differ between BilinearFormIntegrator and LinearFormIntegrator , potentially resulting in round-off errors differences. When considering to use a BilinearForm or a LinearForm, one must be aware of their different computational and memory costs. A bilinear form must create a sparse matrix which can require a great deal of memory. Integrating a GridFunctionCoefficient in a LinearForm object will require very little memory. On the other hand, computing the integrals inside a LinearForm object can be computationally expensive even in comparison to assembling the bilinear form. Which is the better option? As always, there are trade-offs. The answer depends on many variables; the complexities of the BilinearFormIntegrator and the LinearFormIntegrator , the complexity of other coefficients that may be present, the order of the basis functions, can the bilinear form be reused or is this a one-time calculation, whether the code runs on a CPU or GPU , etc. On some architectures the motion of data through memory during a matrix-vector multiplication may be expensive enough that using a LinearForm and recomputing the integrals is more efficient. Often the construction of dual vectors is a small portion of the overall compute time so this choice may not be critical. The best choice is to test your application and determine which method is more appropriate for your algorithm on your hardware. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Constructing Dual Vectors"},{"location":"publications/","text":"Publications Google Scholar Citations Recent All time Selected Publications 2021 Tz. Kolev and W. Pazner, Conservative and accurate solution transfer between high-order and low-order refined finite element spaces , in review , 2021 . J. Yang, T. Dzanic, B. Petersen, J. Kudo, K. Mittal, V. Tomov, J.-S. Camier, T. Zhao, H. Zha, Tz. Kolev, R. Anderson, D. Faissol, Reinforcement Learning for Adaptive Mesh Refinement , in review , 2021 . W. Pazner and Tz. Kolev, Uniform subspace correction preconditioners for discontinuous Galerkin methods with hp -refinement , in review , 2021 . W. Pazner, Sparse invariant domain preserving discontinuous Galerkin methods with subcell convex limiting , in review , 2021 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, hr -adaptivity for nonconforming high-order meshes with the target matrix optimization paradigm , in review , 2021 . Also available as arXiv:2010.02166 . N. Whitman, T. Palmer, P. Greaney, S. Hosseini, D. Burkes, and D. Senor, Gray Phonon Transport Prediction of Thermal Conductivity in Lithium Aluminate with Higher-Order Finite Elements on Meshes with Curved Surfaces , Journal of Computational and Theoretical Transport , 2021 . H. Hajduk, Monolithic convex limiting in discontinuous Galerkin discretizations of hyperbolic conservation laws , Computers & Mathematics with Applications , (87) 120-138, 2021 . Also available as arXiv:2007.01212 . J. Nikl, I. G\u00f6thel, M. Kucha\u0159\u00edk, S. Weber, and M. Bussmann, Implicit reduced Vlasov-Fokker-Planck-Maxwell model based on high-order mixed elements , Journal of Computational Physics , (434) 110214, 2021 . 2020 N. Beams, A. Abdelfattah, S. Tomov, J. Dongarra, T. Kolev and Y. Dudouit, High-Order Finite Element Method using Standard and Device-Level Batch GEMM on GPUs , IEEE/ACM 11th ScalA Workshop , 53-60, 2020 . A. Barker and Tz. Kolev, Matrix-free preconditioning for high-order H(curl) discretizations , Numerical Linear Algebra with Applications , 28(2) e2348, 2020 . D. Kuzmin and M. Quezada de Luna, Entropy conservation property and entropy stabilization of high-order continuous Galerkin approximations to scalar conservation laws , Computers & Fluids , (213) 104742, 2020 . A. Sandu, V. Tomov, L. Cervena, and Tz. Kolev, Conservative High-Order Time Integration for Lagrangian Hydrodynamics , SIAM Journal on Scientific Computing , 43(1), A221-A241, 2020 . B. S. Southworth, M. Holec, and T. Haut. Diffusion synthetic acceleration for heterogeneous domains, compatible with voids , Nuclear Science and Engineering , 195(2), 119-136, 2020 . T. Haut, B. Southworth, P. Maginot, V. Tomov, Diffusion Synthetic Acceleration Preconditioning for Discontinuous Galerkin Discretizations of SN Transport on High-Order Curved Meshes , SIAM Journal on Scientific Computing , 42(5), B1271-B1301, 2020 . R. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerveny V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, W. Pazner, M. Stowell, V. Tomov, I. Akkerman, J. Dahm, D. Medina, and S. Zampini, MFEM: A Modular Finite Element Library , Computers & Mathematics with Applications , (81) 42-74, 2020 . Also available as arXiv:1911.09220 . R. Li and C. Zhang, Efficient Parallel Implementations of Sparse Triangular Solves for GPU Architectures , Proceedings of the 2020 SIAM Conference on Parallel Processing for Scientific Computing , 2020 . W. Pazner, Efficient low-order refined preconditioners for high-order matrix-free continuous and discontinuous Galerkin methods , SIAM Journal on Scientific Computing , 42(5), pp. A3055-A3083, 2020 . B. Yee, S. Olivier, T. Haut, M. Holec, V. Tomov, P. Maginot, A Quadratic Programming Flux Correction Method for High-Order DG Discretizations of SN Transport , Journal of Computational Physics , (419) 109696, 2020 . T. L. Horvath and S. Rhebergen, An exactly mass conserving space-time embedded-hybridized discontinuous Galerkin method for the Navier-Stokes equations on moving domains , Journal of Computational Physics , (417) 109577, 2020 . S. Rhebergen and G. N. Wells, An embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations , Computer Methods in Applied Mechanics and Engineering , (358) 112619, 2020 . P. Bello-Maldonado, Tz. Kolev, R. Rieben, and V. Tomov, A Matrix-Free Hyperviscosity Formulation for High-Order ALE Hydrodynamics , Computers & Fluids , (205) 104577, 2020 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, R. Rieben, and V. Tomov, Simulation-Driven Optimization of High-Order Meshes in ALE Hydrodynamics , Computers & Fluids , (208) 104602, 2020 . H. Hajduk, D. Kuzmin, Tz. Kolev, V. Tomov, I. Tomas, and J. Shadid, Matrix-free subcell residual distribution for Bernstein finite elements: Monolithic limiting , Computers & Fluids , (200) 104451, 2020 . M. Franco, J.-S. Camier, J. Andrej, and W. Pazner, High-order matrix-free incompressible flow solvers with GPU acceleration and low-order refined preconditioners , Computers & Fluids , (203) 104541, 2020 . S. Friedhoff and B. S. Southworth, On \"Optimal\" h-independent convergence of Parareal and multigrid-reduction-in-time using Runge-Kutta time integration , Numerical Linear Algebra with Applications , e2301, 2020 . B. S. Southworth, A. A. Sivas, and S. Rhebergen, On fixed-point, Krylov, and 2x2 block preconditioners for nonsymmetric problems , SIAM Journal on Matrix Analysis and Applications , 41(2), pp. 871-900, 2020 . P. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown, Scalability of High-Performance PDE Solvers , The International Journal on High Performance Computing Applications , 34(5), pp. 562-586, 2020 . G. Sosa Jones, J. J. Lee, and S. Rhebergen, A space-time hybridizable discontinuous Galerkin method for linear free-surface waves , Journal of Scientific Computing , (85) 61, 2020 . Also available as arXiv:1910.07315 2019 H. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall, Matrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT , Comp. Meth. Appl. Mech. Eng. , (359) 112658, 2019 . K. Suzuki, M. Fujisawa and M. Mikawa, Simulation Controlling Method for Generating Desired Water Caustics , 2019 International Conference on Cyberworlds (CW) , Kyoto, Japan, pp. 163-170, 2019 . D. White, Y. Choit, and J. Kudo, A dual mesh method with adaptivity for stress constrained topology optimization , Structural and Multidisciplinary Optimization , 61, pp. 749-762, 2019 . S. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White, Simple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design , Structural and Multidisciplinary Optimization , 60, pp. 1887-1920, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov, Towards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm , 27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque , Lecture Notes in Computational Science and Engineering, 127, pp. 285-302, 2019 . J. Cerveny, V. Dobrev, and Tz. Kolev, Non-Conforming Mesh Refinement For High-Order Finite Elements , SIAM Journal on Scientific Computing , 41(4):C367-C392, 2019 . D. White, W. Arrighi, J. Kudo, and S. Watts, Multiscale topology optimization using neural network surrogate models , Comp. Meth. Appl. Mech. Eng. , 346, pp.1118-1135, 2019 . V. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski, Algebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning , SIAM Journal on Scientific Computing , 41(3):B425-B447, 2019 . D. White, and A. Voronin, A computational study of symmetry and well-posedness of structural topology optimization , Structural and Multidisciplinary Optimization , 59(3), pp. 759-766, 2019 . T. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey, An Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes , Nuclear Science and Engineering , 193(7):746-759, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, The Target-Matrix Optimization Paradigm For High-Order Meshes , SIAM Journal on Scientific Computing , 41(1):B50-B68, 2019 . K. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen, Analysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains , SIAM Journal on Numerical Analysis , 57(4), pp. 1677-1696, 2019 . T. L. Horvath and S. Rhebergen, A locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains , International Journal for Numerical Methods in Fluids , 89(12):519-532, 2019 . R. Li, Y. Xi, L. Erlandson, and Y. Saad, The Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software , SIAM Journal on Scientific Computing , 41(4), pp. C393-C415, 2019 . 2018 H. Auten, The High Value of Open Source Software , Science & Technology Review , January/February 2018, pp. 5-11, 2018 . R. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, High-Order Multi-Material ALE Hydrodynamics , SIAM Journal on Scientific Computing , 40(1), pp. B32-B58, 2018 . A. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev, A scalable preconditioner for a primal discontinuous Petrov-Galerkin method , SIAM Journal on Scientific Computing , 40(2), pp. A1187-A1203, 2018 . V. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov, Sequential limiting in continuous and discontinuous Galerkin methods for the Euler equations , Journal of Computational Physics , 356, pp. 372 - 390, 2018 . M. Reberol and B. L\u00e9vy, Computing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU , SIAM Journal on Scientific Computing , 40(1), pp. C131-C155, 2018 . A. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore, Stress estimation in reservoirs using an integrated inverse method , Computers & Geosciences , 114, pp. 30 - 40, 2018 . J. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski, The auxiliary space preconditioner for the de Rham complex , SIAM Journal on Numerical Analysis , 56(6), pp. 3196-3218, 2018 . D. A. White, M. Stowell, and D. A. Tortorelli, Topological optimization of structures using Fourier representations , Structural and Multidisciplinary Optimization , pp. 1-16, 2018 . S. Rhebergen and G. N. Wells, Preconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations , Journal of Scientific Computing , 77(3), pp. 1936-1501, 2018 . T. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey, An Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes , American Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA , 2018 . A. S\u00e1nchez-Villar and M. Merino, Advances in Wave-Plasma Modelling in ECR Thrusters , 2018 Space Propulsion Conference, May 14-18, Seville, Spain , 2018 . 2017 S. Osborn, P. S. Vassilevski, and U. Villa, A Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields , SIAM Journal on Scientific Computing , 39(5), pp. S543-S562, 2017 . R. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder, Multigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study , SIAM Journal on Scientific Computing , 39(5), pp. S298-S322, 2017 . T. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth, A Root-Node Based Algebraic Multigrid Method , SIAM Journal on Scientific Computing , 39(5), pp. S723-S756, 2017 . A. T. Barker, C. S. Lee, and P. S. Vassilevski, Spectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation , SIAM Journal on Scientific Computing , 39(5), pp. S323-S346, 2017 . V. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder, Two-level Convergence Theory For Multigrid Reduction In Time (MGRIT) , SIAM Journal on Scientific Computing , 39(5), pp. S501-S527, 2017 . R. E. Bank, P. S. Vassilevski, and L. T. Zikatanov, Arbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations , Journal of Computational and Applied Mathematics , 310, pp. 19-31, 2017 . S. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski, Scalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes , Numerical Linear Algebra with Applications , 25, pp. e2146, 2017 . J. H. Adler, I. Lashuk, and S. P. MacLachlan, Composite-grid multigrid for diffusion on the sphere , Numerical Linear Algebra with Applications , 25(1), pp. e2115, 2017 . S. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev, Balancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order , Domain Decomposition Methods in Science and Engineering XXIV , 2017 . M. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison, The ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman , ISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization , 2017 . J. Wright and S. Shiraiwa, Antenna to Core: A New Approach to RF Modelling , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . S. Shiraiwa, J. C. Wright, P. T. Bonoli, Tz. Kolev, and M. Stowell, RF wave simulation for cold edge plasmas using the MFEM library , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . C. Hofer, U. Langer, M. Neum\u00fcller, and I. Toulopoulos, Time-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems , RICAM-Report 2017-26 , 2017 . J. Billings, A. McCaskey, G. Vallee, and G. Watson, Will humans even write code in 2040 and what would that mean for extreme heterogeneity in computing? , arXiv:1712.00676 , 2017 . M. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski, Numerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach , SIAM Journal on Scientific Computing , 39(1), pp. B102-B137, 2017 . R. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov, High-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation , Journal of Computational Physics , 334, pp. 102-124, 2017 . R. Li and Y. Saad, Low-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners , SIAM Journal on Matrix Analysis and Applications , 38(3), pp. 807-828, 2017 . 2016 D. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski, Upscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method , SIAM Journal on Scientific Computing , 38(5), pp. A2912-A2933, 2016 . V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, Multi-material closure model for high-order finite element Lagrangian hydrodynamics , International Journal for Numerical Methods in Fluids , 82(10), pp. 689-706, 2016 . J. Guermond, B. Popov, and V. Tomov, Entropy-viscosity method for the single material Euler equations in Lagrangian frame , Computer Methods in Applied Mechanics and Engineering , 300, pp. 402 - 426, 2016 . M. Holec, J. Limpouch, R. Liska, and S. Weber, High-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics , International Journal for Numerical Methods in Fluids , 83(10), pp. 779-797, 2016 . Tz. V. Kolev, J. Xu, and Y. Zhu, Multilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients , Journal of Scientific Computing , 67(1), pp. 324--350, 2016 . M. Reberol and B. L\u00e9vy, Low-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes , CoRR , abs/1605.02626, 2016 . O. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev, Tuning the Coarse Space Construction in a Spectral AMG Solver , Procedia Computer Science , 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA, 2016 . J. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev, Data-Driven Performance Modeling of Linear Solvers for Sparse Matrices , 2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS) , 2016 . 2015 and earlier D. Osei-Kuffuor, R. Li, and Y. Saad, Matrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning , SIAM Journal on Scientific Computing , 37(1), pp. A391-A419, 2015 . R. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben, Monotonicity in high-order curvilinear finite element ALE remap , Int. J. Numer. Meth. Fluids , 77(5), pp. 249-273, 2014 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics , J. Comp. Phys. , (257B), pp. 1062-1080, 2014 . P. Vassilevski and U. Villa, A mixed formulation for the Brinkman problem , SIAM Journal on Numerical Analysis , 52-1, pp. 258-281, 2014 . J. H. Adler and P. S. Vassilevski, Error Analysis for Constrained First-Order System Least-Squares Finite-Element Methods , SIAM Journal on Scientific Computing , 36(3), pp. A1071-A1088, 2014 . A. Aposporidis, P. S. Vassilevski, and A. Veneziani, Multigrid preconditioning of the non-regularized augmented Bingham fluid problem , ETNA. Electronic Transactions on Numerical Analysis , 41, 2014 . P. S. Vassilevski and U. M. Yang, Reducing communication in algebraic multigrid using additive variants , Numerical Linear Algebra with Applications , 21(2), pp. 275-296, 2014 . T. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra, A Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU , 2014 IEEE 28th International Parallel and Distributed Processing Symposium , May 2014 . P. Vassilevski and U. Villa, A block-diagonal algebraic multigrid preconditioner for the Brinkman problem , SIAM Journal on Scientific Computing , 35-5, pp. S3-S17, 2013 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics , Computers & Fluids , pp. 58-69, 2013 . D. Kalchev, C. Ketelsen, and P. S. Vassilevski, Two-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients , SIAM Journal on Scientific Computing , 35(6), pp. B1215-B1234, 2013 . P. D'Ambra and P. S. Vassilevski, Adaptive AMG with coarsening based on compatible weighted matching , Computing and Visualization in Science , 16(2), pp. 59--76, 2013 . T. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till, Preserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion , International Conference on Mathematics and Computational Methods Applied to Nuclear Science & Engineering , 2013 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG solver for H(div) problems , SIAM Journal on Scientific Computing , 34, pp. A3079-A3098, 2012 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for Lagrangian hydrodynamics , SIAM Journal on Scientific Computing , 34, pp. B606-B641, 2012 . I. Lashuk and P.Vassilevski, Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties , Numerical Linear Algebra with Applications , 19, pp. 414-426, 2012 . D. Kalchev, Adaptive algebraic multigrid for finite element elliptic equations with random coefficients , LLNL Tech. Report , LLNL-TR-553254, 2012 . A. Aposporidis, P. Vassilevski, and A. Veneziani, A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables , LLNL Tech. Report , LLNL-JRNL-600372, 2012 . P. Knupp, Introducing the target-matrix paradigm for mesh optimization by node movement , Engineering with Computers , 28(4), pp. 419--429, 2012 . T. A. Brunner, Mulard: A Multigroup Thermal Radiation Diffusion Mini-Application , DOE Exascale Research Conference, Portland, Oregon , 2012 . A. Baker, R. Falgout, T. Kolev, and U. Yang, Multigrid smoothers for ultra-parallel computing , SIAM Journal on Scientific Computing , 33(5), pp. 2864-2887, 2011 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, Curvilinear finite elements for Lagrangian hydrodynamics , Int. J. Numer. Meth. Fluids , 65, pp. 1295-1310, 2011 . V. Dobrev, J.-L. Guermond, and B. Popov, Surface reconstruction and image enhancement via L1-minimization , SIAM Journal on Scientific Computing , 32 (3), pp. 1591-1616, 2010 . J. Brannick and R. Falgout, Compatible relaxation and coarsening in algebraic multigrid , SIAM Journal on Scientific Computing , 32, pp. 1393-1416, 2010 . A. Baker, Tz. Kolev, and U. M. Yang, Improving algebraic multigrid interpolation operators for linear elasticity problems , Numerical Linear Algebra with Applications , 17, pp. 495-517, 2010 . U. M. Yang, On long-range interpolation operators for aggressive coarsening , Numerical Linear Algebra with Applications , 17, pp. 453-472, 2010 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG for H(curl) problems , Journal of Computational Mathematics , 27, pp. 604-623, 2009 . Tz. V. Kolev and R. N. Rieben, A tensor artificial viscosity using a finite element approach , Journal of Computational Physics , 228(22), pp. 8336 - 8366, 2009 . A. Baker, E. Jessup, and Tz. Kolev, A simple strategy for varying the restart parameter in GMRES(m) , J. Comp. Appl. Math. , 230, pp. 751-761, 2009 . Tz. Kolev, J. Pasciak, and P. Vassilevski, H(curl) auxiliary mesh preconditioning , Numerical Linear Algebra with Applications , 15, pp. 455-471, 2008 . H. De Sterck, R. Falgout, J. Nolting, and U. M. Yang, Distance-two interpolation for parallel algebraic multigrid , Numerical Linear Algebra with Applications , 15, pp. 115-139, 2008 . V. Dobrev, R. Lazarov, and L. Zikatanov, Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, 2008 . D. Alber and L. Olson, Parallel coarse grid selection , Numerical Linear Algebra with Applications , 14, pp. 611-643, 2007 . V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations , Numerical Linear Algebra with Applications , 13 (9), pp. 753-770, 2006 . Tz. Kolev and P. Vassilevski, AMG by element agglomeration and constrained energy minimization interpolation , Numerical Linear Algebra with Applications , 13, pp. 771-788, 2006 . J. Bramble, Tz. Kolev, and J. Pasciak, A least-squares approximation method for the time-harmonic Maxwell equations , Journal of Numerical Mathematics , 13(4), pp. 237-263, 2005 . P. Vassilevski, Sparse matrix element topology with application to AMG(e) and preconditioning , Numerical Linear Algebra with Applications , 9, pp. 429--444, 2002 . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Publications"},{"location":"publications/#publications","text":"","title":"Publications"},{"location":"publications/#google-scholar-citations","text":"Recent All time","title":"Google Scholar Citations"},{"location":"publications/#selected-publications","text":"","title":"Selected Publications"},{"location":"publications/#2021","text":"Tz. Kolev and W. Pazner, Conservative and accurate solution transfer between high-order and low-order refined finite element spaces , in review , 2021 . J. Yang, T. Dzanic, B. Petersen, J. Kudo, K. Mittal, V. Tomov, J.-S. Camier, T. Zhao, H. Zha, Tz. Kolev, R. Anderson, D. Faissol, Reinforcement Learning for Adaptive Mesh Refinement , in review , 2021 . W. Pazner and Tz. Kolev, Uniform subspace correction preconditioners for discontinuous Galerkin methods with hp -refinement , in review , 2021 . W. Pazner, Sparse invariant domain preserving discontinuous Galerkin methods with subcell convex limiting , in review , 2021 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, hr -adaptivity for nonconforming high-order meshes with the target matrix optimization paradigm , in review , 2021 . Also available as arXiv:2010.02166 . N. Whitman, T. Palmer, P. Greaney, S. Hosseini, D. Burkes, and D. Senor, Gray Phonon Transport Prediction of Thermal Conductivity in Lithium Aluminate with Higher-Order Finite Elements on Meshes with Curved Surfaces , Journal of Computational and Theoretical Transport , 2021 . H. Hajduk, Monolithic convex limiting in discontinuous Galerkin discretizations of hyperbolic conservation laws , Computers & Mathematics with Applications , (87) 120-138, 2021 . Also available as arXiv:2007.01212 . J. Nikl, I. G\u00f6thel, M. Kucha\u0159\u00edk, S. Weber, and M. Bussmann, Implicit reduced Vlasov-Fokker-Planck-Maxwell model based on high-order mixed elements , Journal of Computational Physics , (434) 110214, 2021 .","title":"2021"},{"location":"publications/#2020","text":"N. Beams, A. Abdelfattah, S. Tomov, J. Dongarra, T. Kolev and Y. Dudouit, High-Order Finite Element Method using Standard and Device-Level Batch GEMM on GPUs , IEEE/ACM 11th ScalA Workshop , 53-60, 2020 . A. Barker and Tz. Kolev, Matrix-free preconditioning for high-order H(curl) discretizations , Numerical Linear Algebra with Applications , 28(2) e2348, 2020 . D. Kuzmin and M. Quezada de Luna, Entropy conservation property and entropy stabilization of high-order continuous Galerkin approximations to scalar conservation laws , Computers & Fluids , (213) 104742, 2020 . A. Sandu, V. Tomov, L. Cervena, and Tz. Kolev, Conservative High-Order Time Integration for Lagrangian Hydrodynamics , SIAM Journal on Scientific Computing , 43(1), A221-A241, 2020 . B. S. Southworth, M. Holec, and T. Haut. Diffusion synthetic acceleration for heterogeneous domains, compatible with voids , Nuclear Science and Engineering , 195(2), 119-136, 2020 . T. Haut, B. Southworth, P. Maginot, V. Tomov, Diffusion Synthetic Acceleration Preconditioning for Discontinuous Galerkin Discretizations of SN Transport on High-Order Curved Meshes , SIAM Journal on Scientific Computing , 42(5), B1271-B1301, 2020 . R. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerveny V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, W. Pazner, M. Stowell, V. Tomov, I. Akkerman, J. Dahm, D. Medina, and S. Zampini, MFEM: A Modular Finite Element Library , Computers & Mathematics with Applications , (81) 42-74, 2020 . Also available as arXiv:1911.09220 . R. Li and C. Zhang, Efficient Parallel Implementations of Sparse Triangular Solves for GPU Architectures , Proceedings of the 2020 SIAM Conference on Parallel Processing for Scientific Computing , 2020 . W. Pazner, Efficient low-order refined preconditioners for high-order matrix-free continuous and discontinuous Galerkin methods , SIAM Journal on Scientific Computing , 42(5), pp. A3055-A3083, 2020 . B. Yee, S. Olivier, T. Haut, M. Holec, V. Tomov, P. Maginot, A Quadratic Programming Flux Correction Method for High-Order DG Discretizations of SN Transport , Journal of Computational Physics , (419) 109696, 2020 . T. L. Horvath and S. Rhebergen, An exactly mass conserving space-time embedded-hybridized discontinuous Galerkin method for the Navier-Stokes equations on moving domains , Journal of Computational Physics , (417) 109577, 2020 . S. Rhebergen and G. N. Wells, An embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations , Computer Methods in Applied Mechanics and Engineering , (358) 112619, 2020 . P. Bello-Maldonado, Tz. Kolev, R. Rieben, and V. Tomov, A Matrix-Free Hyperviscosity Formulation for High-Order ALE Hydrodynamics , Computers & Fluids , (205) 104577, 2020 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, R. Rieben, and V. Tomov, Simulation-Driven Optimization of High-Order Meshes in ALE Hydrodynamics , Computers & Fluids , (208) 104602, 2020 . H. Hajduk, D. Kuzmin, Tz. Kolev, V. Tomov, I. Tomas, and J. Shadid, Matrix-free subcell residual distribution for Bernstein finite elements: Monolithic limiting , Computers & Fluids , (200) 104451, 2020 . M. Franco, J.-S. Camier, J. Andrej, and W. Pazner, High-order matrix-free incompressible flow solvers with GPU acceleration and low-order refined preconditioners , Computers & Fluids , (203) 104541, 2020 . S. Friedhoff and B. S. Southworth, On \"Optimal\" h-independent convergence of Parareal and multigrid-reduction-in-time using Runge-Kutta time integration , Numerical Linear Algebra with Applications , e2301, 2020 . B. S. Southworth, A. A. Sivas, and S. Rhebergen, On fixed-point, Krylov, and 2x2 block preconditioners for nonsymmetric problems , SIAM Journal on Matrix Analysis and Applications , 41(2), pp. 871-900, 2020 . P. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown, Scalability of High-Performance PDE Solvers , The International Journal on High Performance Computing Applications , 34(5), pp. 562-586, 2020 . G. Sosa Jones, J. J. Lee, and S. Rhebergen, A space-time hybridizable discontinuous Galerkin method for linear free-surface waves , Journal of Scientific Computing , (85) 61, 2020 . Also available as arXiv:1910.07315","title":"2020"},{"location":"publications/#2019","text":"H. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall, Matrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT , Comp. Meth. Appl. Mech. Eng. , (359) 112658, 2019 . K. Suzuki, M. Fujisawa and M. Mikawa, Simulation Controlling Method for Generating Desired Water Caustics , 2019 International Conference on Cyberworlds (CW) , Kyoto, Japan, pp. 163-170, 2019 . D. White, Y. Choit, and J. Kudo, A dual mesh method with adaptivity for stress constrained topology optimization , Structural and Multidisciplinary Optimization , 61, pp. 749-762, 2019 . S. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White, Simple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design , Structural and Multidisciplinary Optimization , 60, pp. 1887-1920, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov, Towards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm , 27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque , Lecture Notes in Computational Science and Engineering, 127, pp. 285-302, 2019 . J. Cerveny, V. Dobrev, and Tz. Kolev, Non-Conforming Mesh Refinement For High-Order Finite Elements , SIAM Journal on Scientific Computing , 41(4):C367-C392, 2019 . D. White, W. Arrighi, J. Kudo, and S. Watts, Multiscale topology optimization using neural network surrogate models , Comp. Meth. Appl. Mech. Eng. , 346, pp.1118-1135, 2019 . V. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski, Algebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning , SIAM Journal on Scientific Computing , 41(3):B425-B447, 2019 . D. White, and A. Voronin, A computational study of symmetry and well-posedness of structural topology optimization , Structural and Multidisciplinary Optimization , 59(3), pp. 759-766, 2019 . T. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey, An Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes , Nuclear Science and Engineering , 193(7):746-759, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, The Target-Matrix Optimization Paradigm For High-Order Meshes , SIAM Journal on Scientific Computing , 41(1):B50-B68, 2019 . K. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen, Analysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains , SIAM Journal on Numerical Analysis , 57(4), pp. 1677-1696, 2019 . T. L. Horvath and S. Rhebergen, A locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains , International Journal for Numerical Methods in Fluids , 89(12):519-532, 2019 . R. Li, Y. Xi, L. Erlandson, and Y. Saad, The Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software , SIAM Journal on Scientific Computing , 41(4), pp. C393-C415, 2019 .","title":"2019"},{"location":"publications/#2018","text":"H. Auten, The High Value of Open Source Software , Science & Technology Review , January/February 2018, pp. 5-11, 2018 . R. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, High-Order Multi-Material ALE Hydrodynamics , SIAM Journal on Scientific Computing , 40(1), pp. B32-B58, 2018 . A. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev, A scalable preconditioner for a primal discontinuous Petrov-Galerkin method , SIAM Journal on Scientific Computing , 40(2), pp. A1187-A1203, 2018 . V. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov, Sequential limiting in continuous and discontinuous Galerkin methods for the Euler equations , Journal of Computational Physics , 356, pp. 372 - 390, 2018 . M. Reberol and B. L\u00e9vy, Computing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU , SIAM Journal on Scientific Computing , 40(1), pp. C131-C155, 2018 . A. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore, Stress estimation in reservoirs using an integrated inverse method , Computers & Geosciences , 114, pp. 30 - 40, 2018 . J. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski, The auxiliary space preconditioner for the de Rham complex , SIAM Journal on Numerical Analysis , 56(6), pp. 3196-3218, 2018 . D. A. White, M. Stowell, and D. A. Tortorelli, Topological optimization of structures using Fourier representations , Structural and Multidisciplinary Optimization , pp. 1-16, 2018 . S. Rhebergen and G. N. Wells, Preconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations , Journal of Scientific Computing , 77(3), pp. 1936-1501, 2018 . T. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey, An Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes , American Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA , 2018 . A. S\u00e1nchez-Villar and M. Merino, Advances in Wave-Plasma Modelling in ECR Thrusters , 2018 Space Propulsion Conference, May 14-18, Seville, Spain , 2018 .","title":"2018"},{"location":"publications/#2017","text":"S. Osborn, P. S. Vassilevski, and U. Villa, A Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields , SIAM Journal on Scientific Computing , 39(5), pp. S543-S562, 2017 . R. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder, Multigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study , SIAM Journal on Scientific Computing , 39(5), pp. S298-S322, 2017 . T. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth, A Root-Node Based Algebraic Multigrid Method , SIAM Journal on Scientific Computing , 39(5), pp. S723-S756, 2017 . A. T. Barker, C. S. Lee, and P. S. Vassilevski, Spectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation , SIAM Journal on Scientific Computing , 39(5), pp. S323-S346, 2017 . V. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder, Two-level Convergence Theory For Multigrid Reduction In Time (MGRIT) , SIAM Journal on Scientific Computing , 39(5), pp. S501-S527, 2017 . R. E. Bank, P. S. Vassilevski, and L. T. Zikatanov, Arbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations , Journal of Computational and Applied Mathematics , 310, pp. 19-31, 2017 . S. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski, Scalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes , Numerical Linear Algebra with Applications , 25, pp. e2146, 2017 . J. H. Adler, I. Lashuk, and S. P. MacLachlan, Composite-grid multigrid for diffusion on the sphere , Numerical Linear Algebra with Applications , 25(1), pp. e2115, 2017 . S. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev, Balancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order , Domain Decomposition Methods in Science and Engineering XXIV , 2017 . M. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison, The ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman , ISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization , 2017 . J. Wright and S. Shiraiwa, Antenna to Core: A New Approach to RF Modelling , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . S. Shiraiwa, J. C. Wright, P. T. Bonoli, Tz. Kolev, and M. Stowell, RF wave simulation for cold edge plasmas using the MFEM library , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . C. Hofer, U. Langer, M. Neum\u00fcller, and I. Toulopoulos, Time-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems , RICAM-Report 2017-26 , 2017 . J. Billings, A. McCaskey, G. Vallee, and G. Watson, Will humans even write code in 2040 and what would that mean for extreme heterogeneity in computing? , arXiv:1712.00676 , 2017 . M. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski, Numerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach , SIAM Journal on Scientific Computing , 39(1), pp. B102-B137, 2017 . R. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov, High-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation , Journal of Computational Physics , 334, pp. 102-124, 2017 . R. Li and Y. Saad, Low-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners , SIAM Journal on Matrix Analysis and Applications , 38(3), pp. 807-828, 2017 .","title":"2017"},{"location":"publications/#2016","text":"D. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski, Upscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method , SIAM Journal on Scientific Computing , 38(5), pp. A2912-A2933, 2016 . V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, Multi-material closure model for high-order finite element Lagrangian hydrodynamics , International Journal for Numerical Methods in Fluids , 82(10), pp. 689-706, 2016 . J. Guermond, B. Popov, and V. Tomov, Entropy-viscosity method for the single material Euler equations in Lagrangian frame , Computer Methods in Applied Mechanics and Engineering , 300, pp. 402 - 426, 2016 . M. Holec, J. Limpouch, R. Liska, and S. Weber, High-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics , International Journal for Numerical Methods in Fluids , 83(10), pp. 779-797, 2016 . Tz. V. Kolev, J. Xu, and Y. Zhu, Multilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients , Journal of Scientific Computing , 67(1), pp. 324--350, 2016 . M. Reberol and B. L\u00e9vy, Low-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes , CoRR , abs/1605.02626, 2016 . O. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev, Tuning the Coarse Space Construction in a Spectral AMG Solver , Procedia Computer Science , 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA, 2016 . J. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev, Data-Driven Performance Modeling of Linear Solvers for Sparse Matrices , 2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS) , 2016 .","title":"2016"},{"location":"publications/#2015-and-earlier","text":"D. Osei-Kuffuor, R. Li, and Y. Saad, Matrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning , SIAM Journal on Scientific Computing , 37(1), pp. A391-A419, 2015 . R. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben, Monotonicity in high-order curvilinear finite element ALE remap , Int. J. Numer. Meth. Fluids , 77(5), pp. 249-273, 2014 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics , J. Comp. Phys. , (257B), pp. 1062-1080, 2014 . P. Vassilevski and U. Villa, A mixed formulation for the Brinkman problem , SIAM Journal on Numerical Analysis , 52-1, pp. 258-281, 2014 . J. H. Adler and P. S. Vassilevski, Error Analysis for Constrained First-Order System Least-Squares Finite-Element Methods , SIAM Journal on Scientific Computing , 36(3), pp. A1071-A1088, 2014 . A. Aposporidis, P. S. Vassilevski, and A. Veneziani, Multigrid preconditioning of the non-regularized augmented Bingham fluid problem , ETNA. Electronic Transactions on Numerical Analysis , 41, 2014 . P. S. Vassilevski and U. M. Yang, Reducing communication in algebraic multigrid using additive variants , Numerical Linear Algebra with Applications , 21(2), pp. 275-296, 2014 . T. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra, A Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU , 2014 IEEE 28th International Parallel and Distributed Processing Symposium , May 2014 . P. Vassilevski and U. Villa, A block-diagonal algebraic multigrid preconditioner for the Brinkman problem , SIAM Journal on Scientific Computing , 35-5, pp. S3-S17, 2013 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics , Computers & Fluids , pp. 58-69, 2013 . D. Kalchev, C. Ketelsen, and P. S. Vassilevski, Two-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients , SIAM Journal on Scientific Computing , 35(6), pp. B1215-B1234, 2013 . P. D'Ambra and P. S. Vassilevski, Adaptive AMG with coarsening based on compatible weighted matching , Computing and Visualization in Science , 16(2), pp. 59--76, 2013 . T. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till, Preserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion , International Conference on Mathematics and Computational Methods Applied to Nuclear Science & Engineering , 2013 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG solver for H(div) problems , SIAM Journal on Scientific Computing , 34, pp. A3079-A3098, 2012 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for Lagrangian hydrodynamics , SIAM Journal on Scientific Computing , 34, pp. B606-B641, 2012 . I. Lashuk and P.Vassilevski, Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties , Numerical Linear Algebra with Applications , 19, pp. 414-426, 2012 . D. Kalchev, Adaptive algebraic multigrid for finite element elliptic equations with random coefficients , LLNL Tech. Report , LLNL-TR-553254, 2012 . A. Aposporidis, P. Vassilevski, and A. Veneziani, A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables , LLNL Tech. Report , LLNL-JRNL-600372, 2012 . P. Knupp, Introducing the target-matrix paradigm for mesh optimization by node movement , Engineering with Computers , 28(4), pp. 419--429, 2012 . T. A. Brunner, Mulard: A Multigroup Thermal Radiation Diffusion Mini-Application , DOE Exascale Research Conference, Portland, Oregon , 2012 . A. Baker, R. Falgout, T. Kolev, and U. Yang, Multigrid smoothers for ultra-parallel computing , SIAM Journal on Scientific Computing , 33(5), pp. 2864-2887, 2011 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, Curvilinear finite elements for Lagrangian hydrodynamics , Int. J. Numer. Meth. Fluids , 65, pp. 1295-1310, 2011 . V. Dobrev, J.-L. Guermond, and B. Popov, Surface reconstruction and image enhancement via L1-minimization , SIAM Journal on Scientific Computing , 32 (3), pp. 1591-1616, 2010 . J. Brannick and R. Falgout, Compatible relaxation and coarsening in algebraic multigrid , SIAM Journal on Scientific Computing , 32, pp. 1393-1416, 2010 . A. Baker, Tz. Kolev, and U. M. Yang, Improving algebraic multigrid interpolation operators for linear elasticity problems , Numerical Linear Algebra with Applications , 17, pp. 495-517, 2010 . U. M. Yang, On long-range interpolation operators for aggressive coarsening , Numerical Linear Algebra with Applications , 17, pp. 453-472, 2010 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG for H(curl) problems , Journal of Computational Mathematics , 27, pp. 604-623, 2009 . Tz. V. Kolev and R. N. Rieben, A tensor artificial viscosity using a finite element approach , Journal of Computational Physics , 228(22), pp. 8336 - 8366, 2009 . A. Baker, E. Jessup, and Tz. Kolev, A simple strategy for varying the restart parameter in GMRES(m) , J. Comp. Appl. Math. , 230, pp. 751-761, 2009 . Tz. Kolev, J. Pasciak, and P. Vassilevski, H(curl) auxiliary mesh preconditioning , Numerical Linear Algebra with Applications , 15, pp. 455-471, 2008 . H. De Sterck, R. Falgout, J. Nolting, and U. M. Yang, Distance-two interpolation for parallel algebraic multigrid , Numerical Linear Algebra with Applications , 15, pp. 115-139, 2008 . V. Dobrev, R. Lazarov, and L. Zikatanov, Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, 2008 . D. Alber and L. Olson, Parallel coarse grid selection , Numerical Linear Algebra with Applications , 14, pp. 611-643, 2007 . V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations , Numerical Linear Algebra with Applications , 13 (9), pp. 753-770, 2006 . Tz. Kolev and P. Vassilevski, AMG by element agglomeration and constrained energy minimization interpolation , Numerical Linear Algebra with Applications , 13, pp. 771-788, 2006 . J. Bramble, Tz. Kolev, and J. Pasciak, A least-squares approximation method for the time-harmonic Maxwell equations , Journal of Numerical Mathematics , 13(4), pp. 237-263, 2005 . P. Vassilevski, Sparse matrix element topology with application to AMG(e) and preconditioning , Numerical Linear Algebra with Applications , 9, pp. 429--444, 2002 . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"2015 and earlier"},{"location":"serial-tutorial/","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Serial Tutorial Summary This tutorial illustrates the building and sample use of the following MFEM serial example codes: Example 1 Example 2 Example 3 An interactive documentation of all example codes is available here . Building Follow the serial instructions to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the serial example codes, type make in MFEM's examples directory: ~/mfem/examples> make g++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem g++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem g++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem g++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem g++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem g++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem g++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem g++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem g++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem g++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem Example 1 This example code demonstrates the use of MFEM to define a simple linear finite element discretization of the Laplace problem $-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements): ~/mfem/examples> ex1 -m ../data/star.mesh Iteration : 0 (B r, r) = 0.00111712 Iteration : 1 (B r, r) = 0.00674088 Iteration : 2 (B r, r) = 0.0123008 ... Iteration : 88 (B r, r) = 5.28955e-15 Iteration : 89 (B r, r) = 1.99155e-15 Iteration : 90 (B r, r) = 9.91309e-16 Average reduction factor = 0.857127 If a GLVis server is running, the computed finite element solution will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . Pressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines: This example saves two files called refined.mesh and sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with glvis -m refined.mesh -g sol.gf as discussed here . Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g., ~/mfem/examples> ex1 -m ../data/fichera-q2.vtk Iteration : 0 (B r, r) = 0.0235996 Iteration : 1 (B r, r) = 0.0476694 Iteration : 2 (B r, r) = 0.0200109 ... Iteration : 27 (B r, r) = 7.77888e-14 Iteration : 28 (B r, r) = 2.36255e-14 Iteration : 29 (B r, r) = 8.56679e-15 Average reduction factor = 0.610261 The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \". Example 2 This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below: +----------+----------+ boundary --->| material | material |<--- boundary attribute 1 | 1 | 2 | attribute 2 (fixed) +----------+----------+ (pull down) The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options: ~/mfem/examples> ex2 -m ../data/beam-quad.mesh -o 2 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 1.88755e-06 Iteration : 1 (B r, r) = 8.2357e-07 Iteration : 2 (B r, r) = 9.9098e-07 ... Iteration : 498 (B r, r) = 2.78279e-11 Iteration : 499 (B r, r) = 3.75298e-11 Iteration : 500 (B r, r) = 4.95682e-11 PCG: No convergence! (B r_0, r_0) = 1.88755e-06 (B r_N, r_N) = 4.95682e-11 Number of PCG iterations: 500 Average reduction factor = 0.989508 The output shows the (curved) displaced mesh together with the inverse displacement vector field: The above plot can be alternatively produced with: glvis -m displaced.mesh -g sol.gf -k \"RfjliiiiimmAbb\" Example 2 also works in 3D: ~/mfem/examples> ex2 -m ../data/beam-tet.mesh -o 3 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 2.7147e-06 Iteration : 1 (B r, r) = 1.95756e-06 Iteration : 2 (B r, r) = 2.24159e-06 ... Iteration : 426 (B r, r) = 3.37563e-14 Iteration : 427 (B r, r) = 3.06198e-14 Iteration : 428 (B r, r) = 2.5706e-14 Average reduction factor = 0.978648 One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse: Example 3 This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh: ~/mfem/examples> ex3 -m ../data/fichera.mesh Iteration : 0 (B r, r) = 121.209 Iteration : 1 (B r, r) = 21.1137 Iteration : 2 (B r, r) = 12.6503 ... Iteration : 149 (B r, r) = 2.40571e-10 Iteration : 150 (B r, r) = 1.39788e-10 Iteration : 151 (B r, r) = 9.43635e-11 Average reduction factor = 0.911811 || E_h - E ||_{L^2} = 0.00976655 To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ): Curved meshes are also supported: ~/mfem/examples> ex3 -m ../data/fichera-q3.mesh Iteration : 0 (B r, r) = 135.613 Iteration : 1 (B r, r) = 22.3785 Iteration : 2 (B r, r) = 12.5215 ... Iteration : 168 (B r, r) = 4.95911e-10 Iteration : 169 (B r, r) = 2.23499e-10 Iteration : 170 (B r, r) = 1.25714e-10 Average reduction factor = 0.921741 || E_h - E ||_{L^2} = 0.0821686 To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \": Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example: ~/mfem/examples> ex3 -m ../data/escher.mesh Iteration : 0 (B r, r) = 348.797 Iteration : 1 (B r, r) = 32.0699 Iteration : 2 (B r, r) = 14.902 ... Iteration : 159 (B r, r) = 4.16076e-10 Iteration : 160 (B r, r) = 3.50907e-10 Iteration : 161 (B r, r) = 3.22923e-10 Average reduction factor = 0.917548 || E_h - E ||_{L^2} = 0.36541 ~/mfem/examples> glvis -m refined.mesh -g sol.gf -gc 0 -k \"gooottF\" The discontinuity of the Nedelec functions is clearly seen in the above plot.","title":"Serial Tutorial"},{"location":"serial-tutorial/#serial-tutorial","text":"","title":"Serial Tutorial"},{"location":"serial-tutorial/#summary","text":"This tutorial illustrates the building and sample use of the following MFEM serial example codes: Example 1 Example 2 Example 3 An interactive documentation of all example codes is available here .","title":"Summary"},{"location":"serial-tutorial/#building","text":"Follow the serial instructions to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the serial example codes, type make in MFEM's examples directory: ~/mfem/examples> make g++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem g++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem g++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem g++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem g++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem g++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem g++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem g++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem g++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem g++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem","title":"Building"},{"location":"serial-tutorial/#example-1","text":"This example code demonstrates the use of MFEM to define a simple linear finite element discretization of the Laplace problem $-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements): ~/mfem/examples> ex1 -m ../data/star.mesh Iteration : 0 (B r, r) = 0.00111712 Iteration : 1 (B r, r) = 0.00674088 Iteration : 2 (B r, r) = 0.0123008 ... Iteration : 88 (B r, r) = 5.28955e-15 Iteration : 89 (B r, r) = 1.99155e-15 Iteration : 90 (B r, r) = 9.91309e-16 Average reduction factor = 0.857127 If a GLVis server is running, the computed finite element solution will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . Pressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines: This example saves two files called refined.mesh and sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with glvis -m refined.mesh -g sol.gf as discussed here . Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g., ~/mfem/examples> ex1 -m ../data/fichera-q2.vtk Iteration : 0 (B r, r) = 0.0235996 Iteration : 1 (B r, r) = 0.0476694 Iteration : 2 (B r, r) = 0.0200109 ... Iteration : 27 (B r, r) = 7.77888e-14 Iteration : 28 (B r, r) = 2.36255e-14 Iteration : 29 (B r, r) = 8.56679e-15 Average reduction factor = 0.610261 The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \".","title":"Example 1"},{"location":"serial-tutorial/#example-2","text":"This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below: +----------+----------+ boundary --->| material | material |<--- boundary attribute 1 | 1 | 2 | attribute 2 (fixed) +----------+----------+ (pull down) The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options: ~/mfem/examples> ex2 -m ../data/beam-quad.mesh -o 2 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 1.88755e-06 Iteration : 1 (B r, r) = 8.2357e-07 Iteration : 2 (B r, r) = 9.9098e-07 ... Iteration : 498 (B r, r) = 2.78279e-11 Iteration : 499 (B r, r) = 3.75298e-11 Iteration : 500 (B r, r) = 4.95682e-11 PCG: No convergence! (B r_0, r_0) = 1.88755e-06 (B r_N, r_N) = 4.95682e-11 Number of PCG iterations: 500 Average reduction factor = 0.989508 The output shows the (curved) displaced mesh together with the inverse displacement vector field: The above plot can be alternatively produced with: glvis -m displaced.mesh -g sol.gf -k \"RfjliiiiimmAbb\" Example 2 also works in 3D: ~/mfem/examples> ex2 -m ../data/beam-tet.mesh -o 3 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 2.7147e-06 Iteration : 1 (B r, r) = 1.95756e-06 Iteration : 2 (B r, r) = 2.24159e-06 ... Iteration : 426 (B r, r) = 3.37563e-14 Iteration : 427 (B r, r) = 3.06198e-14 Iteration : 428 (B r, r) = 2.5706e-14 Average reduction factor = 0.978648 One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse:","title":"Example 2"},{"location":"serial-tutorial/#example-3","text":"This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh: ~/mfem/examples> ex3 -m ../data/fichera.mesh Iteration : 0 (B r, r) = 121.209 Iteration : 1 (B r, r) = 21.1137 Iteration : 2 (B r, r) = 12.6503 ... Iteration : 149 (B r, r) = 2.40571e-10 Iteration : 150 (B r, r) = 1.39788e-10 Iteration : 151 (B r, r) = 9.43635e-11 Average reduction factor = 0.911811 || E_h - E ||_{L^2} = 0.00976655 To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ): Curved meshes are also supported: ~/mfem/examples> ex3 -m ../data/fichera-q3.mesh Iteration : 0 (B r, r) = 135.613 Iteration : 1 (B r, r) = 22.3785 Iteration : 2 (B r, r) = 12.5215 ... Iteration : 168 (B r, r) = 4.95911e-10 Iteration : 169 (B r, r) = 2.23499e-10 Iteration : 170 (B r, r) = 1.25714e-10 Average reduction factor = 0.921741 || E_h - E ||_{L^2} = 0.0821686 To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \": Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example: ~/mfem/examples> ex3 -m ../data/escher.mesh Iteration : 0 (B r, r) = 348.797 Iteration : 1 (B r, r) = 32.0699 Iteration : 2 (B r, r) = 14.902 ... Iteration : 159 (B r, r) = 4.16076e-10 Iteration : 160 (B r, r) = 3.50907e-10 Iteration : 161 (B r, r) = 3.22923e-10 Average reduction factor = 0.917548 || E_h - E ||_{L^2} = 0.36541 ~/mfem/examples> glvis -m refined.mesh -g sol.gf -gc 0 -k \"gooottF\" The discontinuity of the Nedelec functions is clearly seen in the above plot.","title":"Example 3"},{"location":"tools/","text":"Tools This page provides a brief description of several useful tool programs that are distributed in the MFEM's miniapps/tools directory. General Tools Display Basis The display-basis miniapp, found under miniapps/tools , visualizes various types of finite element basis functions on a single mesh element in 1D, 2D, and 3D. The element type, basis type and order can be changed interactively. The mesh element is either the reference element, or a simple transformation of it. Low-Order Refined Transfer The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. DataCollection Tools Convert DC This tool, named convert-dc in the miniapps/tools subdirectory, demonstrates how to convert between MFEM's different concrete DataCollection options. Currently supported data collection type options: Nickname Full Class Name visit VisItDataCollection (default) sidre or sidre_hdf5 SidreDataCollection json ConduitDataCollection w/ protocol json conduit_json ConduitDataCollection w/ protocol conduit_json conduit_bin ConduitDataCollection w/ protocol conduit_bin hdf5 ConduitDataCollection w/ protocol hdf5 Load DC The load-dc miniapp, found in the miniapps/tools subdirectory, loads and visualizes (in GLVis) previously saved data using DataCollection sub-classes, see e.g. Example 5/5p. Currently, only the VisItDataCollection class is supported. Get Values The get-values miniapp, found in miniapps/tools , loads previously saved data using DataCollection sub-classes and outputs field values at a set of points. Currently, only the VisItDataCollection class is supported. # Number of fields 3 # Legend # \"Index\" \"Location\":2 \"pressure\":1 \"velocity\":2 2 1 2 # Number of points 6 0 0.0 0.8 0.717336 -0.716172 -0.696674 1 0.2 0.8 0.876045 -0.875874 -0.852278 2 0.4 0.8 1.06999 -1.07106 -1.03923 3 0.6 0.8 1.30719 -1.30931 -1.26903 4 0.8 0.8 1.59678 -1.59601 -1.54949 5 1.0 0.8 1.94995 -1.94853 -1.89371 Point locations can be specified on the command line using -p or within a data file whose name can be given with option -pf . The data file format is: number_of_points space_dimension x_0 y_0 ... x_1 y_1 ... etc. By default all available fields are evaluated. The list of fields can be reduced by specifying the desired field names with -fn . The -fn option takes a space separated list of field names surrounded by quotes. Field names containing spaces, such as \"Field 1\" and \"Field 2\", can be entered as: get-values -fn \"Field\\ 1 Field\\ 2\" By default the data is written to standard out. This can be overwritten with the -o [filename] option. The output format contains comments as well as sizing information to aid in subsequent processing. The bulk of the data consists of one line per point with a 0-based integer index followed by the point coordinates and then the field data. A legend, appearing before the bulk data, shows the order of the fields along with the number of values per field (for vector data). MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Tools"},{"location":"tools/#tools","text":"This page provides a brief description of several useful tool programs that are distributed in the MFEM's miniapps/tools directory.","title":"Tools"},{"location":"tools/#general-tools","text":"","title":"General Tools"},{"location":"tools/#display-basis","text":"The display-basis miniapp, found under miniapps/tools , visualizes various types of finite element basis functions on a single mesh element in 1D, 2D, and 3D. The element type, basis type and order can be changed interactively. The mesh element is either the reference element, or a simple transformation of it.","title":"Display Basis"},{"location":"tools/#low-order-refined-transfer","text":"The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space.","title":"Low-Order Refined Transfer"},{"location":"tools/#datacollection-tools","text":"","title":"DataCollection Tools"},{"location":"tools/#convert-dc","text":"This tool, named convert-dc in the miniapps/tools subdirectory, demonstrates how to convert between MFEM's different concrete DataCollection options. Currently supported data collection type options: Nickname Full Class Name visit VisItDataCollection (default) sidre or sidre_hdf5 SidreDataCollection json ConduitDataCollection w/ protocol json conduit_json ConduitDataCollection w/ protocol conduit_json conduit_bin ConduitDataCollection w/ protocol conduit_bin hdf5 ConduitDataCollection w/ protocol hdf5","title":"Convert DC"},{"location":"tools/#load-dc","text":"The load-dc miniapp, found in the miniapps/tools subdirectory, loads and visualizes (in GLVis) previously saved data using DataCollection sub-classes, see e.g. Example 5/5p. Currently, only the VisItDataCollection class is supported.","title":"Load DC"},{"location":"tools/#get-values","text":"The get-values miniapp, found in miniapps/tools , loads previously saved data using DataCollection sub-classes and outputs field values at a set of points. Currently, only the VisItDataCollection class is supported. # Number of fields 3 # Legend # \"Index\" \"Location\":2 \"pressure\":1 \"velocity\":2 2 1 2 # Number of points 6 0 0.0 0.8 0.717336 -0.716172 -0.696674 1 0.2 0.8 0.876045 -0.875874 -0.852278 2 0.4 0.8 1.06999 -1.07106 -1.03923 3 0.6 0.8 1.30719 -1.30931 -1.26903 4 0.8 0.8 1.59678 -1.59601 -1.54949 5 1.0 0.8 1.94995 -1.94853 -1.89371 Point locations can be specified on the command line using -p or within a data file whose name can be given with option -pf . The data file format is: number_of_points space_dimension x_0 y_0 ... x_1 y_1 ... etc. By default all available fields are evaluated. The list of fields can be reduced by specifying the desired field names with -fn . The -fn option takes a space separated list of field names surrounded by quotes. Field names containing spaces, such as \"Field 1\" and \"Field 2\", can be entered as: get-values -fn \"Field\\ 1 Field\\ 2\" By default the data is written to standard out. This can be overwritten with the -o [filename] option. The output format contains comments as well as sizing information to aid in subsequent processing. The bulk of the data consists of one line per point with a 0-based integer index followed by the point coordinates and then the field data. A legend, appearing before the bulk data, shows the order of the fields along with the number of values per field (for vector data). MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Get Values"},{"location":"toys/","text":"Toys Automata The automata miniapp implements a one dimensional elementary cellular automata as described in: Wolfram MathWorld . This miniapp shows a completely unnecessary use of the finite element method to simply display binary data (but it's fun to play with). The automata miniapp has only three options; -vis or -no-vis to enable or disable visualization, -ns which defines the number of steps to evolve the cellular automata, and -r to select the rule which is applied at each step. Rules for this type of cellular automata consist of a sequence of 8 bits which are normally passed as an integer 0-255. The rule defines how to update each cell based on the current values of that cell and its two nearest neighbors. Life The life miniapp implements Conway's Game of Life. A few simple starting positions are available as well as a random initial state. The game will terminate only if two successive iterations are identical. Users can control the size of the domain and the initial placement of simple objects like blinkers and gliders . Arbitrary patterns can be supplied through the --sketch-pad or -sp option. The sketch pad was used to produce the above image with the command line: life -nx 30 -sp '11 11 1 1 1 1 1 1 1 1 2 1 0 1 1 1 1 0 1 2 1 1 1 1 1 1 1 1' The values following -sp are the starting coordinates of the pattern followed by zeros or ones to indicate pixels that should be off or on, any twos indicate new lines in the pattern. Lissajous The lissajous miniapp generates two different Lissajous curves in 3D which appear to spin vertically and/or horizontally, even though the net motion is the same. Vertical Rotation Horizontal Rotation Based on the 2019 Illusion of the year \"Dual Axis Illusion\" by Frank Force, see Dual Axis Illusion . Mandel The mandel miniapp is a specialized version of the shaper miniapp which adapts a mesh to the Mandelbrot set. Both planar and surface meshes are supported. Mondrian The mondrian miniapp is a specialized version of the shaper miniapp that converts an input image to an AMR mesh. It allows the fast approximate meshing of any domain for which there is an image. The input image should be in 8-bit grayscale PGM format. You can use a number of image manipulation tools, such as GIMP (gimp.org) and ImageMagick's convert utility (imagemagick.org/script/convert.php) to convert your image to this format as a pre-processing step, e.g.: /usr/bin/convert australia.svg -compress none -depth 8 australia.pgm Rubik The rubik miniapp implements an interactive model of a Rubik's Cube\u2122 puzzle. The basic interactive command is of the form [xyz][1,2,3][0-3] which rotates, about the x, y, or z axis, a single tier, indicated by the first integer, by a number of increments, indicated by the final integer. Any manipulation of the cube can be accomplished with a sequence of these simple three character commands. Common commands: Command Action R Resets or re-paints the cube S or s Solve the cube starting from the top and working down r[0-9]+ Specific number of random moves p Print the current state of the cube to the screen q Quit Other commands: Command Action T Solve the top tier only M Solve the middle tier assuming the top has already been solved B Solve the bottom tier assuming the top and middle are done c Swap bottom tier corners in positions 0 and 1 t[0,1] Twist, in place, three of the bottom tier corners e[0,1] Permute three of the bottom tier edges f[2,4] Flip, in place, 2 or 4 of the bottom tier edges Snake The snake miniapp provides a light-hearted example of mesh manipulation and GLVis integration. The Rubik's Snake\u2122 a.k.a. Twist is a simple tool for experimenting with geometric shapes in 3D. It consists of 24 triangular prisms attached in a row so that neighboring wedges can rotate against each other but cannot be separated. An astonishing variety of different configurations can be reached. Thirteen pre-programmed configurations are available via the -c [0-12] command line option. Other configurations can be reached with the -u option. Each configuration must be 23 integers long corresponding to the 23 joints making up the Snake\u2122 puzzle. The values can be 0-3 indicating how far to rotate the joint in the clockwise direction when looking along the snake from the starting (lower) end. The values 0, 1, 2, and 3 correspond to angles of 0, 90, 180, and 270 degrees respectively.","title":"Toys"},{"location":"toys/#toys","text":"","title":"Toys"},{"location":"toys/#automata","text":"The automata miniapp implements a one dimensional elementary cellular automata as described in: Wolfram MathWorld . This miniapp shows a completely unnecessary use of the finite element method to simply display binary data (but it's fun to play with). The automata miniapp has only three options; -vis or -no-vis to enable or disable visualization, -ns which defines the number of steps to evolve the cellular automata, and -r to select the rule which is applied at each step. Rules for this type of cellular automata consist of a sequence of 8 bits which are normally passed as an integer 0-255. The rule defines how to update each cell based on the current values of that cell and its two nearest neighbors.","title":"Automata"},{"location":"toys/#life","text":"The life miniapp implements Conway's Game of Life. A few simple starting positions are available as well as a random initial state. The game will terminate only if two successive iterations are identical. Users can control the size of the domain and the initial placement of simple objects like blinkers and gliders . Arbitrary patterns can be supplied through the --sketch-pad or -sp option. The sketch pad was used to produce the above image with the command line: life -nx 30 -sp '11 11 1 1 1 1 1 1 1 1 2 1 0 1 1 1 1 0 1 2 1 1 1 1 1 1 1 1' The values following -sp are the starting coordinates of the pattern followed by zeros or ones to indicate pixels that should be off or on, any twos indicate new lines in the pattern.","title":"Life"},{"location":"toys/#lissajous","text":"The lissajous miniapp generates two different Lissajous curves in 3D which appear to spin vertically and/or horizontally, even though the net motion is the same. Vertical Rotation Horizontal Rotation Based on the 2019 Illusion of the year \"Dual Axis Illusion\" by Frank Force, see Dual Axis Illusion .","title":"Lissajous"},{"location":"toys/#mandel","text":"The mandel miniapp is a specialized version of the shaper miniapp which adapts a mesh to the Mandelbrot set. Both planar and surface meshes are supported.","title":"Mandel"},{"location":"toys/#mondrian","text":"The mondrian miniapp is a specialized version of the shaper miniapp that converts an input image to an AMR mesh. It allows the fast approximate meshing of any domain for which there is an image. The input image should be in 8-bit grayscale PGM format. You can use a number of image manipulation tools, such as GIMP (gimp.org) and ImageMagick's convert utility (imagemagick.org/script/convert.php) to convert your image to this format as a pre-processing step, e.g.: /usr/bin/convert australia.svg -compress none -depth 8 australia.pgm","title":"Mondrian"},{"location":"toys/#rubik","text":"The rubik miniapp implements an interactive model of a Rubik's Cube\u2122 puzzle. The basic interactive command is of the form [xyz][1,2,3][0-3] which rotates, about the x, y, or z axis, a single tier, indicated by the first integer, by a number of increments, indicated by the final integer. Any manipulation of the cube can be accomplished with a sequence of these simple three character commands. Common commands: Command Action R Resets or re-paints the cube S or s Solve the cube starting from the top and working down r[0-9]+ Specific number of random moves p Print the current state of the cube to the screen q Quit Other commands: Command Action T Solve the top tier only M Solve the middle tier assuming the top has already been solved B Solve the bottom tier assuming the top and middle are done c Swap bottom tier corners in positions 0 and 1 t[0,1] Twist, in place, three of the bottom tier corners e[0,1] Permute three of the bottom tier edges f[2,4] Flip, in place, 2 or 4 of the bottom tier edges","title":"Rubik"},{"location":"toys/#snake","text":"The snake miniapp provides a light-hearted example of mesh manipulation and GLVis integration. The Rubik's Snake\u2122 a.k.a. Twist is a simple tool for experimenting with geometric shapes in 3D. It consists of 24 triangular prisms attached in a row so that neighboring wedges can rotate against each other but cannot be separated. An astonishing variety of different configurations can be reached. Thirteen pre-programmed configurations are available via the -c [0-12] command line option. Other configurations can be reached with the -u option. Each configuration must be 23 integers long corresponding to the 23 joints making up the Snake\u2122 puzzle. The values can be 0-3 indicating how far to rotate the joint in the clockwise direction when looking along the snake from the starting (lower) end. The values 0, 1, 2, and 3 correspond to angles of 0, 90, 180, and 270 degrees respectively.","title":"Snake"},{"location":"tperformance/","text":"Tensor-Based Operator Assembly and Evaluation Overview The high performance (HPC) versions of the example codes in the miniapps/performance directory use a set of templated classes to efficiently implement the inner-most portion ($B^T D B$) of the fundamental finite element (FE) operator decomposition: We take advantage of the tensor-product structure of both the finite element basis and the quadrature rule to efficiently apply the action of $B$ without necessarily computing its entries. This is generally know as sum factorization . In the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly . Template implementation Below is a short description of the header files that are part of the initial reference implementation of the tensor-based finite element assembly and evaluation algorithms. config/tconfig.hpp Configuration macros including the specification of the template blocking size (currently used in the matrix-matrix multiply). general/tassign.hpp Helper templated function to allow single implementation of multiple assignment operations on tensor entries. linalg/tlayout.hpp Classes describing fixed size tensor layouts. Implemented are standard strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and sub-tensor operations independent of the actual data storage. This header also contains another set of \"vector layout\" classes for converting scalar data indices into multi-component (vector) data indices. They are used to describe the layout of vector GridFunctions on global degrees of freedom (similar to the Ordering class). In the FE operator decomposition, these classes are used by the templated *_FiniteElementSpace classes (see fem/tfespace.hpp below) to implement the actions of $G$ and $G^T$ in the case of vector (multi-component) input and/or output fields. linalg/tmatrix.hpp Small matrix operations, defined by specializations: determinant, adjugate, etc. Matrix-matrix multiply, C = A.B , simple and blocked version. linalg/ttensor.hpp Fixed-size container classes TVector , TMatrix , TTensor3 , TTensor4 for 1D/2D/3D/4D tensors stored in column-major layout. Element-wise tensor operations: A {=,+=,*=} scalar ; A {=,+=,*=} B . The latter allows different input and output layouts. With suitable layouts this can be used to permute (transpose) tensors, extract sub-tensors, etc. The tensor contraction/product operations: Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$ Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$ TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$ TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$ mesh/tmesh.hpp The Mesh object templated by the finite element space and layout of the nodes. Provides MatchesGeometry() and MatchesNodes() functions to verify if compiled and runtime mesh agree. fem/tintrules.hpp Quadrature rules templated by geometry (triangles, quads, etc.) and integration order. fem/tfe.hpp H1 and L2 finite elements templated by geometry and polynomial order. fem/tfespace.hpp Template *_FiniteElementSpace classes providing the mappings between global and local (element) degrees of freedom for H1 continuous and L2 discontinuous spaces. In the FE operator decomposition, these classes provide the element local action of $G$ ( Extract methods) and $G^T$ ( Assemble methods). fem/tcoefficient.hpp Templated versions of classes derived from the abstract class Coefficient . It encapsulates physical quantities like material properties, sources, boundary/initial conditions, etc. Its main functionality is to evaluate the coefficient at all quadrature points in an element, which is then used in the evaluation of the $D$ matrix. fem/teltrans.hpp Element transformation class, templated on a mesh type and an integration rule. It is constructed from a mesh (e.g. class TMesh ) and shape evaluator (e.g. class ShapeEvaluator ) objects. Allows computation of physical coordinates and Jacobian matrices corresponding to the reference integration points. The desired result (a combination of coordinates and/or Jacobian matrices at quadrature points, element attribute and/or element index) is specified through the template sub-class Result and stored in an object of the same type. The idea of this approach is to eliminate unnecessary evaluations if they are not needed. The need is determined based on what the particular \"users\" need. The \"users\" are the templated Coefficient and Kernel (see fem/tbilininteg.hpp below) classes which specify what they need through static constant boolean variables, e.g. uses_coordinates , uses_Jacobians , etc. fem/tevaluator.hpp Classes for evaluating FE basis, ShapeEvaluator , and finite element functions, FieldEvaluator , and their derivatives at quadrature points, templated by a finite element class and an integration rule class. These correspond to the $B$ and $BG$ matrices above. Quads and hexes use the tensor-product structure for fast evaluation. fem/tbilininteg.hpp Kernel classes (e.g. mass, diffusion) that represent the matrix $D$ from the above FE operator decomposition. These classes also specify the type of the local operator that needs to be applied before and after the $D$ matrix - these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product $B^T_{out} D B_{in}$ is the local element matrix, which is the result when using the BilinearFormIntegrator classes. This specifications of the types are given by static constant boolean variables, e.g. in_values and out_values . The Kernel classes provide the following methods: Action : evaluate the action of $D$ without explicitly storing the partially assembled data; this is needed for matrix-free action. Assemble : evaluate the partially assembled data, $D$, which is kernel-specific: e.g., for mass, the data is one scalar per quadrature point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions) per quadrature point. MultAssembled : perform the action of $D$ using the pre-computed partially assembled data. fem/tbilinearform.hpp Bilinear form operator, templated on the mesh, finite element space, integration rule and bilinear form integrator. Corresponds to the $A$ matrix above. Provides various assembly and evaluation schemes: MultUnassembled : matrix-free action using the mesh nodes and the input vector. Assemble , MultAssembled : partial assembly and operator action using the partially assembled data at quadrature points and the input vector. AssembleMatrix(DenseTensor &) : assemble the local element matrices and store them as DenseTensor . AssembleMatrix(SparseMatrix &) : assemble the operator in a global (CSR) SparseMatrix . AssembleBilinearForm(BilinearForm &) : assemble element matrices and add them to the bilinear form. miniapps/performance/makefile By default make builds the example drivers with the compiler used to compile MFEM. If g++ was used, a pseudo-code dump file with the optimized code will be generated (option -fdump-tree-optimized-blocks ). The g++ option --param max-completely-peel-times=3 prevents the compiler from unrolling innermost loops (of size greater than 3), allowing the compiler to vectorize them. Some options for optimization/vectorization with the clang compiler are also included. miniapps/performance/ex*.cpp High-performance templated versions of the corresponding examples/ex*.cpp example codes. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_High Performance Templated Code"},{"location":"tperformance/#tensor-based-operator-assembly-and-evaluation","text":"","title":"Tensor-Based Operator Assembly and Evaluation"},{"location":"tperformance/#overview","text":"The high performance (HPC) versions of the example codes in the miniapps/performance directory use a set of templated classes to efficiently implement the inner-most portion ($B^T D B$) of the fundamental finite element (FE) operator decomposition: We take advantage of the tensor-product structure of both the finite element basis and the quadrature rule to efficiently apply the action of $B$ without necessarily computing its entries. This is generally know as sum factorization . In the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly .","title":"Overview"},{"location":"tperformance/#template-implementation","text":"Below is a short description of the header files that are part of the initial reference implementation of the tensor-based finite element assembly and evaluation algorithms.","title":"Template implementation"},{"location":"tperformance/#configtconfighpp","text":"Configuration macros including the specification of the template blocking size (currently used in the matrix-matrix multiply).","title":"config/tconfig.hpp"},{"location":"tperformance/#generaltassignhpp","text":"Helper templated function to allow single implementation of multiple assignment operations on tensor entries.","title":"general/tassign.hpp"},{"location":"tperformance/#linalgtlayouthpp","text":"Classes describing fixed size tensor layouts. Implemented are standard strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and sub-tensor operations independent of the actual data storage. This header also contains another set of \"vector layout\" classes for converting scalar data indices into multi-component (vector) data indices. They are used to describe the layout of vector GridFunctions on global degrees of freedom (similar to the Ordering class). In the FE operator decomposition, these classes are used by the templated *_FiniteElementSpace classes (see fem/tfespace.hpp below) to implement the actions of $G$ and $G^T$ in the case of vector (multi-component) input and/or output fields.","title":"linalg/tlayout.hpp"},{"location":"tperformance/#linalgtmatrixhpp","text":"Small matrix operations, defined by specializations: determinant, adjugate, etc. Matrix-matrix multiply, C = A.B , simple and blocked version.","title":"linalg/tmatrix.hpp"},{"location":"tperformance/#linalgttensorhpp","text":"Fixed-size container classes TVector , TMatrix , TTensor3 , TTensor4 for 1D/2D/3D/4D tensors stored in column-major layout. Element-wise tensor operations: A {=,+=,*=} scalar ; A {=,+=,*=} B . The latter allows different input and output layouts. With suitable layouts this can be used to permute (transpose) tensors, extract sub-tensors, etc. The tensor contraction/product operations: Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$ Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$ TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$ TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$","title":"linalg/ttensor.hpp"},{"location":"tperformance/#meshtmeshhpp","text":"The Mesh object templated by the finite element space and layout of the nodes. Provides MatchesGeometry() and MatchesNodes() functions to verify if compiled and runtime mesh agree.","title":"mesh/tmesh.hpp"},{"location":"tperformance/#femtintruleshpp","text":"Quadrature rules templated by geometry (triangles, quads, etc.) and integration order.","title":"fem/tintrules.hpp"},{"location":"tperformance/#femtfehpp","text":"H1 and L2 finite elements templated by geometry and polynomial order.","title":"fem/tfe.hpp"},{"location":"tperformance/#femtfespacehpp","text":"Template *_FiniteElementSpace classes providing the mappings between global and local (element) degrees of freedom for H1 continuous and L2 discontinuous spaces. In the FE operator decomposition, these classes provide the element local action of $G$ ( Extract methods) and $G^T$ ( Assemble methods).","title":"fem/tfespace.hpp"},{"location":"tperformance/#femtcoefficienthpp","text":"Templated versions of classes derived from the abstract class Coefficient . It encapsulates physical quantities like material properties, sources, boundary/initial conditions, etc. Its main functionality is to evaluate the coefficient at all quadrature points in an element, which is then used in the evaluation of the $D$ matrix.","title":"fem/tcoefficient.hpp"},{"location":"tperformance/#femteltranshpp","text":"Element transformation class, templated on a mesh type and an integration rule. It is constructed from a mesh (e.g. class TMesh ) and shape evaluator (e.g. class ShapeEvaluator ) objects. Allows computation of physical coordinates and Jacobian matrices corresponding to the reference integration points. The desired result (a combination of coordinates and/or Jacobian matrices at quadrature points, element attribute and/or element index) is specified through the template sub-class Result and stored in an object of the same type. The idea of this approach is to eliminate unnecessary evaluations if they are not needed. The need is determined based on what the particular \"users\" need. The \"users\" are the templated Coefficient and Kernel (see fem/tbilininteg.hpp below) classes which specify what they need through static constant boolean variables, e.g. uses_coordinates , uses_Jacobians , etc.","title":"fem/teltrans.hpp"},{"location":"tperformance/#femtevaluatorhpp","text":"Classes for evaluating FE basis, ShapeEvaluator , and finite element functions, FieldEvaluator , and their derivatives at quadrature points, templated by a finite element class and an integration rule class. These correspond to the $B$ and $BG$ matrices above. Quads and hexes use the tensor-product structure for fast evaluation.","title":"fem/tevaluator.hpp"},{"location":"tperformance/#femtbilininteghpp","text":"Kernel classes (e.g. mass, diffusion) that represent the matrix $D$ from the above FE operator decomposition. These classes also specify the type of the local operator that needs to be applied before and after the $D$ matrix - these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product $B^T_{out} D B_{in}$ is the local element matrix, which is the result when using the BilinearFormIntegrator classes. This specifications of the types are given by static constant boolean variables, e.g. in_values and out_values . The Kernel classes provide the following methods: Action : evaluate the action of $D$ without explicitly storing the partially assembled data; this is needed for matrix-free action. Assemble : evaluate the partially assembled data, $D$, which is kernel-specific: e.g., for mass, the data is one scalar per quadrature point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions) per quadrature point. MultAssembled : perform the action of $D$ using the pre-computed partially assembled data.","title":"fem/tbilininteg.hpp"},{"location":"tperformance/#femtbilinearformhpp","text":"Bilinear form operator, templated on the mesh, finite element space, integration rule and bilinear form integrator. Corresponds to the $A$ matrix above. Provides various assembly and evaluation schemes: MultUnassembled : matrix-free action using the mesh nodes and the input vector. Assemble , MultAssembled : partial assembly and operator action using the partially assembled data at quadrature points and the input vector. AssembleMatrix(DenseTensor &) : assemble the local element matrices and store them as DenseTensor . AssembleMatrix(SparseMatrix &) : assemble the operator in a global (CSR) SparseMatrix . AssembleBilinearForm(BilinearForm &) : assemble element matrices and add them to the bilinear form.","title":"fem/tbilinearform.hpp"},{"location":"tperformance/#miniappsperformancemakefile","text":"By default make builds the example drivers with the compiler used to compile MFEM. If g++ was used, a pseudo-code dump file with the optimized code will be generated (option -fdump-tree-optimized-blocks ). The g++ option --param max-completely-peel-times=3 prevents the compiler from unrolling innermost loops (of size greater than 3), allowing the compiler to vectorize them. Some options for optimization/vectorization with the clang compiler are also included.","title":"miniapps/performance/makefile"},{"location":"tperformance/#miniappsperformanceexcpp","text":"High-performance templated versions of the corresponding examples/ex*.cpp example codes. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"miniapps/performance/ex*.cpp"}]}
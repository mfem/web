{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MFEM is a free , lightweight , scalable C++ library for finite element methods. Features Arbitrary high-order finite element meshes and spaces . Wide variety of finite element discretization approaches. Conforming and nonconforming adaptive mesh refinement . Scalable to hundreds of thousands of cores. ... and many more . MFEM is used in many projects, including BLAST , XBraid , VisIt , the xSDK , the FASTMath institute in SciDAC, and the co-design Center for Efficient Exascale Discretizations (CEED) in the Exascale Computing Project . See also our Gallery , related publications and project news updates . News Date Message Nov 20, 2019 MFEM overview paper available on arXiv. May 24, 2019 Version 4.0 released with initial GPU support. May 10, 2019 AMR and TMOP papers available on arXiv. Nov 9, 2018 MFEM part of the E4S project. Latest Release New features \u250a Examples \u250a Code documentation \u250a Sources Download mfem-4.0.tgz For older releases see the download section. Documentation Building MFEM \u250a Serial Tutorial \u250a Parallel Tutorial \u250a Code Overview Finite Element Method \u250a Electromagnetics \u250a Meshing New users should start by examining the example codes . We also recommend using GLVis for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"#features","text":"Arbitrary high-order finite element meshes and spaces . Wide variety of finite element discretization approaches. Conforming and nonconforming adaptive mesh refinement . Scalable to hundreds of thousands of cores. ... and many more . MFEM is used in many projects, including BLAST , XBraid , VisIt , the xSDK , the FASTMath institute in SciDAC, and the co-design Center for Efficient Exascale Discretizations (CEED) in the Exascale Computing Project . See also our Gallery , related publications and project news updates .","title":"Features"},{"location":"#news","text":"Date Message Nov 20, 2019 MFEM overview paper available on arXiv. May 24, 2019 Version 4.0 released with initial GPU support. May 10, 2019 AMR and TMOP papers available on arXiv. Nov 9, 2018 MFEM part of the E4S project.","title":"News"},{"location":"#latest-release","text":"New features \u250a Examples \u250a Code documentation \u250a Sources Download mfem-4.0.tgz For older releases see the download section.","title":"Latest Release"},{"location":"#documentation","text":"Building MFEM \u250a Serial Tutorial \u250a Parallel Tutorial \u250a Code Overview Finite Element Method \u250a Electromagnetics \u250a Meshing New users should start by examining the example codes . We also recommend using GLVis for visualization.","title":"Documentation"},{"location":"#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about/","text":"About MFEM MFEM originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @misc{mfem-library, title = {{MFEM}: Modular Finite Element Methods Library}, howpublished = {\\url{mfem.org}}, doi = {10.11578/dc.20171025.1248} } Contributors Ido Akkerman Robert Anderson Thomas Anderson Julian Andrej Mikhail Artemyev Andrew Barker Thomas Benson Aaron Black Jamie Bramwell Thomas Brunner Jean-Sylvain Camier Jakub \u010cerven\u00fd Johann Dahm Veselin Dobrev Truman Ellis Aaron Fisher Pieter Ghysels Hennes Hajduk Cyrus Harrison Kazem Kamran Patrick Knupp Tzanio Kolev \u2014 Project Leader Ilya Lashuk Scott MacLachlan Peter Maginot Mark Miller Ketan Mittal Jan Nikl Geoffrey Oxberry Will Pazner Robert Rieben Joachim Sch\u00f6berl Jean Sexton Syun'ichi Shiraiwa Cameron Smith Thomas Stitt Mark Stowell Stanimire Tomov Vladimir Tomov Arturo Vargas Umberto Villa Kenneth Weiss Daniel White Stefano Zampini License GNU Lesser GPL v2.1 This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-443211. DOI: 10.11578/dc.20171025.1248 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about/#about-mfem","text":"MFEM originates from previous research effort in the (unreleased) AggieFEM/aFEM project. Please cite with: @misc{mfem-library, title = {{MFEM}: Modular Finite Element Methods Library}, howpublished = {\\url{mfem.org}}, doi = {10.11578/dc.20171025.1248} }","title":"About MFEM"},{"location":"about/#contributors","text":"Ido Akkerman Robert Anderson Thomas Anderson Julian Andrej Mikhail Artemyev Andrew Barker Thomas Benson Aaron Black Jamie Bramwell Thomas Brunner Jean-Sylvain Camier Jakub \u010cerven\u00fd Johann Dahm Veselin Dobrev Truman Ellis Aaron Fisher Pieter Ghysels Hennes Hajduk Cyrus Harrison Kazem Kamran Patrick Knupp Tzanio Kolev \u2014 Project Leader Ilya Lashuk Scott MacLachlan Peter Maginot Mark Miller Ketan Mittal Jan Nikl Geoffrey Oxberry Will Pazner Robert Rieben Joachim Sch\u00f6berl Jean Sexton Syun'ichi Shiraiwa Cameron Smith Thomas Stitt Mark Stowell Stanimire Tomov Vladimir Tomov Arturo Vargas Umberto Villa Kenneth Weiss Daniel White Stefano Zampini","title":"Contributors"},{"location":"about/#license","text":"GNU Lesser GPL v2.1 This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-443211. DOI: 10.11578/dc.20171025.1248 . Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"License"},{"location":"bilininteg/","text":"Bilinear Form Integrators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions of both the domain and range spaces, therefore bilinear integrators simultaneously compute the integrals of all combinations of the relevant basis functions from the domain and range spaces. This produces a two dimensional array of results that are arranged into a small dense matrix of integral values called a local element (stiffness) matrix . To put this another way, the BilinearForm class builds a global, sparse, finite element matrix, glb_mat , by performing the outer loop in the following pseudocode snippet whereas the BilinearFormIntegrator class performs the nested inner loops to compute the dense local element matrix, loc_mat . for each elem in elements loc_mat = 0.0 for each pt in quadrature_points for each u_j in elem for each v_i in elem loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt) end end end glb_mat += loc_mat end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$ Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$ Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$ The BilinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the BilinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function Notation: The integrals performed by the various integrators listed below are shown using inner product notation, $(\\cdot,\\cdot)$, defined as follows. $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$ $$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$ Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$ or $\\vec{v}$ is in the range (or test) space. For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Note that any operators involving a derivative of the range function $v$ or $\\vec{v}$ are computed using integration by parts. This leads to a boundary integral which can be used to apply Neumann boundary conditions. Some of these operators are listed along with their boundary terms in section Weak Operators . Scalar Field Operators These operators require scalar-valued trial spaces. Many of these operators will work with either H1 or L2 basis functions but some that require a gradient operator should be used with H1. Square Operators These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension MassIntegrator H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D DiffusionIntegrator H1 S, M $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ 1D, 2D, 3D Mixed Operators These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedScalarMassIntegrator H1, L2 H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D MixedScalarWeakDivergenceIntegrator H1, L2 H1 V $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ 2D, 3D MixedScalarWeakDerivativeIntegrator H1, L2 H1 S $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ 1D MixedScalarWeakCurlIntegrator H1, L2 ND S $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ 2D MixedVectorProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda}u,\\vec{v})$ $\\vec{\\lambda}u$ 2D, 3D MixedScalarWeakCrossProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$ $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$ 2D MixedScalarWeakGradientIntegrator H1, L2 RT S $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ 2D, 3D MixedDirectionalDerivativeIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cdot\\grad u, v)$ $\\vec{\\lambda}\\cdot\\grad u$ 2D, 3D MixedScalarCrossGradIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cross\\grad u, v)$ $\\vec{\\lambda}\\cross\\grad u$ 2D MixedScalarDerivativeIntegrator H1 H1, L2 S $(\\lambda \\ddx{u}, v)$ $\\lambda\\ddx{u}\\;$ 1D MixedGradGradIntegrator H1 H1 S, D, M $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ 2D, 3D MixedCrossGradGradIntegrator H1 H1 V $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ 2D, 3D MixedVectorGradientIntegrator H1 ND, RT S, D, M $(\\lambda\\grad u,\\vec{v})$ $\\lambda\\grad u$ 2D, 3D MixedCrossGradIntegrator H1 ND, RT V $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$ $\\vec{\\lambda}\\cross\\grad u$ 3D MixedCrossGradCurlIntegrator H1 ND V $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\times\\grad u)$ 3D MixedGradDivIntegrator H1 RT V $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ 2D, 3D Other Scalar Operators Class Name Domain Range Coef. Dimension Operator Notes DerivativeIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$ The direction index \"i\" is passed by the user. See MixedDirectionalDerivativeIntegrator for a more general alternative. ConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\vec{\\lambda}\\cdot\\grad u, v)$ This is designed to be used with BilinearForm to produce a square matrix. See MixedDirectionalDerivativeIntegrator for a rectangular version. GroupConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$ Uses the \"group\" finite element formulation for advection due to Fletcher . BoundaryMassIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\,u,v)$ Computes a mass matrix on the exterior faces of a domain. See MassIntegrator above for a more general version. Vector Finite Element Operators These operators require vector-valued basis functions in the trial space. Many of these operators will work with either ND or RT basis functions but others require one or the other. Square Operators These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension VectorFEMassIntegrator ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D CurlCurlIntegrator ND S $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 2D, 3D DivDivIntegrator RT S $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ 2D, 3D Mixed Operators These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedDotProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cdot\\vec{u},v)$ $\\vec{\\lambda}\\cdot\\vec{u}$ 2D, 3D MixedScalarCrossProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cross\\vec{u},v)$ $\\vec{\\lambda}\\cross\\vec{u}$ 2D MixedVectorWeakDivergenceIntegrator ND, RT H1 S, D, M $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ 2D, 3D MixedWeakDivCrossIntegrator ND, RT H1 V $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedVectorMassIntegrator ND, RT ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D MixedCrossProductIntegrator ND, RT ND, RT V $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\vec{u}$ 3D MixedVectorWeakCurlIntegrator ND, RT ND S, D, M $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ 3D MixedWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedScalarWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 2D MixedWeakGradDotIntegrator ND, RT RT V $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ 2D, 3D MixedScalarCurlIntegrator ND H1, L2 S $(\\lambda\\curl\\vec{u},v)$ $\\lambda\\curl\\vec{u}\\;$ 2D MixedCrossCurlGradIntegrator ND H1 V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedVectorCurlIntegrator ND ND, RT S, D, M $(\\lambda\\curl\\vec{u},\\vec{v})$ $\\lambda\\curl\\vec{u}$ 3D MixedCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\curl\\vec{u}$ 3D MixedScalarCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$ 2D MixedCurlCurlIntegrator ND ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 3D MixedCrossCurlCurlIntegrator ND ND V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedScalarDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ $\\lambda \\div\\vec{u}$ 2D, 3D MixedDivGradIntegrator RT H1 V $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ 2D, 3D MixedVectorDivergenceIntegrator RT ND, RT V $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$ $\\vec{\\lambda}\\div\\vec{u}$ 2D, 3D Other Vector Finite Element Operators Class Name Domain Range Coef. Operator Dimension Notes VectorFEDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ 2D, 3D Alternate implementation of MixedScalarDivergenceIntegrator. VectorFEWeakDivergenceIntegrator ND H1 S $(-\\lambda\\vec{u},\\grad v)$ 2D, 3D See MixedVectorWeakDivergenceIntegrator for a more general implementation. VectorFECurlIntegrator ND, RT ND, RT S $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$ 3D If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations. Vector Field Operators These operators require vector-valued basis functions constructed by using multiple copies of scalar fields. In each of these integrators the scalar basis function index increments most quickly followed by the vector index. This leads to local element matrix which have a block structure. Square Operators Class Name Spaces Coef. Dimension Operator Notes VectorMassIntegrator $H_1^d$, $L_2^d$ S, D, M 1D, 2D, 3D $(\\lambda\\vec{u},\\vec{v})$ VectorCurlCurlIntegrator $H_1^d$, $L_2^d$ S 2D, 3D $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ VectorDiffusionIntegrator $H_1^d$, $L_2^d$ S 1D, 2D, 3D $(\\lambda\\grad u_i,\\grad v_i)$ Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block ElasticityIntegrator $H_1^d$, $L_2^d$ $2\\times$S 1D, 2D, 3D $(c_{ikjl}\\grad u_j,\\grad v_i)$ Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix. The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$ Mixed Operators Class Name Domain Range Coef. Dimension Operator VectorDivergenceIntegrator $H_1^d$, $L_2^d$ H1, L2 S 1D, 2D, 3D $(\\lambda\\div\\vec{u},v)$ Discontinuous Galerkin Operators Class Name Domain Range Operator Notes DGTraceIntegrator H1, L2 H1, L2 $\\alpha \\left<\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right> \\\\ + \\beta \\left<\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right>$ DGDiffusionIntegrator H1, L2 H1, L2 $-\\left<\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right> \\\\ + \\sigma \\left<[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right> \\\\ + \\kappa \\left<\\{h^{-1}Q\\}[u],[v]\\right> $ DGElasticityIntegrator H1, L2 H1, L2 see $(\\ref{dg-elast})$ TraceJumpIntegrator $\\left< v, [w] \\right>$ NormalTraceJumpIntegrator $\\left< v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right>$ Integrator for the DG elasticity form, for the formulations see: PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09, p.3 $$ - \\left< \\{ \\tau(u) \\}, [v] \\right> + \\alpha \\left< \\{ \\tau(v) \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ where $ \\left< u, v\\right> = \\int_{F} u \\cdot v $, and $ F $ is a face which is either a boundary face $ F_b $ of an element $ K $ or an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $. In the bilinear form above $ \\tau(u) $ is traction, and it's also $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $. In other words, we have $$\\label{dg-elast} - \\left< \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right> + \\alpha \\left< \\{ \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ For isotropic media $$ \\begin{split} \\sigma(u) &= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\ &= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u + \\nabla u^T \\right) \\\\ &= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T \\right) \\end{split} $$ where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test functions, respectively. The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to use (when this integrator is added to the \"broken\" ElasticityIntegrator): IIPG , $\\alpha = 0$, C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004. SIPG , $\\alpha = -1$, M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006. NIPG , $\\alpha = 1$, B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite Element Methods Based on Discontinuous Approximation Spaces for Elliptic Problems, SINUM, 39(3), 902-931, 2001. This is a 'Vector' integrator, i.e. defined for FE spaces using multiple copies of a scalar FE space. Special Purpose Integrators These \"integrators\" do not actually perform integrations they merely alter the results of other integrators. As such they provide a convenient and easy way to reuse existing integrators in special situations rather than needing to reimplement their functionality. Class Name Description TransposeIntegrator Returns the transpose of the local matrix computed by another BilinearFormIntegrator LumpedIntegrator Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices) InverseIntegrator Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix SumIntegrator Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices) Weak Operators and Their Boundary Integrals Weak operators use integration by parts to move a spatial derivative onto the test function. This results in an implied boundary integral that is often assumed to be zero but can be used to apply an non-homogeneous Neumann boundary condition. Operator with Scalar Range The following weak operators require the range (or test) space to be $H_1$ i.e. a scalar basis function with a gradient operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an inhomogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DiffusionIntegrator one could provide a known function for $\\lambda\\,\\grad u$ to the BoundaryNormalLFIntegrator which would then integrate the normal component of this function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DiffusionIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedGradGradIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedCrossGradGradIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$ MixedScalarWeakDivergenceIntegrator $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$ MixedScalarWeakDerivativeIntegrator $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$ MixedVectorWeakDivergenceIntegrator $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$ MixedWeakDivCrossIntegrator $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ MixedCrossCurlGradIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedDivGradIntegrator $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$ Operator with Vector Range The following weak operators require the range (or test) space to be H(Curl) i.e. a vector basis function with a curl operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the CurlCurlIntegrator one could provide a known function for $\\lambda\\,\\curl\\vec{u}$ to the VectorFEBoundaryTangentLFIntegrator which would then integrate the product of the tangential portion of this function with that of the ND basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. CurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCrossCurlCurlIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedCrossGradCurlIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$ MixedVectorWeakCurlIntegrator $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\vec{u}$ MixedScalarWeakCurlIntegrator $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$ MixedWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ MixedScalarWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ The following weak operators require the range (or test) space to be H(Div) i.e. a vector basis function with a divergence operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DivDivIntegrator one could provide a known function for $\\lambda\\,\\div\\vec{u}$ to the VectorFEBoundaryFluxLFIntegrator which would then integrate the product of this function with the normal component of the RT basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DivDivIntegrator $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}\\,\\hat{n}$ MixedGradDivIntegrator $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$ MixedScalarWeakGradientIntegrator $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ $-\\lambda u\\,\\hat{n}$ MixedWeakGradDotIntegrator $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Bilinear Form Integrators"},{"location":"bilininteg/#bilinear-form-integrators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions of both the domain and range spaces, therefore bilinear integrators simultaneously compute the integrals of all combinations of the relevant basis functions from the domain and range spaces. This produces a two dimensional array of results that are arranged into a small dense matrix of integral values called a local element (stiffness) matrix . To put this another way, the BilinearForm class builds a global, sparse, finite element matrix, glb_mat , by performing the outer loop in the following pseudocode snippet whereas the BilinearFormIntegrator class performs the nested inner loops to compute the dense local element matrix, loc_mat . for each elem in elements loc_mat = 0.0 for each pt in quadrature_points for each u_j in elem for each v_i in elem loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt) end end end glb_mat += loc_mat end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$ Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$ Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$ The BilinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the BilinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function Notation: The integrals performed by the various integrators listed below are shown using inner product notation, $(\\cdot,\\cdot)$, defined as follows. $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$ $$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$ Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$ or $\\vec{v}$ is in the range (or test) space. For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Note that any operators involving a derivative of the range function $v$ or $\\vec{v}$ are computed using integration by parts. This leads to a boundary integral which can be used to apply Neumann boundary conditions. Some of these operators are listed along with their boundary terms in section Weak Operators .","title":"Bilinear Form Integrators"},{"location":"bilininteg/#scalar-field-operators","text":"These operators require scalar-valued trial spaces. Many of these operators will work with either H1 or L2 basis functions but some that require a gradient operator should be used with H1.","title":"Scalar Field Operators"},{"location":"bilininteg/#square-operators","text":"These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension MassIntegrator H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D DiffusionIntegrator H1 S, M $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ 1D, 2D, 3D","title":"Square Operators"},{"location":"bilininteg/#mixed-operators","text":"These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedScalarMassIntegrator H1, L2 H1, L2 S $(\\lambda u, v)$ $\\lambda u$ 1D, 2D, 3D MixedScalarWeakDivergenceIntegrator H1, L2 H1 V $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ 2D, 3D MixedScalarWeakDerivativeIntegrator H1, L2 H1 S $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ 1D MixedScalarWeakCurlIntegrator H1, L2 ND S $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ 2D MixedVectorProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda}u,\\vec{v})$ $\\vec{\\lambda}u$ 2D, 3D MixedScalarWeakCrossProductIntegrator H1, L2 ND, RT V $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$ $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$ 2D MixedScalarWeakGradientIntegrator H1, L2 RT S $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ 2D, 3D MixedDirectionalDerivativeIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cdot\\grad u, v)$ $\\vec{\\lambda}\\cdot\\grad u$ 2D, 3D MixedScalarCrossGradIntegrator H1 H1, L2 V $(\\vec{\\lambda}\\cross\\grad u, v)$ $\\vec{\\lambda}\\cross\\grad u$ 2D MixedScalarDerivativeIntegrator H1 H1, L2 S $(\\lambda \\ddx{u}, v)$ $\\lambda\\ddx{u}\\;$ 1D MixedGradGradIntegrator H1 H1 S, D, M $(\\lambda\\grad u,\\grad v)$ $-\\div(\\lambda\\grad u)$ 2D, 3D MixedCrossGradGradIntegrator H1 H1 V $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ 2D, 3D MixedVectorGradientIntegrator H1 ND, RT S, D, M $(\\lambda\\grad u,\\vec{v})$ $\\lambda\\grad u$ 2D, 3D MixedCrossGradIntegrator H1 ND, RT V $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$ $\\vec{\\lambda}\\cross\\grad u$ 3D MixedCrossGradCurlIntegrator H1 ND V $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\times\\grad u)$ 3D MixedGradDivIntegrator H1 RT V $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ 2D, 3D","title":"Mixed Operators"},{"location":"bilininteg/#other-scalar-operators","text":"Class Name Domain Range Coef. Dimension Operator Notes DerivativeIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$ The direction index \"i\" is passed by the user. See MixedDirectionalDerivativeIntegrator for a more general alternative. ConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\vec{\\lambda}\\cdot\\grad u, v)$ This is designed to be used with BilinearForm to produce a square matrix. See MixedDirectionalDerivativeIntegrator for a rectangular version. GroupConvectionIntegrator H1 H1 V 1D, 2D, 3D $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$ Uses the \"group\" finite element formulation for advection due to Fletcher . BoundaryMassIntegrator H1, L2 H1, L2 S 1D, 2D, 3D $(\\lambda\\,u,v)$ Computes a mass matrix on the exterior faces of a domain. See MassIntegrator above for a more general version.","title":"Other Scalar Operators"},{"location":"bilininteg/#vector-finite-element-operators","text":"These operators require vector-valued basis functions in the trial space. Many of these operators will work with either ND or RT basis functions but others require one or the other.","title":"Vector Finite Element Operators"},{"location":"bilininteg/#square-operators_1","text":"These integrators are designed to be used with the BilinearForm object to assemble square linear operators. Class Name Spaces Coef. Operator Continuous Op. Dimension VectorFEMassIntegrator ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D CurlCurlIntegrator ND S $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 2D, 3D DivDivIntegrator RT S $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ 2D, 3D","title":"Square Operators"},{"location":"bilininteg/#mixed-operators_1","text":"These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators. Class Name Domain Range Coef. Operator Continuous Op. Dimension MixedDotProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cdot\\vec{u},v)$ $\\vec{\\lambda}\\cdot\\vec{u}$ 2D, 3D MixedScalarCrossProductIntegrator ND, RT H1, L2 V $(\\vec{\\lambda}\\cross\\vec{u},v)$ $\\vec{\\lambda}\\cross\\vec{u}$ 2D MixedVectorWeakDivergenceIntegrator ND, RT H1 S, D, M $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ 2D, 3D MixedWeakDivCrossIntegrator ND, RT H1 V $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedVectorMassIntegrator ND, RT ND, RT S, D, M $(\\lambda\\vec{u},\\vec{v})$ $\\lambda\\vec{u}$ 2D, 3D MixedCrossProductIntegrator ND, RT ND, RT V $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\vec{u}$ 3D MixedVectorWeakCurlIntegrator ND, RT ND S, D, M $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ 3D MixedWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 3D MixedScalarWeakCurlCrossIntegrator ND, RT ND V $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ 2D MixedWeakGradDotIntegrator ND, RT RT V $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ 2D, 3D MixedScalarCurlIntegrator ND H1, L2 S $(\\lambda\\curl\\vec{u},v)$ $\\lambda\\curl\\vec{u}\\;$ 2D MixedCrossCurlGradIntegrator ND H1 V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedVectorCurlIntegrator ND ND, RT S, D, M $(\\lambda\\curl\\vec{u},\\vec{v})$ $\\lambda\\curl\\vec{u}$ 3D MixedCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\curl\\vec{u}$ 3D MixedScalarCrossCurlIntegrator ND ND, RT V $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$ $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$ 2D MixedCurlCurlIntegrator ND ND S, D, M $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ 3D MixedCrossCurlCurlIntegrator ND ND V $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ 3D MixedScalarDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ $\\lambda \\div\\vec{u}$ 2D, 3D MixedDivGradIntegrator RT H1 V $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ 2D, 3D MixedVectorDivergenceIntegrator RT ND, RT V $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$ $\\vec{\\lambda}\\div\\vec{u}$ 2D, 3D","title":"Mixed Operators"},{"location":"bilininteg/#other-vector-finite-element-operators","text":"Class Name Domain Range Coef. Operator Dimension Notes VectorFEDivergenceIntegrator RT H1, L2 S $(\\lambda\\div\\vec{u}, v)$ 2D, 3D Alternate implementation of MixedScalarDivergenceIntegrator. VectorFEWeakDivergenceIntegrator ND H1 S $(-\\lambda\\vec{u},\\grad v)$ 2D, 3D See MixedVectorWeakDivergenceIntegrator for a more general implementation. VectorFECurlIntegrator ND, RT ND, RT S $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$ 3D If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.","title":"Other Vector Finite Element Operators"},{"location":"bilininteg/#vector-field-operators","text":"These operators require vector-valued basis functions constructed by using multiple copies of scalar fields. In each of these integrators the scalar basis function index increments most quickly followed by the vector index. This leads to local element matrix which have a block structure.","title":"Vector Field Operators"},{"location":"bilininteg/#square-operators_2","text":"Class Name Spaces Coef. Dimension Operator Notes VectorMassIntegrator $H_1^d$, $L_2^d$ S, D, M 1D, 2D, 3D $(\\lambda\\vec{u},\\vec{v})$ VectorCurlCurlIntegrator $H_1^d$, $L_2^d$ S 2D, 3D $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ VectorDiffusionIntegrator $H_1^d$, $L_2^d$ S 1D, 2D, 3D $(\\lambda\\grad u_i,\\grad v_i)$ Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block ElasticityIntegrator $H_1^d$, $L_2^d$ $2\\times$S 1D, 2D, 3D $(c_{ikjl}\\grad u_j,\\grad v_i)$ Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix. The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$","title":"Square Operators"},{"location":"bilininteg/#mixed-operators_2","text":"Class Name Domain Range Coef. Dimension Operator VectorDivergenceIntegrator $H_1^d$, $L_2^d$ H1, L2 S 1D, 2D, 3D $(\\lambda\\div\\vec{u},v)$","title":"Mixed Operators"},{"location":"bilininteg/#discontinuous-galerkin-operators","text":"Class Name Domain Range Operator Notes DGTraceIntegrator H1, L2 H1, L2 $\\alpha \\left<\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right> \\\\ + \\beta \\left<\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right>$ DGDiffusionIntegrator H1, L2 H1, L2 $-\\left<\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right> \\\\ + \\sigma \\left<[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right> \\\\ + \\kappa \\left<\\{h^{-1}Q\\}[u],[v]\\right> $ DGElasticityIntegrator H1, L2 H1, L2 see $(\\ref{dg-elast})$ TraceJumpIntegrator $\\left< v, [w] \\right>$ NormalTraceJumpIntegrator $\\left< v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right>$ Integrator for the DG elasticity form, for the formulations see: PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09, p.3 $$ - \\left< \\{ \\tau(u) \\}, [v] \\right> + \\alpha \\left< \\{ \\tau(v) \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ where $ \\left< u, v\\right> = \\int_{F} u \\cdot v $, and $ F $ is a face which is either a boundary face $ F_b $ of an element $ K $ or an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $. In the bilinear form above $ \\tau(u) $ is traction, and it's also $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $. In other words, we have $$\\label{dg-elast} - \\left< \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right> + \\alpha \\left< \\{ \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right> + \\kappa \\left< h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right> $$ For isotropic media $$ \\begin{split} \\sigma(u) &= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\ &= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u + \\nabla u^T \\right) \\\\ &= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T \\right) \\end{split} $$ where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test functions, respectively. The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to use (when this integrator is added to the \"broken\" ElasticityIntegrator): IIPG , $\\alpha = 0$, C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004. SIPG , $\\alpha = -1$, M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006. NIPG , $\\alpha = 1$, B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite Element Methods Based on Discontinuous Approximation Spaces for Elliptic Problems, SINUM, 39(3), 902-931, 2001. This is a 'Vector' integrator, i.e. defined for FE spaces using multiple copies of a scalar FE space.","title":"Discontinuous Galerkin Operators"},{"location":"bilininteg/#special-purpose-integrators","text":"These \"integrators\" do not actually perform integrations they merely alter the results of other integrators. As such they provide a convenient and easy way to reuse existing integrators in special situations rather than needing to reimplement their functionality. Class Name Description TransposeIntegrator Returns the transpose of the local matrix computed by another BilinearFormIntegrator LumpedIntegrator Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices) InverseIntegrator Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix SumIntegrator Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)","title":"Special Purpose Integrators"},{"location":"bilininteg/#weak-operators-and-their-boundary-integrals","text":"Weak operators use integration by parts to move a spatial derivative onto the test function. This results in an implied boundary integral that is often assumed to be zero but can be used to apply an non-homogeneous Neumann boundary condition.","title":"Weak Operators and Their Boundary Integrals"},{"location":"bilininteg/#operator-with-scalar-range","text":"The following weak operators require the range (or test) space to be $H_1$ i.e. a scalar basis function with a gradient operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an inhomogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DiffusionIntegrator one could provide a known function for $\\lambda\\,\\grad u$ to the BoundaryNormalLFIntegrator which would then integrate the normal component of this function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DiffusionIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedGradGradIntegrator $(\\lambda\\grad u, \\grad v)$ $-\\div(\\lambda\\grad u)$ $\\lambda\\,\\hat{n}\\cdot\\grad u$ MixedCrossGradGradIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$ MixedScalarWeakDivergenceIntegrator $(-\\vec{\\lambda}u,\\grad v)$ $\\div(\\vec{\\lambda}u)$ $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$ MixedScalarWeakDerivativeIntegrator $(-\\lambda u, \\ddx{v})$ $\\ddx{}(\\lambda u)\\;$ $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$ MixedVectorWeakDivergenceIntegrator $(-\\lambda\\vec{u},\\grad v)$ $\\div(\\lambda\\vec{u})$ $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$ MixedWeakDivCrossIntegrator $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$ $\\div(\\vec{\\lambda}\\cross\\vec{u})$ $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$ MixedCrossCurlGradIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$ $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedDivGradIntegrator $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$ $-\\div(\\vec{\\lambda}\\div\\vec{u})$ $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$","title":"Operator with Scalar Range"},{"location":"bilininteg/#operator-with-vector-range","text":"The following weak operators require the range (or test) space to be H(Curl) i.e. a vector basis function with a curl operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the CurlCurlIntegrator one could provide a known function for $\\lambda\\,\\curl\\vec{u}$ to the VectorFEBoundaryTangentLFIntegrator which would then integrate the product of the tangential portion of this function with that of the ND basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. CurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCurlCurlIntegrator $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\curl\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$ MixedCrossCurlCurlIntegrator $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$ MixedCrossGradCurlIntegrator $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\grad u)$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$ MixedVectorWeakCurlIntegrator $(\\lambda\\vec{u},\\curl\\vec{v})$ $\\curl(\\lambda\\vec{u})$ $\\lambda\\,\\hat{n}\\times\\vec{u}$ MixedScalarWeakCurlIntegrator $(\\lambda u,\\curl\\vec{v})$ $\\curl(\\lambda\\,u\\,\\hat{z})\\;$ $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$ MixedWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ MixedScalarWeakCurlCrossIntegrator $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$ $\\curl(\\vec{\\lambda}\\cross\\vec{u})$ $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$ The following weak operators require the range (or test) space to be H(Div) i.e. a vector basis function with a divergence operator. The implied natural boundary condition when using these operators is for the continuous boundary operator (shown in the last column) to be equal to zero. On the other hand an non-homogeneous Neumann boundary condition can be applied by using a linear form boundary integrator to compute this boundary term for a known function e.g. when using the DivDivIntegrator one could provide a known function for $\\lambda\\,\\div\\vec{u}$ to the VectorFEBoundaryFluxLFIntegrator which would then integrate the product of this function with the normal component of the RT basis function over the boundary of the domain. See Linear Form Integrators for more information. Class Name Operator Continuous Op. Continuous Boundary Op. DivDivIntegrator $(\\lambda\\div\\vec{u},\\div\\vec{v})$ $-\\grad(\\lambda\\div\\vec{u})$ $\\lambda\\div\\vec{u}\\,\\hat{n}$ MixedGradDivIntegrator $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$ $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$ $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$ MixedScalarWeakGradientIntegrator $(-\\lambda u, \\div\\vec{v})$ $\\grad(\\lambda u)$ $-\\lambda u\\,\\hat{n}$ MixedWeakGradDotIntegrator $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$ $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$ $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Operator with Vector Range"},{"location":"building/","text":"Building MFEM A simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the INSTALL file and make help . In addition to the native build system described below, MFEM packages are also available in the following package managers: Spack OpenHPC Homebrew/Science (deprecated) MFEM can also be installed as part of CEED xSDK E4S FASTMath RADIUSS Instructions Download MFEM and GLVis http://mfem.org http://glvis.org Below we assume that we are working with versions 3.4. Serial version of MFEM and GLVis Put everything in the same directory: ~> ls glvis-3.4.tgz mfem-3.4.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-3.4.tgz ~> cd mfem-3.4 ~/mfem-3.4> make serial -j Build GLVis: ~> tar -zxvf glvis-3.4.tgz ~> cd glvis-3.4 ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j That's it! The MFEM library can be found in mfem-3.4/libmfem.a , while the glvis executable will be in the glvis-3.4 directory. To start a GLVis server, open a new terminal and type ~> cd glvis-3.4 ~/glvis-3.4> ./glvis The serial examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j All serial examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j Parallel MPI version of MFEM Download hypre and metis from https://github.com/hypre-space/hypre/releases https://computation.llnl.gov/casc/hypre/software.html http://glaros.dtc.umn.edu/gkhome/metis/metis/download Below we assume that we are working with versions 2.16.0 and 4.0.3 respectively. We also assume that the serial version of MFEM and GLVis have been built as described above. Put everything in the same directory: ~> ls glvis-3.4/ hypre-2.16.0.tar.gz metis-4.0.3.tar.gz mfem-3.4/ Build hypre: ~> tar -zxvf hypre-2.16.0.tar.gz ~> cd hypre-2.16.0/src/ ~/hypre-2.16.0/src> ./configure --disable-fortran ~/hypre-2.16.0/src> make -j ~/hypre-2.16.0/src> cd ../.. ~> ln -s hypre-2.16.0 hypre Build metis: ~> tar -zxvf metis-4.0.3.tar.gz ~> cd metis-4.0.3 ~/metis-4.0.3> make ~/metis-4.0.3> cd .. ~> ln -s metis-4.0.3 metis-4.0 (If you are using METIS 5, see the instructions below .) Build the parallel version of MFEM: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j Note that if hypre or metis are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the config/defaults.mk file, or create you own config/user.mk , as described in the INSTALL file. The parallel examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j The serial examples can also be build with the parallel version of the library, e.g. ~/mfem-3.4/examples> make ex1 ex2 All parallel examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j One can also use the parallel library to optionally (re-)build GLVis: ~> cd glvis-3.4 ~/glvis-3.4> make clean ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j This, however, is generally not recommended , since the additional MPI thread can interfere with the other GLVis threads. Parallel build using METIS 5 Build METIS 5: ~> tar zvxf metis-5.1.0.tar.gz ~> cd metis-5.1.0 ~/metis-5.1.0> make config ; make ~/metis-5.1.0> mkdir lib ~/metis-5.1.0> ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib Build the parallel version of MFEM, setting the options MFEM_USE_METIS_5 and METIS_DIR , e.g.: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0","title":"Building MFEM"},{"location":"building/#building-mfem","text":"A simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the INSTALL file and make help . In addition to the native build system described below, MFEM packages are also available in the following package managers: Spack OpenHPC Homebrew/Science (deprecated) MFEM can also be installed as part of CEED xSDK E4S FASTMath RADIUSS","title":"Building MFEM"},{"location":"building/#instructions","text":"Download MFEM and GLVis http://mfem.org http://glvis.org Below we assume that we are working with versions 3.4.","title":"Instructions"},{"location":"building/#serial-version-of-mfem-and-glvis","text":"Put everything in the same directory: ~> ls glvis-3.4.tgz mfem-3.4.tgz Build the serial version of MFEM: ~> tar -zxvf mfem-3.4.tgz ~> cd mfem-3.4 ~/mfem-3.4> make serial -j Build GLVis: ~> tar -zxvf glvis-3.4.tgz ~> cd glvis-3.4 ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j That's it! The MFEM library can be found in mfem-3.4/libmfem.a , while the glvis executable will be in the glvis-3.4 directory. To start a GLVis server, open a new terminal and type ~> cd glvis-3.4 ~/glvis-3.4> ./glvis The serial examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j All serial examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j","title":"Serial version of MFEM and GLVis"},{"location":"building/#parallel-mpi-version-of-mfem","text":"Download hypre and metis from https://github.com/hypre-space/hypre/releases https://computation.llnl.gov/casc/hypre/software.html http://glaros.dtc.umn.edu/gkhome/metis/metis/download Below we assume that we are working with versions 2.16.0 and 4.0.3 respectively. We also assume that the serial version of MFEM and GLVis have been built as described above. Put everything in the same directory: ~> ls glvis-3.4/ hypre-2.16.0.tar.gz metis-4.0.3.tar.gz mfem-3.4/ Build hypre: ~> tar -zxvf hypre-2.16.0.tar.gz ~> cd hypre-2.16.0/src/ ~/hypre-2.16.0/src> ./configure --disable-fortran ~/hypre-2.16.0/src> make -j ~/hypre-2.16.0/src> cd ../.. ~> ln -s hypre-2.16.0 hypre Build metis: ~> tar -zxvf metis-4.0.3.tar.gz ~> cd metis-4.0.3 ~/metis-4.0.3> make ~/metis-4.0.3> cd .. ~> ln -s metis-4.0.3 metis-4.0 (If you are using METIS 5, see the instructions below .) Build the parallel version of MFEM: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j Note that if hypre or metis are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the config/defaults.mk file, or create you own config/user.mk , as described in the INSTALL file. The parallel examples can be build with: ~> cd mfem-3.4/examples ~/mfem-3.4/examples> make -j The serial examples can also be build with the parallel version of the library, e.g. ~/mfem-3.4/examples> make ex1 ex2 All parallel examples and miniapps can be build with: ~> cd mfem-3.4 ~/mfem-3.4> make all -j One can also use the parallel library to optionally (re-)build GLVis: ~> cd glvis-3.4 ~/glvis-3.4> make clean ~/glvis-3.4> make MFEM_DIR=../mfem-3.4 -j This, however, is generally not recommended , since the additional MPI thread can interfere with the other GLVis threads.","title":"Parallel MPI version of MFEM"},{"location":"building/#parallel-build-using-metis-5","text":"Build METIS 5: ~> tar zvxf metis-5.1.0.tar.gz ~> cd metis-5.1.0 ~/metis-5.1.0> make config ; make ~/metis-5.1.0> mkdir lib ~/metis-5.1.0> ln -s ../build/Linux-x86_64/libmetis/libmetis.a lib Build the parallel version of MFEM, setting the options MFEM_USE_METIS_5 and METIS_DIR , e.g.: ~> cd mfem-3.4 ~/mfem-3.4> make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0","title":"Parallel build using METIS 5"},{"location":"code-overview/","text":"Code Overview MFEM consists of the following closely interconnected modules: General - general data structures and algorithms. Linear Algebra - linear algebra, linear and nonlinear solvers, time steppers. Mesh - mesh class, mesh readers, mesh manipulation. FEM - finite elements, spaces, linear and bilinear forms, etc. General Array Class Array<T> . Similar to std::vector<T> in many respects. Can allocate and manage data or hold external data. Hash table Class HashTable<T> . Used in the NCMesh class. Table Class Table . Maps each row, {0,1,..,n-1} , to a list of integers (columns). This is CSR-like data structure without data, only the ' I ' and ' J ' arrays. Represents relations like vertex-to-element , element-to-dof , etc. Dynamic symmetric table Class DSTable is a dynamic symmetric version of the Table class. Used for building relations like vertex-to-vertex - mesh edges. Dynamic symmetric 3D table Class STable3D . Used for building vertex-to-vertex-to-vertex relations - mesh faces in 3D. Communication Classes GroupTopology , GroupCommunicator . Groups are sets of MPI ranks that need to exchange common data at processor boundaries. Reduce (gather) and broadcast (scatter) MPI communications within groups . Socket stream Class socketstream Two-way TCP sockets as c++ streams. Can be compiled with GnuTLS for security. Primarily used for sending data to GLVis. Timers Class StopWatch . Has various \"backends\" - std::clock , POSIX clocks, Windows' QueryPerformanceCounter etc. Options parser Class OptionsParser . Makes it easy to define and parse command line parameters. Used in all examples and miniapps. Linear Algebra Vector Class Vector - a vector of double s. Can allocate and manage data or warp external data. Defines a number of vector operations on the data. Operator Class Operator An abstract base class for all linear and non-linear operators. Virtual method Mult(const Vector &, Vector &) . Optional virtual method Operator &GetGradient(const Vector &x) . Dense matrix Class DenseMatrix - a matrix of double s. Can allocate and manage data or wrap external data. Uses column-major storage. Defines a number of matrix operations, matrix-vector, etc. Inherits from Operator . Dense tensor Class DenseTensor Can be viewed as an array of DenseMatrix (of the same size). Can be used in batched matrix operations. Sparse matrix Class SparseMatrix - int indices, double data. Compressed sparse row (CSR) or linked list (LIL) storage. Various operations: assembly, matrix-vector, smoothers, etc. Inherits from Operator . Parallel hypre vector Class HypreParVector - wraps hypre's data structure & operations. Parallel hypre matrix Class HypreParMatrix - wraps hypre's data structure & operations. Solvers Abstract base class Solver - extends (inherits) class Operator . Adds virtual method void SetOperator(const Operator &) . Direct dense solver Class DenseMatrixInverse - inherits Solver . Inverts dense matrices, class DenseMatrix . Uses standard LU factorization with pivoting. Iterative solvers Krylov methods, Newton method. Direct sparse solvers Classes UMFPackSolver , KLUSolver - wraps UMFPACK and KLU from SuiteSparse; can be used with SparseMatrix (serial). Class SuperLUSolver - wraps SuperLU_DIST; the parallel matrix needs to be converted to SuperLURowLocMatrix . Class STRUMPACKSolver - wraps STRUMPACK; the parallel matrix needs to be converted to STRUMPACKLURowLocMatrix . Hypre preconditioners and solvers Classes HypreBoomerAMG , HypreAMS , ect. Classes HyprePCG , HypreGMRES . Time dependent operator Class TimeDependentOperator , inherits from Operator . Implements basic virtual methods double GetTime() and void SetTime(const double) . Optional virtual method void ImplicitSolve(const double dt, const Vector &x, Vector &k) - solve backward Euler system; required for implicit time steppers. ODE solvers Abstract base class ODESolver . Has virtual method void Init(TimeDependentOperator &) . Has pure virtual method void Step(Vector &x, double &t, double &dt) . Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods. Symplectic Integrators for Hamiltonian Systems Abstract base class 'SIASolver'. Has virtual method void Init(Operator &, TimeDependentOperator &) . Has pure virtual method void Step(Vector &q, Vector &p, double &t, double &dt) . Derived classes for explicit first and second order integrators. Derived class supporting integration orders from 1 to 4. Constraint operator Class ConstrainedOperator , inherits from Operator . Impose essential boundary conditions on any Operator (matrix-free). Used by Operator::FormLinearSystem() . Block vector Class BlockVector , inherits from Vector . Holds a set of multiple contiguously allocated vectors. Useful for systems of equations with multiple components using different finite element spaces. Block operator Class BlockOperator , inherits from Operator . Each block is itself an Operator . Block matrix Class BlockMatrix , inherits AbstractSparseMatrix . Each block is a SparseMatrix . Supports more operations than BlockOperator . Block diagonal preconditioner Class BlockDiagonalPreconditioner , inherits Solver . Similar to BlockOperator but with diagonal block structure and square diagonal blocks. Mesh Mesh Class Mesh . The mesh topology/connectivity is given by element-to-vertex relation. Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and attribute ( int ). Boundary elements can be included allowing tagging of boundary subsets, e.g. for boundary conditions, by the boundary element attribute. Edges, faces, and other connectivity are derived automatically based on the element type. A high-order mesh uses a vector FE function, i.e. a vector GridFunction , to represent its high-order nodes . Hanging/slave vertices are regular vertices - the mesh is \"cut\" along non-conforming edges and faces. Conforming constraints and interpolation are added at the level of the FiniteElementSpace based on additional data from the Mesh and NCMesh objects. Local conforming refinement for triangles and tets. Local non-conforming refinement for triangles, quads, and hexes. De-refinement and parallel rebalancing for non-conforming meshes. Supports curve and surface meshes. Periodic meshes: periodic topology with a DG GridFunction as nodes, cut along the periodic edges/faces. Non-conforming mesh Class NCMesh . Used through class Mesh . Supports triangles, quads, and hexes including anisotropic refinement for quads and hexes. Arbitrary level of hanging nodes and full refinement hierarchy. Generates the \"cut\" Mesh from the leaf elements. NURBS mesh Class NURBSExtension . Used through class Mesh . The NURBS patch connectivity is itself a quad/hex Mesh . Supports knot insertion, degree elevation, (serial, uniform) h-refinement. Generates a quad/hex Mesh . Easy to convert to a polynomial high-order mesh. Mesh readers and writers Own formats, read and write, for: MFEM mesh v1.0 , MFEM mesh v1.1 (extension for non-conforming meshes), MFEM NURBS mesh v1.0 , and MFEM INLINE mesh v1.0 (boxes). Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files. Write linear and quadratic VTK meshes. Parallel mesh Classes ParMesh , ParNCMesh , ParNURBSExtension . Inherit and extend classes Mesh , NCMesh , NURBSExtension . ParMesh is constructed from a serial Mesh available on all tasks. Built-in mesh partitioning is based on METIS. Parallel conforming and non-conforming refinement. Mesh operators Classes ThresholdRefiner , ThresholdDerefiner , Rebalancer . Finite Elements Quadrature formulas Class IntegrationPoint - coordinates plus weights. Class IntegrationRule - an array of IntegrationPoint s. Class IntegrationRules - container for IntegrationRule s. Element transformation Class ElementTransformation , IsoparametricTransformation . Defined through a FiniteElement Transforms reference IntegrationPoint s into physical Vector s. On demand, computes and stores Jacobian matrix, and weight. Finite elements Abstract base class FiniteElement . Arbitrary order H1_* , L2_* , RT_* , and ND_* elements on segment, triangles, quads, tets, and hexes. Abstract method CalcShape , CalcDShape for scalar FE; CalcVShape , CalcDivShape , CalcCurlShape for vector H(div)/H(curl) FE. Other interpolation and projection methods. Finite element collections Base class FiniteElementCollection . Associates FiniteElement s with elements, faces, edges, vertices. Degrees of freedom on faces/edges/vertices are shared between adjacent elements. Derived classes for arbitrary order H1_* , L2_* , RT_* , and ND_* collections. Finite element space Class FiniteElementSpace . Constructed from a Mesh and a FiniteElementCollection . Defines the mappings elements-to-dofs , faces-to-dofs , etc. Defines, when necessary, a prolongation, P , and a restriction, R , matrices: R.P = I to constrain \"slave\" dofs. On non-conforming meshes, the space is \"cut\" or \"partially conforming\" (before applying P ). The domain of P defines the \"true\" or \"conforming\" dofs. The range of P is a sub-set of the \"partially conforming\" dofs. Grid function Class GridFunction , extends class Vector . A container Vector on the \"partially conforming\" dofs. Defines a number of useful operations like computing values, gradient, etc at quadrature points ( IntegrationPoint or IntegrationRule ). Methods for projecting (interpolating) Coefficient , VectorCoefficient . Methods for computing error norms with respect to a Coefficient . Linear form Class LinearForm , extends class Vector . Assembles r.h.s. vector. Uses a sum of local LinearFormIntegrator s. Bilinear form Class BilinearForm . Assembles linear system matrix. Uses a sum of local BilinearFormIntegrator s. Method FormLinearSystem applies necessary transformations, e.g. $P^T A P$. Mixed bilinear form Class MixedBilinearForm . Coefficients Abstract base classes: Coefficient , VectorCoefficient , and MatrixCoefficient . Derived classes include: ConstantCoefficient , FunctionCoefficient , GridFunctionCoefficient ; VectorFunctionCoefficient , VectorGridFunctionCoefficient , etc. Easy to derive new coefficient classes. Parallel versions ParFiniteElementSpace ParGridFunction ParLinearForm ParBilinearForm etc Error estimators Classes ZienkiewiczZhuEstimator , L2ZienkiewiczZhuEstimator . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Code Overview"},{"location":"code-overview/#code-overview","text":"MFEM consists of the following closely interconnected modules: General - general data structures and algorithms. Linear Algebra - linear algebra, linear and nonlinear solvers, time steppers. Mesh - mesh class, mesh readers, mesh manipulation. FEM - finite elements, spaces, linear and bilinear forms, etc.","title":"Code Overview"},{"location":"code-overview/#general","text":"","title":"General"},{"location":"code-overview/#array","text":"Class Array<T> . Similar to std::vector<T> in many respects. Can allocate and manage data or hold external data.","title":"Array"},{"location":"code-overview/#hash-table","text":"Class HashTable<T> . Used in the NCMesh class.","title":"Hash table"},{"location":"code-overview/#table","text":"Class Table . Maps each row, {0,1,..,n-1} , to a list of integers (columns). This is CSR-like data structure without data, only the ' I ' and ' J ' arrays. Represents relations like vertex-to-element , element-to-dof , etc.","title":"Table"},{"location":"code-overview/#dynamic-symmetric-table","text":"Class DSTable is a dynamic symmetric version of the Table class. Used for building relations like vertex-to-vertex - mesh edges.","title":"Dynamic symmetric table"},{"location":"code-overview/#dynamic-symmetric-3d-table","text":"Class STable3D . Used for building vertex-to-vertex-to-vertex relations - mesh faces in 3D.","title":"Dynamic symmetric 3D table"},{"location":"code-overview/#communication","text":"Classes GroupTopology , GroupCommunicator . Groups are sets of MPI ranks that need to exchange common data at processor boundaries. Reduce (gather) and broadcast (scatter) MPI communications within groups .","title":"Communication"},{"location":"code-overview/#socket-stream","text":"Class socketstream Two-way TCP sockets as c++ streams. Can be compiled with GnuTLS for security. Primarily used for sending data to GLVis.","title":"Socket stream"},{"location":"code-overview/#timers","text":"Class StopWatch . Has various \"backends\" - std::clock , POSIX clocks, Windows' QueryPerformanceCounter etc.","title":"Timers"},{"location":"code-overview/#options-parser","text":"Class OptionsParser . Makes it easy to define and parse command line parameters. Used in all examples and miniapps.","title":"Options parser"},{"location":"code-overview/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"code-overview/#vector","text":"Class Vector - a vector of double s. Can allocate and manage data or warp external data. Defines a number of vector operations on the data.","title":"Vector"},{"location":"code-overview/#operator","text":"Class Operator An abstract base class for all linear and non-linear operators. Virtual method Mult(const Vector &, Vector &) . Optional virtual method Operator &GetGradient(const Vector &x) .","title":"Operator"},{"location":"code-overview/#dense-matrix","text":"Class DenseMatrix - a matrix of double s. Can allocate and manage data or wrap external data. Uses column-major storage. Defines a number of matrix operations, matrix-vector, etc. Inherits from Operator .","title":"Dense matrix"},{"location":"code-overview/#dense-tensor","text":"Class DenseTensor Can be viewed as an array of DenseMatrix (of the same size). Can be used in batched matrix operations.","title":"Dense tensor"},{"location":"code-overview/#sparse-matrix","text":"Class SparseMatrix - int indices, double data. Compressed sparse row (CSR) or linked list (LIL) storage. Various operations: assembly, matrix-vector, smoothers, etc. Inherits from Operator .","title":"Sparse matrix"},{"location":"code-overview/#parallel-hypre-vector","text":"Class HypreParVector - wraps hypre's data structure & operations.","title":"Parallel hypre vector"},{"location":"code-overview/#parallel-hypre-matrix","text":"Class HypreParMatrix - wraps hypre's data structure & operations.","title":"Parallel hypre matrix"},{"location":"code-overview/#solvers","text":"Abstract base class Solver - extends (inherits) class Operator . Adds virtual method void SetOperator(const Operator &) .","title":"Solvers"},{"location":"code-overview/#direct-dense-solver","text":"Class DenseMatrixInverse - inherits Solver . Inverts dense matrices, class DenseMatrix . Uses standard LU factorization with pivoting.","title":"Direct dense solver"},{"location":"code-overview/#iterative-solvers","text":"Krylov methods, Newton method.","title":"Iterative solvers"},{"location":"code-overview/#direct-sparse-solvers","text":"Classes UMFPackSolver , KLUSolver - wraps UMFPACK and KLU from SuiteSparse; can be used with SparseMatrix (serial). Class SuperLUSolver - wraps SuperLU_DIST; the parallel matrix needs to be converted to SuperLURowLocMatrix . Class STRUMPACKSolver - wraps STRUMPACK; the parallel matrix needs to be converted to STRUMPACKLURowLocMatrix .","title":"Direct sparse solvers"},{"location":"code-overview/#hypre-preconditioners-and-solvers","text":"Classes HypreBoomerAMG , HypreAMS , ect. Classes HyprePCG , HypreGMRES .","title":"Hypre preconditioners and solvers"},{"location":"code-overview/#time-dependent-operator","text":"Class TimeDependentOperator , inherits from Operator . Implements basic virtual methods double GetTime() and void SetTime(const double) . Optional virtual method void ImplicitSolve(const double dt, const Vector &x, Vector &k) - solve backward Euler system; required for implicit time steppers.","title":"Time dependent operator"},{"location":"code-overview/#ode-solvers","text":"Abstract base class ODESolver . Has virtual method void Init(TimeDependentOperator &) . Has pure virtual method void Step(Vector &x, double &t, double &dt) . Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods.","title":"ODE solvers"},{"location":"code-overview/#symplectic-integrators-for-hamiltonian-systems","text":"Abstract base class 'SIASolver'. Has virtual method void Init(Operator &, TimeDependentOperator &) . Has pure virtual method void Step(Vector &q, Vector &p, double &t, double &dt) . Derived classes for explicit first and second order integrators. Derived class supporting integration orders from 1 to 4.","title":"Symplectic Integrators for Hamiltonian Systems"},{"location":"code-overview/#constraint-operator","text":"Class ConstrainedOperator , inherits from Operator . Impose essential boundary conditions on any Operator (matrix-free). Used by Operator::FormLinearSystem() .","title":"Constraint operator"},{"location":"code-overview/#block-vector","text":"Class BlockVector , inherits from Vector . Holds a set of multiple contiguously allocated vectors. Useful for systems of equations with multiple components using different finite element spaces.","title":"Block vector"},{"location":"code-overview/#block-operator","text":"Class BlockOperator , inherits from Operator . Each block is itself an Operator .","title":"Block operator"},{"location":"code-overview/#block-matrix","text":"Class BlockMatrix , inherits AbstractSparseMatrix . Each block is a SparseMatrix . Supports more operations than BlockOperator .","title":"Block matrix"},{"location":"code-overview/#block-diagonal-preconditioner","text":"Class BlockDiagonalPreconditioner , inherits Solver . Similar to BlockOperator but with diagonal block structure and square diagonal blocks.","title":"Block diagonal preconditioner"},{"location":"code-overview/#mesh","text":"","title":"Mesh"},{"location":"code-overview/#mesh_1","text":"Class Mesh . The mesh topology/connectivity is given by element-to-vertex relation. Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and attribute ( int ). Boundary elements can be included allowing tagging of boundary subsets, e.g. for boundary conditions, by the boundary element attribute. Edges, faces, and other connectivity are derived automatically based on the element type. A high-order mesh uses a vector FE function, i.e. a vector GridFunction , to represent its high-order nodes . Hanging/slave vertices are regular vertices - the mesh is \"cut\" along non-conforming edges and faces. Conforming constraints and interpolation are added at the level of the FiniteElementSpace based on additional data from the Mesh and NCMesh objects. Local conforming refinement for triangles and tets. Local non-conforming refinement for triangles, quads, and hexes. De-refinement and parallel rebalancing for non-conforming meshes. Supports curve and surface meshes. Periodic meshes: periodic topology with a DG GridFunction as nodes, cut along the periodic edges/faces.","title":"Mesh"},{"location":"code-overview/#non-conforming-mesh","text":"Class NCMesh . Used through class Mesh . Supports triangles, quads, and hexes including anisotropic refinement for quads and hexes. Arbitrary level of hanging nodes and full refinement hierarchy. Generates the \"cut\" Mesh from the leaf elements.","title":"Non-conforming mesh"},{"location":"code-overview/#nurbs-mesh","text":"Class NURBSExtension . Used through class Mesh . The NURBS patch connectivity is itself a quad/hex Mesh . Supports knot insertion, degree elevation, (serial, uniform) h-refinement. Generates a quad/hex Mesh . Easy to convert to a polynomial high-order mesh.","title":"NURBS mesh"},{"location":"code-overview/#mesh-readers-and-writers","text":"Own formats, read and write, for: MFEM mesh v1.0 , MFEM mesh v1.1 (extension for non-conforming meshes), MFEM NURBS mesh v1.0 , and MFEM INLINE mesh v1.0 (boxes). Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files. Write linear and quadratic VTK meshes.","title":"Mesh readers and writers"},{"location":"code-overview/#parallel-mesh","text":"Classes ParMesh , ParNCMesh , ParNURBSExtension . Inherit and extend classes Mesh , NCMesh , NURBSExtension . ParMesh is constructed from a serial Mesh available on all tasks. Built-in mesh partitioning is based on METIS. Parallel conforming and non-conforming refinement.","title":"Parallel mesh"},{"location":"code-overview/#mesh-operators","text":"Classes ThresholdRefiner , ThresholdDerefiner , Rebalancer .","title":"Mesh operators"},{"location":"code-overview/#finite-elements","text":"","title":"Finite Elements"},{"location":"code-overview/#quadrature-formulas","text":"Class IntegrationPoint - coordinates plus weights. Class IntegrationRule - an array of IntegrationPoint s. Class IntegrationRules - container for IntegrationRule s.","title":"Quadrature formulas"},{"location":"code-overview/#element-transformation","text":"Class ElementTransformation , IsoparametricTransformation . Defined through a FiniteElement Transforms reference IntegrationPoint s into physical Vector s. On demand, computes and stores Jacobian matrix, and weight.","title":"Element transformation"},{"location":"code-overview/#finite-elements_1","text":"Abstract base class FiniteElement . Arbitrary order H1_* , L2_* , RT_* , and ND_* elements on segment, triangles, quads, tets, and hexes. Abstract method CalcShape , CalcDShape for scalar FE; CalcVShape , CalcDivShape , CalcCurlShape for vector H(div)/H(curl) FE. Other interpolation and projection methods.","title":"Finite elements"},{"location":"code-overview/#finite-element-collections","text":"Base class FiniteElementCollection . Associates FiniteElement s with elements, faces, edges, vertices. Degrees of freedom on faces/edges/vertices are shared between adjacent elements. Derived classes for arbitrary order H1_* , L2_* , RT_* , and ND_* collections.","title":"Finite element collections"},{"location":"code-overview/#finite-element-space","text":"Class FiniteElementSpace . Constructed from a Mesh and a FiniteElementCollection . Defines the mappings elements-to-dofs , faces-to-dofs , etc. Defines, when necessary, a prolongation, P , and a restriction, R , matrices: R.P = I to constrain \"slave\" dofs. On non-conforming meshes, the space is \"cut\" or \"partially conforming\" (before applying P ). The domain of P defines the \"true\" or \"conforming\" dofs. The range of P is a sub-set of the \"partially conforming\" dofs.","title":"Finite element space"},{"location":"code-overview/#grid-function","text":"Class GridFunction , extends class Vector . A container Vector on the \"partially conforming\" dofs. Defines a number of useful operations like computing values, gradient, etc at quadrature points ( IntegrationPoint or IntegrationRule ). Methods for projecting (interpolating) Coefficient , VectorCoefficient . Methods for computing error norms with respect to a Coefficient .","title":"Grid function"},{"location":"code-overview/#linear-form","text":"Class LinearForm , extends class Vector . Assembles r.h.s. vector. Uses a sum of local LinearFormIntegrator s.","title":"Linear form"},{"location":"code-overview/#bilinear-form","text":"Class BilinearForm . Assembles linear system matrix. Uses a sum of local BilinearFormIntegrator s. Method FormLinearSystem applies necessary transformations, e.g. $P^T A P$.","title":"Bilinear form"},{"location":"code-overview/#mixed-bilinear-form","text":"Class MixedBilinearForm .","title":"Mixed bilinear form"},{"location":"code-overview/#coefficients","text":"Abstract base classes: Coefficient , VectorCoefficient , and MatrixCoefficient . Derived classes include: ConstantCoefficient , FunctionCoefficient , GridFunctionCoefficient ; VectorFunctionCoefficient , VectorGridFunctionCoefficient , etc. Easy to derive new coefficient classes.","title":"Coefficients"},{"location":"code-overview/#parallel-versions","text":"ParFiniteElementSpace ParGridFunction ParLinearForm ParBilinearForm etc","title":"Parallel versions"},{"location":"code-overview/#error-estimators","text":"Classes ZienkiewiczZhuEstimator , L2ZienkiewiczZhuEstimator . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Error estimators"},{"location":"download/","text":"Latest Release New features \u250a Example codes \u250a Code documentation \u250a Sources Download mfem-4.0tgz Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size SLOC Notes mfem-4.0.tgz v4.0 May 2019 5.2M 167K GPU support mfem-3.4.tgz v3.4 May 2018 4.4M 134K mfem-3.3.2.tgz v3.3.2 Nov 2017 4.2M 123K mesh optimization mfem-3.3.tgz v3.3 Jan 2017 4.0M 112K mfem-3.2.tgz v3.2 Jun 2016 3.3M 92K dynamic AMR, HPC miniapps mfem-3.1.tgz v3.1 Feb 2016 2.9M 80K fem \u2194 linear system interface mfem-3.0.1.tgz v3.0.1 Jan 2015 1.1M 61K mfem-3.0.tgz v3.0 Jan 2015 1.1M 61K non-conforming AMR mfem-2.0.tgz v2.0 Nov 2011 308K 40K arbitrary order spaces, NURBS mfem-v1.2.2.tgz v1.2.2 Apr 2011 240K 28K mfem-v1.2.1.tgz v1.2.1 Apr 2011 240K 28K mfem-v1.2.tgz v1.2 Apr 2011 240K 28K MPI parallelism based on hypre mfem-v1.1.tgz v1.1 Sep 2010 166K 23K mfem-v1.0.tgz v1.0 Jul 2010 160K 22K initial release","title":"Download"},{"location":"download/#latest-release","text":"New features \u250a Example codes \u250a Code documentation \u250a Sources Download mfem-4.0tgz Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download/#all-releases","text":"Filename Version Release Date Size SLOC Notes mfem-4.0.tgz v4.0 May 2019 5.2M 167K GPU support mfem-3.4.tgz v3.4 May 2018 4.4M 134K mfem-3.3.2.tgz v3.3.2 Nov 2017 4.2M 123K mesh optimization mfem-3.3.tgz v3.3 Jan 2017 4.0M 112K mfem-3.2.tgz v3.2 Jun 2016 3.3M 92K dynamic AMR, HPC miniapps mfem-3.1.tgz v3.1 Feb 2016 2.9M 80K fem \u2194 linear system interface mfem-3.0.1.tgz v3.0.1 Jan 2015 1.1M 61K mfem-3.0.tgz v3.0 Jan 2015 1.1M 61K non-conforming AMR mfem-2.0.tgz v2.0 Nov 2011 308K 40K arbitrary order spaces, NURBS mfem-v1.2.2.tgz v1.2.2 Apr 2011 240K 28K mfem-v1.2.1.tgz v1.2.1 Apr 2011 240K 28K mfem-v1.2.tgz v1.2 Apr 2011 240K 28K MPI parallelism based on hypre mfem-v1.1.tgz v1.1 Sep 2010 166K 23K mfem-v1.0.tgz v1.0 Jul 2010 160K 22K initial release","title":"All Releases"},{"location":"electromagnetics/","text":"Electromagnetics Mini Applications $\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}} \\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}} \\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}} \\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}} \\newcommand{\\F}{\\vec{F}} \\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla}$ The miniapps/electromagnetics directory contains a collection of electromagnetic miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current electromagnetic miniapps are described below. Electromagnetics The equations describing electromagnetic phenomena are known collectively as the Maxwell Equations. They are usually given as: $$\\begin{align} \\curl\\H - \\dd{\\D}{t} & = \\J \\label{ampere} \\\\ \\curl\\E + \\dd{\\B}{t} & = 0 \\label{faraday} \\\\ \\div\\D & = \\rho \\label{gauss} \\\\ \\div\\B & = 0 \\label{divb} \\end{align}$$ Where equation \\eqref{ampere} can be referred to as Amp\u00e9re's Law , equation \\eqref{faraday} is called Faraday's Law , equation \\eqref{gauss} is Gauss's Law , and equation \\eqref{divb} doesn't generally have a name but is related to the nonexistence of magnetic monopoles. The various fields in these equations are: Symbol Name SI Units $\\H$ magnetic field Ampere/meter $\\B$ magnetic flux density Tesla $\\E$ electric field Volts/meter $\\D$ electric displacement Coulomb/meter$^2$ $\\J$ current density Ampere/meter$^2$ $\\rho$ charge density Coulomb/meter$^3$ In the literature these names do vary, particularly those for $\\H$ and $\\B$, but in this document we will try to adhere to the convention laid out above. Generally we also need constitutive relations between $\\E$ and $\\D$ and/or between $\\H$ and $\\B$. These relations start with the definitions: $$\\begin{align} \\D & = \\epsilon_0\\E + \\P \\label{const_d} \\\\ \\B & = \\mu_0(\\H + \\M) \\label{const_b} \\end{align}$$ Where $\\P$ is the polarization density , and $\\M$ is the magnetization . Also, $\\epsilon_0$ is the permittivity of free space and $\\mu_0$ is the permeability of free space which are both constants of nature. In many common materials the polarization density can be approximated as a scalar multiple of the electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D = \\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity of the material. The nature of magnetization is more complicated but we will take a very simplified view which is valid in many situations. Specifically, we will assume that either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$ where $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the magnetic susceptibility or that $\\M$ is independent of the applied field. The former case pertains to both diamagnetic and paramagnetic materials and the latter to ferromagnetic materials. Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be combined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$ which can be important in plasma physics and magnetohydrodynamics (MHD). Electrostatics Electrostatic problems come in a variety of subtypes but they all derive from Gauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}). When we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$. This suggests that the electric field can be expressed as the gradient of a scalar field which is traditionally taken to be $-\\varphi$, i.e. $$\\E = -\\grad\\varphi \\label{gradphi}$$ where $\\varphi$ is called the electric potential and has units of Volts in the SI system. Inserting this definition into equation \\eqref{gauss} gives: $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P \\label{poisson}$$ which is Poisson's equation for the electric potential, where we have assumed a linear constitutive relation between $\\D$ and $\\E$ of the form $\\D = \\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as well a polarization independent of $\\E$. If this relation happens to be nonlinear then Poisson's equation would need to be replaced with a more complicated nonlinear expression. The solutions to equation \\eqref{poisson} are non unique because they can be shifted by any additive constant. This means that we must apply a Dirichlet boundary condition at least at one point in the problem domain in order to obtain a solution. Typically this point will be on the boundary but it need not be so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a. potential) at one or more locations. Additionally, this equation admits a normal derivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a prescribed value on some portion of the boundary. This is equivalent to defining a surface charge density on that portion of the boundary. Volta Mini Application The electrostatics mini application, named volta after the inventor of the voltaic pile , is intended to demonstrate how to solve standard electrostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters. Mini Application Features Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Charge Density: The charge density, $\\rho$, is assumed to be zero except for an optional sphere of uniform charge density which can be defined by the user. The command line option for this is -cs which follows the same pattern as the dielectric sphere. Note that the last entry is the total charge of the sphere and not its charge density. Polarization: A polarization vector function, $\\P$, can be imposed as a source of the electric field. The command line option -vp creates a polarization due to a simple voltaic pile, i.e., a cylinder which is electrically polarized along its axis. The user should specify the two end points of the cylinder axis, its radius and the magnitude of the polarization vector. Dirichlet BC: Dirichlet boundary conditions can either specify piecewise constant voltages on a collection of surfaces or they can specify a gradient field which approximates a uniform applied electric field. In either case the user specifies the surfaces where the Dirichlet boundary condition should be applied using the -dbcs option followed by a list of boundary attributes. For example to select surfaces 2, 3, and 4 the user would use the following: -dbcs '2 3 4' . To apply a gradient field on these surfaces the user would also use the -dbcg option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with -uebc followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would supply: -uebc '1 2 3' . To specify piecewise constant potential values the user would list the desired values after -dbcv as follows: -dbcv '0.0 1.0 -1.0' . Neumann BC: Neumann boundary conditions set the normal component of the electric displacement on portions of the boundary. This normal component is equivalent to the surface charge density on the surface. This is rarely used because surface charge densities are rarely known unless they are know to be zero. However, if the surface charge density is zero then the Neumann BCs are not needed because this is the natural boundary condition. Only piecewise constant Neumann boundary conditions are supported. They can be set analogously to piecewise Dirichlet boundary conditions but using options -nbcs and -nbcv . Magnetostatics Magnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law \\eqref{ampere} which leads to: $$\\curl\\H = \\J \\nonumber$$ We will again assume a somewhat more general constitutive relation between $\\H$ and $\\vec{B}$ than is normally seen: $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M \\nonumber$$ Where the magnetization is split into two portions; one which is proportional to $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and is given by $\\M$. This allows for paramagnetic and/or diamagnetic materials defined through $\\mu$ as well as ferromagnetic materials represented by $\\M$. This choice yields: $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M \\nonumber$$ Which, when combined with equation \\eqref{divb}, becomes: $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$ If $\\J$ happens to be zero we have another option because we can assume that $\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined with equation \\eqref{divb} this leads to: $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$ Currently only the vector potential equation is used so we will focus on that for the remainder of this document. The vector potential is again non unique so we must apply additional constraints in order to arrive at a solution for $\\A$. When working analytically it is common to constrain the solution by restricting the divergence of $\\A$ but numerically this leads to other complications. For our problems of interest it will be necessary to require Dirichlet boundary conditions on the entire outer surface in order to sufficiently constrain the solution. Dirichlet boundary conditions for the vector potential on a surface provide a means to specify the component of $\\B$ normal to that surface. For example, setting the tangential components of $\\A$ to be zero on a particular surface results in a magnetic flux density which must be tangent to that surface. Tesla Mini Application The magnetostatics mini application, named tesla after the unit of magnetic field strength (and of course the man Nikola Tesla), is intended to demonstrate how to solve standard magnetostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources of boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters. Mini Application Features Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional ring of constant current which can be defined by the user. The command line option for this is -cr which requires two points giving the end points of the ring's axis, inner and outer radii, and a constant total current. For example, to specify a ring centered at the origin and laying in the XY plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps the user would give: -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 . Magnetization: A permanent magnetization, $\\M$, can be applied in the form of a cylindrical magnet with poles at its circular ends. The command line option is -bm which indicates a 'bar magnet'. The option requires the two end points of the cylinder's axis, its radius, and the magnitude of the magnetization. Surface Current Density: A surface current can be imposed indirectly by specifying separate surface patches with different voltages as well as a collection of surface patches connecting the voltages through which the current will flow. The voltage surfaces and their voltages can be specified using -vbcs followed by the indices of the surfaces and -vbcv followed by their voltages. The path for the surface current ($\\vec{K}$) is specified by using -kbcs followed by a set of surface indices. For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current path along surfaces 4 and 6 would be specified as: -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' . Any surfaces not listed as voltage or current surfaces will be assigned as homogeneous Dirichlet boundaries. Note that when this option is selected an auxiliary electrostatic problem will be solved on the surface of the geometry to compute the surface current. Dirichlet BC: Dirichlet boundary conditions are required if a surface current density is not defined. For this reason the user need not specify boundary surfaces by number since the boundary condition must be applied on all of them. The default boundary condition is a homogeneous Dirichlet boundary condition on all outer surfaces. This means that the normal component of $\\B$ will be zero at the outer boundary. An alternative is to specify a desired uniform magnetic flux density on the entire outer surface. This is accomplished with the -ubbc command line option followed by the desired $\\B$ vector. Transient Full-Wave Electromagnetics Transient electromagnetics problems are governed by the time-dependent Maxwell equations \\eqref{ampere} and \\eqref{faraday} when combined using the constitutive relations \\eqref{const_d} and \\eqref{const_b}. When combined these equations can describe the evolution and propagation of electromagnetic waves. $$\\begin{align} \\dd{(\\epsilon\\E)}{t} & = \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J \\\\ \\dd{\\B}{t} & = - \\curl\\E \\end{align}$$ The term $\\sigma\\E$ arises in the presence of electrically conductive materials where the electric field induces a current which can be separated from $\\J$. In such cases the total current appearing in Amp\u00e9re's Law \\eqref{ampere} can be expressed as the sum of an applied current (also labeled as $\\J$) and an induced current $\\sigma\\E$. Solving these equations requires initial conditions for both the electric and magnetic fields $\\E$ and $\\B$ as well as boundary conditions related to the tangential components of $\\E$ or $\\H$. Other formulations are possible such as evolving $\\H$ and $\\D$ or the potentials $\\varphi$ and $\\A$. This system of equations can also be written as a single second order equation involving only $\\E$, $\\H$, $\\varphi$, or $\\A$. Each of these formulations has a different set of sources, initial and boundary conditions for which it is well-suited. The choice we make here is perhaps the most common but it may not be the most convenient choice for a given application. These equations can be used to evolve their initial conditions or they can be driven by either a current source or through time-varying boundary conditions. It is also possible to combine all three of these sources in a single simulation. Maxwell Mini Application The electrodynamics mini application, named maxwell after James Clerk Maxwell who first formulated the classical theory of electromagnetic radiation, is intended to demonstrate how to solve transient wave problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. An example simulation is depicted below (click to animate the wave propagation). Time integration is handled by a variable order symplectic time integration algorithm. This algorithm is designed for systems of equations which are derived from a Hamiltonian and it helps to ensure energy conservation within some tolerance. The time step used during integration is automatically chosen based on the largest stable time step as computed from the largest eigenvalue of the update equations. This determination involves a user-adjustable factor which creates a safety margin. By default the actual time step is less than 95% of the estimate for the largest stable time step. Note that this application assumes the mesh coordinates are given in meters. Internally the code assumes time is in seconds but the command line options use nanoseconds for convenience. Mini Application Features Time Evolution: The initial and final times for the simulation can be specified, in nanoseconds, with the -ti and -tf options. Visualization snapshots of data will be written out after time intervals specified by -ts which again given in nanoseconds. The order of the time integration can be specified, from 1 to 4, using the -to option. Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Conductivity: The conductivity, $\\sigma$, is assumed to be zero except for an optional sphere of conductive material which can be defined by the user. The command line option -cs can be used to set the parameters for this conductive sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify: -cs '0 0 0 0.5 3e6' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional cylinder of pulsed current which can be defined by the user. The command line option for this is -dp , short for 'dipole pulse', which requires two points giving the end points of the cylinder's axis, radius, amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$). The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds. Dirichlet BC: Homogeneous Dirichlet boundary conditions, which constrain the tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be activated on a portion of the boundary by specifying a list of boundary attributes such as -dbcs '4 8' . For convenience a boundary attribute of '-1' can be used to specify all boundary surfaces. Non-Homogeneous, time-dependent Dirichlet boundary conditions are supported by the Maxwell solver so a user can edit maxwell.cpp and supply their own function if desired. Absorbing BC: A first order Sommerfeld absorbing boundary condition can be applied to a portion of the boundary using the -abcs option along with a list of boundary attributes such as -abcs '4 18' . Again, the special purpose boundary attribute '-1' can be used to specify all boundary surfaces. This boundary condition depends on a coefficient, $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just inside the boundary. The code assumes that the permittivity and permeability are those of the vacuum near the surface but, if this is not the case, an ambitious user can replace etaInvCoef_ with a more appropriate function. Transient Magnetics and Joule Heating Joule Mini Application The transient magnetics mini application, named joule after the SI unit of energy (and the scientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve transient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled with the equations of heat transfer. The coupling is one way, electromagnetics generates Joule heating, but the heating does not affect the electromagnetics. The thermal problem is solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the thermal flux $\\F$ is in $H(\\mathrm{div})$. There are three linear solves per time step: Poisson's equation for the scalar electric potential is solved using the AMG preconditioner, the electric diffusion equation is solved using the AMS preconditioner, and the thermal diffusion equation is solved using the ADS preconditioner. Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical coil in vacuum (the latter is 21MB and can be downloaded from here ). The idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses into the metal, the metal is heated by Joule heating, the heat diffuses out. The equations are: $$\\begin{align} \\div\\sigma\\grad\\Phi &= 0 \\\\ \\sigma \\E &= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\ \\frac{d \\B}{d t} &= - \\curl \\E \\\\ \\F &= -k \\grad T \\\\ c \\frac{d T}{d t} &= - \\div \\F + \\sigma \\E \\cdot \\E \\end{align}$$ The equations are integrated in time using implicit time integration, either midpoint or higher order SDIRK. Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the scalar potential, the electric field, and the thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. Note that this application assumes the mesh coordinates are given in meters. The above picture shows Joule heating of a cylinder using the mesh cylinder-hex.mesh . The cylinder is surrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat flux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature. Mini Application Features Boundary Conditions: Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . Note that the essential BC's can be time varying. Material Properties: There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Electromagnetics"},{"location":"electromagnetics/#electromagnetics-mini-applications","text":"$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}} \\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}} \\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}} \\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}} \\newcommand{\\F}{\\vec{F}} \\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}} \\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla}$ The miniapps/electromagnetics directory contains a collection of electromagnetic miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current electromagnetic miniapps are described below.","title":"Electromagnetics Mini Applications"},{"location":"electromagnetics/#electromagnetics","text":"The equations describing electromagnetic phenomena are known collectively as the Maxwell Equations. They are usually given as: $$\\begin{align} \\curl\\H - \\dd{\\D}{t} & = \\J \\label{ampere} \\\\ \\curl\\E + \\dd{\\B}{t} & = 0 \\label{faraday} \\\\ \\div\\D & = \\rho \\label{gauss} \\\\ \\div\\B & = 0 \\label{divb} \\end{align}$$ Where equation \\eqref{ampere} can be referred to as Amp\u00e9re's Law , equation \\eqref{faraday} is called Faraday's Law , equation \\eqref{gauss} is Gauss's Law , and equation \\eqref{divb} doesn't generally have a name but is related to the nonexistence of magnetic monopoles. The various fields in these equations are: Symbol Name SI Units $\\H$ magnetic field Ampere/meter $\\B$ magnetic flux density Tesla $\\E$ electric field Volts/meter $\\D$ electric displacement Coulomb/meter$^2$ $\\J$ current density Ampere/meter$^2$ $\\rho$ charge density Coulomb/meter$^3$ In the literature these names do vary, particularly those for $\\H$ and $\\B$, but in this document we will try to adhere to the convention laid out above. Generally we also need constitutive relations between $\\E$ and $\\D$ and/or between $\\H$ and $\\B$. These relations start with the definitions: $$\\begin{align} \\D & = \\epsilon_0\\E + \\P \\label{const_d} \\\\ \\B & = \\mu_0(\\H + \\M) \\label{const_b} \\end{align}$$ Where $\\P$ is the polarization density , and $\\M$ is the magnetization . Also, $\\epsilon_0$ is the permittivity of free space and $\\mu_0$ is the permeability of free space which are both constants of nature. In many common materials the polarization density can be approximated as a scalar multiple of the electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D = \\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity of the material. The nature of magnetization is more complicated but we will take a very simplified view which is valid in many situations. Specifically, we will assume that either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$ where $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the magnetic susceptibility or that $\\M$ is independent of the applied field. The former case pertains to both diamagnetic and paramagnetic materials and the latter to ferromagnetic materials. Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be combined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$ which can be important in plasma physics and magnetohydrodynamics (MHD).","title":"Electromagnetics"},{"location":"electromagnetics/#electrostatics","text":"Electrostatic problems come in a variety of subtypes but they all derive from Gauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}). When we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$. This suggests that the electric field can be expressed as the gradient of a scalar field which is traditionally taken to be $-\\varphi$, i.e. $$\\E = -\\grad\\varphi \\label{gradphi}$$ where $\\varphi$ is called the electric potential and has units of Volts in the SI system. Inserting this definition into equation \\eqref{gauss} gives: $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P \\label{poisson}$$ which is Poisson's equation for the electric potential, where we have assumed a linear constitutive relation between $\\D$ and $\\E$ of the form $\\D = \\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as well a polarization independent of $\\E$. If this relation happens to be nonlinear then Poisson's equation would need to be replaced with a more complicated nonlinear expression. The solutions to equation \\eqref{poisson} are non unique because they can be shifted by any additive constant. This means that we must apply a Dirichlet boundary condition at least at one point in the problem domain in order to obtain a solution. Typically this point will be on the boundary but it need not be so. Such a Dirichlet value is equivalent to fixing the voltage (a.k.a. potential) at one or more locations. Additionally, this equation admits a normal derivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a prescribed value on some portion of the boundary. This is equivalent to defining a surface charge density on that portion of the boundary.","title":"Electrostatics"},{"location":"electromagnetics/#volta-mini-application","text":"The electrostatics mini application, named volta after the inventor of the voltaic pile , is intended to demonstrate how to solve standard electrostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters.","title":"Volta Mini Application"},{"location":"electromagnetics/#mini-application-features","text":"Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Charge Density: The charge density, $\\rho$, is assumed to be zero except for an optional sphere of uniform charge density which can be defined by the user. The command line option for this is -cs which follows the same pattern as the dielectric sphere. Note that the last entry is the total charge of the sphere and not its charge density. Polarization: A polarization vector function, $\\P$, can be imposed as a source of the electric field. The command line option -vp creates a polarization due to a simple voltaic pile, i.e., a cylinder which is electrically polarized along its axis. The user should specify the two end points of the cylinder axis, its radius and the magnitude of the polarization vector. Dirichlet BC: Dirichlet boundary conditions can either specify piecewise constant voltages on a collection of surfaces or they can specify a gradient field which approximates a uniform applied electric field. In either case the user specifies the surfaces where the Dirichlet boundary condition should be applied using the -dbcs option followed by a list of boundary attributes. For example to select surfaces 2, 3, and 4 the user would use the following: -dbcs '2 3 4' . To apply a gradient field on these surfaces the user would also use the -dbcg option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with -uebc followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would supply: -uebc '1 2 3' . To specify piecewise constant potential values the user would list the desired values after -dbcv as follows: -dbcv '0.0 1.0 -1.0' . Neumann BC: Neumann boundary conditions set the normal component of the electric displacement on portions of the boundary. This normal component is equivalent to the surface charge density on the surface. This is rarely used because surface charge densities are rarely known unless they are know to be zero. However, if the surface charge density is zero then the Neumann BCs are not needed because this is the natural boundary condition. Only piecewise constant Neumann boundary conditions are supported. They can be set analogously to piecewise Dirichlet boundary conditions but using options -nbcs and -nbcv .","title":"Mini Application Features"},{"location":"electromagnetics/#magnetostatics","text":"Magnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law \\eqref{ampere} which leads to: $$\\curl\\H = \\J \\nonumber$$ We will again assume a somewhat more general constitutive relation between $\\H$ and $\\vec{B}$ than is normally seen: $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M \\nonumber$$ Where the magnetization is split into two portions; one which is proportional to $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and is given by $\\M$. This allows for paramagnetic and/or diamagnetic materials defined through $\\mu$ as well as ferromagnetic materials represented by $\\M$. This choice yields: $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M \\nonumber$$ Which, when combined with equation \\eqref{divb}, becomes: $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$ If $\\J$ happens to be zero we have another option because we can assume that $\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined with equation \\eqref{divb} this leads to: $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$ Currently only the vector potential equation is used so we will focus on that for the remainder of this document. The vector potential is again non unique so we must apply additional constraints in order to arrive at a solution for $\\A$. When working analytically it is common to constrain the solution by restricting the divergence of $\\A$ but numerically this leads to other complications. For our problems of interest it will be necessary to require Dirichlet boundary conditions on the entire outer surface in order to sufficiently constrain the solution. Dirichlet boundary conditions for the vector potential on a surface provide a means to specify the component of $\\B$ normal to that surface. For example, setting the tangential components of $\\A$ to be zero on a particular surface results in a magnetic flux density which must be tangent to that surface.","title":"Magnetostatics"},{"location":"electromagnetics/#tesla-mini-application","text":"The magnetostatics mini application, named tesla after the unit of magnetic field strength (and of course the man Nikola Tesla), is intended to demonstrate how to solve standard magnetostatics problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources of boundary conditions could be implemented. Note that this application assumes the mesh coordinates are given in meters.","title":"Tesla Mini Application"},{"location":"electromagnetics/#mini-application-features_1","text":"Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional ring of constant current which can be defined by the user. The command line option for this is -cr which requires two points giving the end points of the ring's axis, inner and outer radii, and a constant total current. For example, to specify a ring centered at the origin and laying in the XY plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps the user would give: -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 . Magnetization: A permanent magnetization, $\\M$, can be applied in the form of a cylindrical magnet with poles at its circular ends. The command line option is -bm which indicates a 'bar magnet'. The option requires the two end points of the cylinder's axis, its radius, and the magnitude of the magnetization. Surface Current Density: A surface current can be imposed indirectly by specifying separate surface patches with different voltages as well as a collection of surface patches connecting the voltages through which the current will flow. The voltage surfaces and their voltages can be specified using -vbcs followed by the indices of the surfaces and -vbcv followed by their voltages. The path for the surface current ($\\vec{K}$) is specified by using -kbcs followed by a set of surface indices. For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current path along surfaces 4 and 6 would be specified as: -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' . Any surfaces not listed as voltage or current surfaces will be assigned as homogeneous Dirichlet boundaries. Note that when this option is selected an auxiliary electrostatic problem will be solved on the surface of the geometry to compute the surface current. Dirichlet BC: Dirichlet boundary conditions are required if a surface current density is not defined. For this reason the user need not specify boundary surfaces by number since the boundary condition must be applied on all of them. The default boundary condition is a homogeneous Dirichlet boundary condition on all outer surfaces. This means that the normal component of $\\B$ will be zero at the outer boundary. An alternative is to specify a desired uniform magnetic flux density on the entire outer surface. This is accomplished with the -ubbc command line option followed by the desired $\\B$ vector.","title":"Mini Application Features"},{"location":"electromagnetics/#transient-full-wave-electromagnetics","text":"Transient electromagnetics problems are governed by the time-dependent Maxwell equations \\eqref{ampere} and \\eqref{faraday} when combined using the constitutive relations \\eqref{const_d} and \\eqref{const_b}. When combined these equations can describe the evolution and propagation of electromagnetic waves. $$\\begin{align} \\dd{(\\epsilon\\E)}{t} & = \\curl(\\mu^{-1}\\B) - \\sigma \\E - \\J \\\\ \\dd{\\B}{t} & = - \\curl\\E \\end{align}$$ The term $\\sigma\\E$ arises in the presence of electrically conductive materials where the electric field induces a current which can be separated from $\\J$. In such cases the total current appearing in Amp\u00e9re's Law \\eqref{ampere} can be expressed as the sum of an applied current (also labeled as $\\J$) and an induced current $\\sigma\\E$. Solving these equations requires initial conditions for both the electric and magnetic fields $\\E$ and $\\B$ as well as boundary conditions related to the tangential components of $\\E$ or $\\H$. Other formulations are possible such as evolving $\\H$ and $\\D$ or the potentials $\\varphi$ and $\\A$. This system of equations can also be written as a single second order equation involving only $\\E$, $\\H$, $\\varphi$, or $\\A$. Each of these formulations has a different set of sources, initial and boundary conditions for which it is well-suited. The choice we make here is perhaps the most common but it may not be the most convenient choice for a given application. These equations can be used to evolve their initial conditions or they can be driven by either a current source or through time-varying boundary conditions. It is also possible to combine all three of these sources in a single simulation.","title":"Transient Full-Wave Electromagnetics"},{"location":"electromagnetics/#maxwell-mini-application","text":"The electrodynamics mini application, named maxwell after James Clerk Maxwell who first formulated the classical theory of electromagnetic radiation, is intended to demonstrate how to solve transient wave problems in MFEM. Its source terms and boundary conditions are simple but they should indicate how more specialized sources or boundary conditions could be implemented. An example simulation is depicted below (click to animate the wave propagation). Time integration is handled by a variable order symplectic time integration algorithm. This algorithm is designed for systems of equations which are derived from a Hamiltonian and it helps to ensure energy conservation within some tolerance. The time step used during integration is automatically chosen based on the largest stable time step as computed from the largest eigenvalue of the update equations. This determination involves a user-adjustable factor which creates a safety margin. By default the actual time step is less than 95% of the estimate for the largest stable time step. Note that this application assumes the mesh coordinates are given in meters. Internally the code assumes time is in seconds but the command line options use nanoseconds for convenience.","title":"Maxwell Mini Application"},{"location":"electromagnetics/#mini-application-features_2","text":"Time Evolution: The initial and final times for the simulation can be specified, in nanoseconds, with the -ti and -tf options. Visualization snapshots of data will be written out after time intervals specified by -ts which again given in nanoseconds. The order of the time integration can be specified, from 1 to 4, using the -to option. Permittivity: The permittivity, $\\epsilon$, is assumed to be that of free space except for an optional sphere of dielectric material which can be defined by the user. The command line option -ds can be used to set the parameters for this dielectric sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a relative permittivity of 3 the user would specify: -ds '0 0 0 0.5 3' . Permeability: The permeability, $\\mu$, is assumed to be that of free space except for an optional spherical shell of diamagnetic or paramagnetic material which can be defined by the user. The command line option -ms can be used to set the parameters for this shell. For example, to produce a shell at the origin with inner and outer radii of 0.4 and 0.5 respectively and a relative permeability of 3 the user would specify: -ms '0 0 0 0.4 0.5 3' . Conductivity: The conductivity, $\\sigma$, is assumed to be zero except for an optional sphere of conductive material which can be defined by the user. The command line option -cs can be used to set the parameters for this conductive sphere. For example, to produce a sphere at the origin with a radius of 0.5 and a conductivity of 3,000,000 S/m the user would specify: -cs '0 0 0 0.5 3e6' . Current Density: The current density, $\\J$, is assumed to be zero except for an optional cylinder of pulsed current which can be defined by the user. The command line option for this is -dp , short for 'dipole pulse', which requires two points giving the end points of the cylinder's axis, radius, amplitude ($\\alpha$), pulse center ($\\beta$), and a pulse width ($\\gamma$). The time dependence of this pulse is given by: $$\\J(t) = \\hat{a} \\alpha e^{-(t-\\beta)^2/(2\\gamma^2)}$$ Where $\\hat{a}$ is the unit vector along the cylinder's axis and both $\\beta$ and $\\gamma$ are specified in nanoseconds. Dirichlet BC: Homogeneous Dirichlet boundary conditions, which constrain the tangential components of $\\frac{\\partial\\E}{\\partial t}$ to be zero, can be activated on a portion of the boundary by specifying a list of boundary attributes such as -dbcs '4 8' . For convenience a boundary attribute of '-1' can be used to specify all boundary surfaces. Non-Homogeneous, time-dependent Dirichlet boundary conditions are supported by the Maxwell solver so a user can edit maxwell.cpp and supply their own function if desired. Absorbing BC: A first order Sommerfeld absorbing boundary condition can be applied to a portion of the boundary using the -abcs option along with a list of boundary attributes such as -abcs '4 18' . Again, the special purpose boundary attribute '-1' can be used to specify all boundary surfaces. This boundary condition depends on a coefficient, $\\eta^{-1}=\\sqrt{\\epsilon/\\mu}$, which must be matched to the materials just inside the boundary. The code assumes that the permittivity and permeability are those of the vacuum near the surface but, if this is not the case, an ambitious user can replace etaInvCoef_ with a more appropriate function.","title":"Mini Application Features"},{"location":"electromagnetics/#transient-magnetics-and-joule-heating","text":"","title":"Transient Magnetics and Joule Heating"},{"location":"electromagnetics/#joule-mini-application","text":"The transient magnetics mini application, named joule after the SI unit of energy (and the scientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve transient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled with the equations of heat transfer. The coupling is one way, electromagnetics generates Joule heating, but the heating does not affect the electromagnetics. The thermal problem is solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the thermal flux $\\F$ is in $H(\\mathrm{div})$. There are three linear solves per time step: Poisson's equation for the scalar electric potential is solved using the AMG preconditioner, the electric diffusion equation is solved using the AMS preconditioner, and the thermal diffusion equation is solved using the ADS preconditioner. Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical coil in vacuum (the latter is 21MB and can be downloaded from here ). The idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses into the metal, the metal is heated by Joule heating, the heat diffuses out. The equations are: $$\\begin{align} \\div\\sigma\\grad\\Phi &= 0 \\\\ \\sigma \\E &= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\ \\frac{d \\B}{d t} &= - \\curl \\E \\\\ \\F &= -k \\grad T \\\\ c \\frac{d T}{d t} &= - \\div \\F + \\sigma \\E \\cdot \\E \\end{align}$$ The equations are integrated in time using implicit time integration, either midpoint or higher order SDIRK. Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the scalar potential, the electric field, and the thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. Note that this application assumes the mesh coordinates are given in meters. The above picture shows Joule heating of a cylinder using the mesh cylinder-hex.mesh . The cylinder is surrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat flux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.","title":"Joule Mini Application"},{"location":"electromagnetics/#mini-application-features_3","text":"Boundary Conditions: Since there are three solves, three sets of boundary conditions must be specified. The essential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux. These are not set via command line arguments, you have to edit the code to change these. To change these, search the code for ess_bdr . Note that the essential BC's can be time varying. Material Properties: There are conducting and non-conducting material regions, and the mesh must have integer attributes to specify these regions. To change these, search the code for std::map<int, double> this maps the integer attribute to the floating-point material value. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Mini Application Features"},{"location":"examples/","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Codes and Miniapps This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Clicking on any of the categories below displays examples and miniapps that contain the described feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments . Application (PDE) All Laplace Elasticity Electromagnetics grad-div Darcy Advection Conduction Hydrodynamics Meshing High-performance Finite Elements All $L_2$ discontinuous elements $H^1$ nodal elements $H(curl)$ Nedelec elements $H(div)$ Raviart-Thomas elements $H^{-1/2}$ interfacial elements Discretization All Galerkin FEM Mixed FEM Discontinuous Galerkin (DG) Discont. Petrov-Galerkin (DPG) Hybridization Static condensation Isogeometric analysis (NURBS) Adaptive mesh refinement (AMR) Solver All Jacobi Gauss-Seidel PCG MINRES GMRES Algebraic Multigrid (BoomerAMG) Auxiliary-space Maxwell Solver (AMS) Auxiliary-space Divergence Solver (ADS) SuperLU/STRUMPACK (parallel direct) UMFPACK (serial direct) Newton method (nonlinear solver) Explicit Runge-Kutta (ODE integration) Implicit Runge-Kutta (ODE integration) Symplectic Algorithm (ODE Integration) LOBPCG, AME (eigensolvers) SUNDIALS solvers PETSc solvers HiOp solvers Example 1: Laplace Problem This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . Example 2: Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example. Example 3: Definite Maxwell Problem This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-2 before viewing this example. Example 4: Grad-div Problem This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-3 before viewing this example. Example 5: Darcy Problem This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in a VisIt visualization format. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-4 before viewing this example. Example 6: Laplace Problem with AMR This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example. Example 7: Surface Meshes This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 8: DPG for the Laplace Problem This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example. Example 9: DG Advection This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop . Example 10: Nonlinear Elasticity This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example. Example 11: Laplace Eigenproblem This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 12: Linear Elasticity Eigenproblem This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example. Example 13: Maxwell Eigenproblem This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example. Example 14: DG Diffusion This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example. Example 15: Dynamic AMR Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example. Example 16: Time Dependent Heat Conduction This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example. Example 17: DG Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example. Example 18: DG Euler Equations This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example. Example 19: Incompressible Nonlinear Elasticity This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example. Example 20: Symplectic Integration of Hamiltonian Systems This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration. Example 21: Adaptive mesh refinement for linear elasticity This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example. Volta Miniapp: Electrostatics This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Tesla Miniapp: Magnetostatics This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Maxwell Miniapp: Transient Full-Wave Electromagnetics This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Joule Miniapp: Transient Magnetics and Joule Heating This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mobius Strip Miniapp This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Klein Bottle Miniapp This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Toroid Miniapp This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Extruder Miniapp This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Shaper Miniapp This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Explorer Miniapp This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Optimizer Miniapp This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Low-Order Refined Transfer Miniapp The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Laghos Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos . No examples or miniapps match your criteria. <!-- function isChecked(id) { return document.getElementById(id).checked; } function setChecked(id, value) { document.getElementById(id).checked = value; } function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) if (divs.item(i).id == id) divs.item(i).style.display = show ? \"block\" : \"none\"; } function updateGroup(names, id) { // make only one box checked in the group if (names.indexOf(id) != -1) for (i = 0; i < names.length; ++i) setChecked(names[i], id == names[i]); // generate boolean variables from the group names for (i = 0; i < names.length; ++i) this[names[i]] = isChecked(names[i]) || isChecked(names[0]); } function elementVisible(id) { var elem = document.getElementById(id); return elem != null && elem.style.display != \"none\"; } function exampleVisible(num) { return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\"); } function update(id) { var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"hydro\", \"meshing\", \"hpc\"]; var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"]; var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ]; var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"symplectic\", \"lobpcg\", \"sundials\", \"petsc\", \"hiop\"]; updateGroup(group1, id); updateGroup(group2, id); updateGroup(group3, id); updateGroup(group4, id); // Example codes var numExamples = 21; // update when adding examples! showElement(\"ex1\", (laplace || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex3\", maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc)); showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc)); showElement(\"ex5\", darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg || petsc)); showElement(\"ex6\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex7\", (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)); showElement(\"ex8\", laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)); showElement(\"ex9\", advection && l2 && dg && (pcg || rk || sundials || petsc || hiop)); showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)); showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu)); showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)); showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)); showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg)); showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)); showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)); showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)); showElement(\"ex18\", hydro && l2 && dg && (rk)); showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)); showElement(\"ex20\", (elasticity || maxwell || conduction || hydro) && symplectic); showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)); // Electromagnetic miniapps numExamples += 4; // update when adding miniapps! showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)); showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)); showElement(\"maxwell\", (maxwell || conduction) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)); showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)); // Meshing miniapps numExamples += 8; // update when adding miniapps! showElement(\"mobius-strip\", meshing && all2 && all3 && all4); showElement(\"klein-bottle\", meshing && all2 && all3 && all4); showElement(\"toroid\", meshing && all2 && all3 && all4); showElement(\"extruder\", meshing && all2 && all3 && all4); showElement(\"shaper\", meshing && all2 && all3 && all4); showElement(\"mesh-explorer\", meshing && all2 && all3 && all4); showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4); showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4); // External miniapps numExamples += 1; // update when adding miniapps! showElement(\"laghos\", (hydro || hpc) && all2 && all3 && all4); var allHidden = true; for (i = 1; i <= numExamples; i++) { // FIXME this no longer works with the miniapps! if (exampleVisible(i)) { allHidden = false; break; } } showElement(\"nomatch\", allHidden); } function initButtons() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { setChecked(id, true); update(id); }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initButtons(); //-->","title":"Examples"},{"location":"examples/#example-codes-and-miniapps","text":"This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Clicking on any of the categories below displays examples and miniapps that contain the described feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments .","title":"Example Codes and Miniapps"},{"location":"examples/#example-1-laplace-problem","text":"This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi .","title":"Example 1: Laplace Problem"},{"location":"examples/#example-2-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example.","title":"Example 2: Linear Elasticity"},{"location":"examples/#example-3-definite-maxwell-problem","text":"This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-2 before viewing this example.","title":"Example 3: Definite Maxwell Problem"},{"location":"examples/#example-4-grad-div-problem","text":"This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-3 before viewing this example.","title":"Example 4: Grad-div Problem"},{"location":"examples/#example-5-darcy-problem","text":"This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in a VisIt visualization format. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . We recommend viewing examples 1-4 before viewing this example.","title":"Example 5: Darcy Problem"},{"location":"examples/#example-6-laplace-problem-with-amr","text":"This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example.","title":"Example 6: Laplace Problem with AMR"},{"location":"examples/#example-7-surface-meshes","text":"This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 7: Surface Meshes"},{"location":"examples/#example-8-dpg-for-the-laplace-problem","text":"This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example.","title":"Example 8: DPG for the Laplace Problem"},{"location":"examples/#example-9-dg-advection","text":"This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop .","title":"Example 9: DG Advection"},{"location":"examples/#example-10-nonlinear-elasticity","text":"This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example.","title":"Example 10: Nonlinear Elasticity"},{"location":"examples/#example-11-laplace-eigenproblem","text":"This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 11: Laplace Eigenproblem"},{"location":"examples/#example-12-linear-elasticity-eigenproblem","text":"This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example.","title":"Example 12: Linear Elasticity Eigenproblem"},{"location":"examples/#example-13-maxwell-eigenproblem","text":"This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example.","title":"Example 13: Maxwell Eigenproblem"},{"location":"examples/#example-14-dg-diffusion","text":"This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example.","title":"Example 14: DG Diffusion"},{"location":"examples/#example-15-dynamic-amr","text":"Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example.","title":"Example 15: Dynamic AMR"},{"location":"examples/#example-16-time-dependent-heat-conduction","text":"This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example.","title":"Example 16: Time Dependent Heat Conduction"},{"location":"examples/#example-17-dg-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example.","title":"Example 17: DG Linear Elasticity"},{"location":"examples/#example-18-dg-euler-equations","text":"This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example.","title":"Example 18: DG Euler Equations"},{"location":"examples/#example-19-incompressible-nonlinear-elasticity","text":"This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example.","title":"Example 19: Incompressible Nonlinear Elasticity"},{"location":"examples/#example-20-symplectic-integration-of-hamiltonian-systems","text":"This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration.","title":"Example 20: Symplectic Integration of Hamiltonian Systems"},{"location":"examples/#example-21-adaptive-mesh-refinement-for-linear-elasticity","text":"This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example.","title":"Example 21: Adaptive mesh refinement for linear elasticity"},{"location":"examples/#volta-miniapp-electrostatics","text":"This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Volta Miniapp: Electrostatics"},{"location":"examples/#tesla-miniapp-magnetostatics","text":"This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Tesla Miniapp: Magnetostatics"},{"location":"examples/#maxwell-miniapp-transient-full-wave-electromagnetics","text":"This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Maxwell Miniapp: Transient Full-Wave Electromagnetics"},{"location":"examples/#joule-miniapp-transient-magnetics-and-joule-heating","text":"This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Joule Miniapp: Transient Magnetics and Joule Heating"},{"location":"examples/#mobius-strip-miniapp","text":"This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mobius Strip Miniapp"},{"location":"examples/#klein-bottle-miniapp","text":"This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Klein Bottle Miniapp"},{"location":"examples/#toroid-miniapp","text":"This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Toroid Miniapp"},{"location":"examples/#extruder-miniapp","text":"This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Extruder Miniapp"},{"location":"examples/#shaper-miniapp","text":"This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Shaper Miniapp"},{"location":"examples/#mesh-explorer-miniapp","text":"This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Explorer Miniapp"},{"location":"examples/#mesh-optimizer-miniapp","text":"This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Optimizer Miniapp"},{"location":"examples/#low-order-refined-transfer-miniapp","text":"The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Low-Order Refined Transfer Miniapp"},{"location":"examples/#laghos-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos . No examples or miniapps match your criteria. <!-- function isChecked(id) { return document.getElementById(id).checked; } function setChecked(id, value) { document.getElementById(id).checked = value; } function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) if (divs.item(i).id == id) divs.item(i).style.display = show ? \"block\" : \"none\"; } function updateGroup(names, id) { // make only one box checked in the group if (names.indexOf(id) != -1) for (i = 0; i < names.length; ++i) setChecked(names[i], id == names[i]); // generate boolean variables from the group names for (i = 0; i < names.length; ++i) this[names[i]] = isChecked(names[i]) || isChecked(names[0]); } function elementVisible(id) { var elem = document.getElementById(id); return elem != null && elem.style.display != \"none\"; } function exampleVisible(num) { return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\"); } function update(id) { var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"hydro\", \"meshing\", \"hpc\"]; var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"]; var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ]; var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"symplectic\", \"lobpcg\", \"sundials\", \"petsc\", \"hiop\"]; updateGroup(group1, id); updateGroup(group2, id); updateGroup(group3, id); updateGroup(group4, id); // Example codes var numExamples = 21; // update when adding examples! showElement(\"ex1\", (laplace || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex3\", maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc)); showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc)); showElement(\"ex5\", darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg || petsc)); showElement(\"ex6\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc)); showElement(\"ex7\", (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)); showElement(\"ex8\", laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)); showElement(\"ex9\", advection && l2 && dg && (pcg || rk || sundials || petsc || hiop)); showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)); showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu)); showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)); showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)); showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg)); showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)); showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)); showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)); showElement(\"ex18\", hydro && l2 && dg && (rk)); showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)); showElement(\"ex20\", (elasticity || maxwell || conduction || hydro) && symplectic); showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)); // Electromagnetic miniapps numExamples += 4; // update when adding miniapps! showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)); showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)); showElement(\"maxwell\", (maxwell || conduction) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)); showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)); // Meshing miniapps numExamples += 8; // update when adding miniapps! showElement(\"mobius-strip\", meshing && all2 && all3 && all4); showElement(\"klein-bottle\", meshing && all2 && all3 && all4); showElement(\"toroid\", meshing && all2 && all3 && all4); showElement(\"extruder\", meshing && all2 && all3 && all4); showElement(\"shaper\", meshing && all2 && all3 && all4); showElement(\"mesh-explorer\", meshing && all2 && all3 && all4); showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4); showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4); // External miniapps numExamples += 1; // update when adding miniapps! showElement(\"laghos\", (hydro || hpc) && all2 && all3 && all4); var allHidden = true; for (i = 1; i <= numExamples; i++) { // FIXME this no longer works with the miniapps! if (exampleVisible(i)) { allHidden = false; break; } } showElement(\"nomatch\", allHidden); } function initButtons() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { setChecked(id, true); update(id); }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initButtons(); //-->","title":"Laghos Miniapp"},{"location":"features/","text":"Features The goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the hypre library. Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Higher-order Finite Element Spaces MFEM supports a wide variety of finite element spaces in 2D and 3D, including arbitrary high-order: H 1 -conforming, H(div) -conforming, H(curl) -conforming spaces, discontinuous L 2 spaces, numerical trace ( interfacial ) spaces, NURBS spaces for isogeometric analysis. Many bilinear and linear forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code. Flexible Discretization In addition to classical Galerkin methods, MFEM enables the quick prototyping of mixed finite elements, Discontinuous Galerkin ( DG ) methods, isogeometric analysis methods, Discontinuous Petrov-Galerkin ( DPG ) approaches, Hybridization and static condensation for high-order problems. Wide Range of Mesh Types MFEM supports arbitrary element transformations and includes classes for dealing with: triangular, quadrilateral, tetrahedral, wedge, and hexahedral elements , uniform refinement (all element types), conforming local mesh refinement (triangular/tetrahedral meshes), non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement, mesh optimization based on the Target-Matrix Optimization Paradigm (TMOP), higher-order elements with curved boundaries, surface meshes embedded in 3D, topologically periodic meshes, 1D meshes. Additional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the PUMI distributed mesh management system. Parallel, Scalable and GPU-ready MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator. MFEM-based applications have been scaled to hundreds of thousands of parallel cores. The library supports efficient operator assembly/evaluation for tensor-product high-order elements. Support for hardware devices, such as GPUs, and programming models, such as CUDA, OCCA , RAJA and OpenMP is also included. A serial MFEM application typically requires minimal changes to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the hypre library. Both of these versions can be further transitioned to high-performing templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several examples and many linear algebra and finite element operations is available. Built-in Solvers MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors and sparse matrices . Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and matrices are also supported. A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems): point-wise and polynomial serial and parallel smoothers, Krylov solvers , such as PCG, MINRES and GMRES applicable to general operators in serial and in parallel, parallel eigensolvers : LOBPCG and AME, high-performance preconditioners from the hypre library including the BoomerAMG , AMS and ADS solvers, many linear and nonlinear solvers, preconditioners and time integrators from the PETSc suite, time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the SUNDIALS suite, discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods, parallel and sequential sparse direct solvers based on SuperLU , STRUMPACK and the SuiteSparse library, explicit and implicit high-order Runge-Kutta time integrators , solvers for nonlinear problems (Newton, HiOp ) and for single linearly constrained quadratic minimization problems. Extensive Examples MFEM includes a number of well-documented example codes that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are: Example 1 : nodal H1 FEM for the Laplace problem, Example 2 : vector FEM for linear elasticity, Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem, Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem, Example 5 : mixed pressure-velocity FEM for the Darcy problem, Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem, Example 7 : Laplace problem on a surface (the unit sphere), Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem, Example 9 : Discontinuous Galerkin (DG) time-dependent advection, Example 10 : time-dependent implicit nonlinear elasticity, Example 11 : parallel Laplace eigensolver, Example 12 : parallel linear elasticity eigensolver, Example 13 : parallel Maxwell eigensolver, Example 14 : Discontinuous Galerkin (DG) for the Laplace problem, Example 15 : dynamic AMR for Laplace with prescribed time-dependent source, Example 16 : time-dependent nonlinear heat equation, Example 17 : Discontinuous Galerkin (DG) for linear elasticity, Example 18 : Discontinuous Galerkin (DG) for the Euler equations, Example 19 : incompressible nonlinear elasticity, Example 20 : symplectic ODE integration, Example 21 : adaptive mesh refinement for linear elasticity. Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two. Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc , SUNDIALS , PUMI and HiOp . Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are: Volta : simple electrostatics simulation code, Tesla : simple magnetostatics simulation code, Maxwell : transient electromagnetics simulation code, Joule : transient magnetics and Joule heating miniapp, Mesh Explorer : visualize and manipulate meshes, Mesh Optimizer : optimize high-order meshes, LOR Transfer : map functions between high-order and low-order-refined spaces. In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available: Laghos : high-order Lagrangian hydrodynamics miniapp, Mulard : multigroup thermal radiation diffusion mini application. Accurate and Flexible Visualization The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool GLVis , which is built on top of MFEM. The VisIt visualization and analysis tool also natively supports MFEM formats. Lightweight, Portable and Easily Extendable The MFEM code base is relatively small and is written in highly portable C++ (e.g. with very limited use of templates and the STL). The serial version of MFEM has no external dependencies and is straightforward to build on Linux, Mac and Windows machines. The MPI-parallel version uses two third-party libraries ( hypre and METIS), and is also easy to build with an MPI compiler. On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively. The object-oriented design of MFEM separates the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of applications . Open Source MFEM is an open-source software, and can be freely used under the terms of the LGPL 2.1 license.","title":"Features"},{"location":"features/#features","text":"The goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the hypre library. Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.","title":"Features"},{"location":"features/#higher-order-finite-element-spaces","text":"MFEM supports a wide variety of finite element spaces in 2D and 3D, including arbitrary high-order: H 1 -conforming, H(div) -conforming, H(curl) -conforming spaces, discontinuous L 2 spaces, numerical trace ( interfacial ) spaces, NURBS spaces for isogeometric analysis. Many bilinear and linear forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.","title":"Higher-order Finite Element Spaces"},{"location":"features/#flexible-discretization","text":"In addition to classical Galerkin methods, MFEM enables the quick prototyping of mixed finite elements, Discontinuous Galerkin ( DG ) methods, isogeometric analysis methods, Discontinuous Petrov-Galerkin ( DPG ) approaches, Hybridization and static condensation for high-order problems.","title":"Flexible Discretization"},{"location":"features/#wide-range-of-mesh-types","text":"MFEM supports arbitrary element transformations and includes classes for dealing with: triangular, quadrilateral, tetrahedral, wedge, and hexahedral elements , uniform refinement (all element types), conforming local mesh refinement (triangular/tetrahedral meshes), non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement, mesh optimization based on the Target-Matrix Optimization Paradigm (TMOP), higher-order elements with curved boundaries, surface meshes embedded in 3D, topologically periodic meshes, 1D meshes. Additional support for automated adaptive analysis and parallel unstructured modifications on simplex meshes is provided via integration with the PUMI distributed mesh management system.","title":"Wide Range of Mesh Types"},{"location":"features/#parallel-scalable-and-gpu-ready","text":"MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator. MFEM-based applications have been scaled to hundreds of thousands of parallel cores. The library supports efficient operator assembly/evaluation for tensor-product high-order elements. Support for hardware devices, such as GPUs, and programming models, such as CUDA, OCCA , RAJA and OpenMP is also included. A serial MFEM application typically requires minimal changes to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the hypre library. Both of these versions can be further transitioned to high-performing templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters. As of version 4.0, GPU acceleration of several examples and many linear algebra and finite element operations is available.","title":"Parallel, Scalable and GPU-ready"},{"location":"features/#built-in-solvers","text":"MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors and sparse matrices . Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and matrices are also supported. A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems): point-wise and polynomial serial and parallel smoothers, Krylov solvers , such as PCG, MINRES and GMRES applicable to general operators in serial and in parallel, parallel eigensolvers : LOBPCG and AME, high-performance preconditioners from the hypre library including the BoomerAMG , AMS and ADS solvers, many linear and nonlinear solvers, preconditioners and time integrators from the PETSc suite, time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the SUNDIALS suite, discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods, parallel and sequential sparse direct solvers based on SuperLU , STRUMPACK and the SuiteSparse library, explicit and implicit high-order Runge-Kutta time integrators , solvers for nonlinear problems (Newton, HiOp ) and for single linearly constrained quadratic minimization problems.","title":"Built-in Solvers"},{"location":"features/#extensive-examples","text":"MFEM includes a number of well-documented example codes that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are: Example 1 : nodal H1 FEM for the Laplace problem, Example 2 : vector FEM for linear elasticity, Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem, Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem, Example 5 : mixed pressure-velocity FEM for the Darcy problem, Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem, Example 7 : Laplace problem on a surface (the unit sphere), Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem, Example 9 : Discontinuous Galerkin (DG) time-dependent advection, Example 10 : time-dependent implicit nonlinear elasticity, Example 11 : parallel Laplace eigensolver, Example 12 : parallel linear elasticity eigensolver, Example 13 : parallel Maxwell eigensolver, Example 14 : Discontinuous Galerkin (DG) for the Laplace problem, Example 15 : dynamic AMR for Laplace with prescribed time-dependent source, Example 16 : time-dependent nonlinear heat equation, Example 17 : Discontinuous Galerkin (DG) for linear elasticity, Example 18 : Discontinuous Galerkin (DG) for the Euler equations, Example 19 : incompressible nonlinear elasticity, Example 20 : symplectic ODE integration, Example 21 : adaptive mesh refinement for linear elasticity. Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two. Many of the examples also have modifications that take advantage of optional third-party libraries such as PETSc , SUNDIALS , PUMI and HiOp . Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are: Volta : simple electrostatics simulation code, Tesla : simple magnetostatics simulation code, Maxwell : transient electromagnetics simulation code, Joule : transient magnetics and Joule heating miniapp, Mesh Explorer : visualize and manipulate meshes, Mesh Optimizer : optimize high-order meshes, LOR Transfer : map functions between high-order and low-order-refined spaces. In addition, the sources for several external benchmark/proxy-apps build on top of MFEM are available: Laghos : high-order Lagrangian hydrodynamics miniapp, Mulard : multigroup thermal radiation diffusion mini application.","title":"Extensive Examples"},{"location":"features/#accurate-and-flexible-visualization","text":"The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool GLVis , which is built on top of MFEM. The VisIt visualization and analysis tool also natively supports MFEM formats.","title":"Accurate and Flexible Visualization"},{"location":"features/#lightweight-portable-and-easily-extendable","text":"The MFEM code base is relatively small and is written in highly portable C++ (e.g. with very limited use of templates and the STL). The serial version of MFEM has no external dependencies and is straightforward to build on Linux, Mac and Windows machines. The MPI-parallel version uses two third-party libraries ( hypre and METIS), and is also easy to build with an MPI compiler. On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively. The object-oriented design of MFEM separates the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of applications .","title":"Lightweight, Portable and Easily Extendable"},{"location":"features/#open-source","text":"MFEM is an open-source software, and can be freely used under the terms of the LGPL 2.1 license.","title":"Open Source"},{"location":"fem/","text":"Finite Element Method The finite element method is a general discretization technique that can utilize unstructured grids to approximate the solutions of many partial differential equations (PDEs). There is a large body of literature on finite elements, including the following excellent books: Numerical Solution of Partial Differential Equations by the Finite Element Method by Claes Johnson Theory and Practice of Finite Elements by Alexandre Ern and Jean-Luc Guermond Higher-Order Finite Element Methods by Pavel \u0160ol\u00edn , Karel Segeth and Ivo Dole\u017eel High-Order Methods for Incompressible Fluid Flow by Michel Deville , Paul Fischer and Ernest Mund Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess The Finite Element Method for Elliptic Problems by Philippe Ciarlet The Mathematical Theory of Finite Element Methods by Susanne Brenner and Ridgway Scott An Analysis of the Finite Element Method by Gilbert Strang and George Fix The Finite Element Method: Its Basis and Fundamentals by Olek Zienkiewicz , Robert Taylor and J.Z. Zhu The MFEM library is designed to be lightweight, general and highly scalable finite element toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Some of the C++ classes for the finite element realizations of these PDE-level concepts in MFEM are described below. Primal and Dual Vectors The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Bilinear Form Integrators Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). The BilinearForm class adds several BilinearFormIntegrator s together to build the global sparse finite element matrix. Linear Form Integrators Linear form integrators are used to compute the integrals of products of a basis function with a given source function over individual mesh elements (or sometimes over edges or faces). The LinearForm class adds several LinearFormIntegrator s together to build the global right-hand side for the finite element linear system. Linear Interpolators Unlike Bilinear and Linear forms, Linear Interpolators do not perform integrations, but project one basis function (or a linear function of a basis function) onto another basis function. The DiscreteLinearOperator class adds one or more LinearInterpolators together to build a global sparse matrix representation of the linear operator.","title":"Finite Elements"},{"location":"fem/#finite-element-method","text":"The finite element method is a general discretization technique that can utilize unstructured grids to approximate the solutions of many partial differential equations (PDEs). There is a large body of literature on finite elements, including the following excellent books: Numerical Solution of Partial Differential Equations by the Finite Element Method by Claes Johnson Theory and Practice of Finite Elements by Alexandre Ern and Jean-Luc Guermond Higher-Order Finite Element Methods by Pavel \u0160ol\u00edn , Karel Segeth and Ivo Dole\u017eel High-Order Methods for Incompressible Fluid Flow by Michel Deville , Paul Fischer and Ernest Mund Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory by Dietrich Braess The Finite Element Method for Elliptic Problems by Philippe Ciarlet The Mathematical Theory of Finite Element Methods by Susanne Brenner and Ridgway Scott An Analysis of the Finite Element Method by Gilbert Strang and George Fix The Finite Element Method: Its Basis and Fundamentals by Olek Zienkiewicz , Robert Taylor and J.Z. Zhu The MFEM library is designed to be lightweight, general and highly scalable finite element toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. Some of the C++ classes for the finite element realizations of these PDE-level concepts in MFEM are described below.","title":"Finite Element Method"},{"location":"fem/#primal-and-dual-vectors","text":"The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play.","title":"Primal and Dual Vectors"},{"location":"fem/#bilinear-form-integrators","text":"Bilinear form integrators are at the heart of any finite element method, they are used to compute the integrals of products of basis functions over individual mesh elements (or sometimes over edges or faces). The BilinearForm class adds several BilinearFormIntegrator s together to build the global sparse finite element matrix.","title":"Bilinear Form Integrators"},{"location":"fem/#linear-form-integrators","text":"Linear form integrators are used to compute the integrals of products of a basis function with a given source function over individual mesh elements (or sometimes over edges or faces). The LinearForm class adds several LinearFormIntegrator s together to build the global right-hand side for the finite element linear system.","title":"Linear Form Integrators"},{"location":"fem/#linear-interpolators","text":"Unlike Bilinear and Linear forms, Linear Interpolators do not perform integrations, but project one basis function (or a linear function of a basis function) onto another basis function. The DiscreteLinearOperator class adds one or more LinearInterpolators together to build a global sparse matrix representation of the linear operator.","title":"Linear Interpolators"},{"location":"gallery/","text":"Gallery This page collects screenshots from various simulations based on MFEM. Additional images can be found in the GLVis gallery . A version of the MFEM logo demonstrating curvilinear elements, adaptive mesh refinement and (idealized) parallel partitioning. Visualization with GLVis . Fibers generated by LDRB approach based on 4 Laplacian solves in the Cardioid project. Solution of a Maxwell problem on a Klein bottle. Mesh generated with the klein-bottle miniapp. Solution with Example 3 . Comparisons of equipotential surfaces and force lines from Maxwell's Treatise on Electricity and Magnetism with results from MFEM's Volta miniapp . Level surfaces in the interior of the solution from Example 1 on escher.mesh . Visualization with GLVis . 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Triple point shock interaction on 4 elements of order 12. Note the element curvature and the high variation of the field inside the lower right element. Streamlines of the magnetic field from a parallel computation of the magnetostatic interaction of two magnetic orbs. Visualization with VTK . Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with Example 13 . Cut image of the solution from Example 1 on a sharply twisted, high order toroidal mesh. The mesh was generated with the toroid miniapp. High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Two-region AMR mesh generated by the Shaper miniapp from successive adaptation to the outlines of Australia. Poisson problem on a \"Breather\" surface. Mesh generated with the Mesh Explorer miniapp. Solution with Example 1 . Radiating Kevin-Helmholtz modeled with the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . The Shaper miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with GLVis . Topology optimization of a drone body using LLNL's LiDO project , based on MFEM. Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with GLVis . Parallel version of Example 1 on 100 processors with a relatively coarse version of square-disc.mesh . Visualization with GLVis . Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in GLVis . Structural topology optimization with MFEM in LLNL's Center for Design and Optimization . Test of the anisotropic refinement feature on a random mesh. A slightly modified version of Example 1 . Visualization with GLVis . Level lines in a cutting plane of the solution from the parallel version of Example 1 on 64 processors with fichera.mesh . Visualization with GLVis .","title":"Gallery"},{"location":"gallery/#gallery","text":"This page collects screenshots from various simulations based on MFEM. Additional images can be found in the GLVis gallery . A version of the MFEM logo demonstrating curvilinear elements, adaptive mesh refinement and (idealized) parallel partitioning. Visualization with GLVis . Fibers generated by LDRB approach based on 4 Laplacian solves in the Cardioid project. Solution of a Maxwell problem on a Klein bottle. Mesh generated with the klein-bottle miniapp. Solution with Example 3 . Comparisons of equipotential surfaces and force lines from Maxwell's Treatise on Electricity and Magnetism with results from MFEM's Volta miniapp . Level surfaces in the interior of the solution from Example 1 on escher.mesh . Visualization with GLVis . 3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Triple point shock interaction on 4 elements of order 12. Note the element curvature and the high variation of the field inside the lower right element. Streamlines of the magnetic field from a parallel computation of the magnetostatic interaction of two magnetic orbs. Visualization with VTK . Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with Example 13 . Cut image of the solution from Example 1 on a sharply twisted, high order toroidal mesh. The mesh was generated with the toroid miniapp. High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Two-region AMR mesh generated by the Shaper miniapp from successive adaptation to the outlines of Australia. Poisson problem on a \"Breather\" surface. Mesh generated with the Mesh Explorer miniapp. Solution with Example 1 . Radiating Kevin-Helmholtz modeled with the MFEM-based BLAST shock hydrodynamics code. Volume visualization with VisIt . The Shaper miniapp applied to a multi-material input functions described by the iterates of the Mandelbrot set. Visualization with GLVis . Topology optimization of a drone body using LLNL's LiDO project , based on MFEM. Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with GLVis . Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based BLAST shock hydrodynamics code. Visualization with VisIt . Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with GLVis . Parallel version of Example 1 on 100 processors with a relatively coarse version of square-disc.mesh . Visualization with GLVis . Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in GLVis . Structural topology optimization with MFEM in LLNL's Center for Design and Optimization . Test of the anisotropic refinement feature on a random mesh. A slightly modified version of Example 1 . Visualization with GLVis . Level lines in a cutting plane of the solution from the parallel version of Example 1 on 64 processors with fichera.mesh . Visualization with GLVis .","title":"Gallery"},{"location":"lininteg/","text":"Linear Form Integrators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Linear form integrators are the right-hand side companion to Bilinear Form Integrators that compute the integrals of products of a basis function and a given \"right-hand side\" function (coefficient) $\\,f$ over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions, therefore linear integrators simultaneously compute the integrals of all combinations of the relevant basis functions with the given input function $\\,f$. This produces a one dimensional array of results that is arranged into a small vector of integral (dual) values called a local element (load) vector . To put this another way, the LinearForm class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet whereas the LinearFormIntegrator class performs the nested inner loops to compute the local vector, loc_vec . for each elem in elements loc_vec = 0.0 for each pt in quadrature_points for each v_i in elem loc_vec(i) += w(pt) * rhs(pt) v_i(pt) end end glb_vec += loc_vec end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$ Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$ Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$ The LinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the LinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None Notation: $$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$ $$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$ For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$. Scalar Field Operators Domain Integrators Class Name Space Operator Continuous Op. Dimension DomainLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D Boundary Integrators Class Name Space Operator Continuous Op. Dimension BoundaryLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D BoundaryNormalLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{n}, v)$ $\\vec{f} \\cdot \\vec{n}$ 1D, 2D, 3D BoundaryTangentialLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{\\tau}, v)$ $\\vec{f} \\cdot \\vec{\\tau}$ 2D BoundaryFlowIntegrator H1, L2 $\\frac{\\alpha}{2}\\, \\left< (\\vec{u} \\cdot \\vec{n})\\, f, v \\right> - \\beta\\, \\left<\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right>$ $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$ 1D, 2D, 3D Face Integrators Class Name Space Operator Continuous Op. Dimension DGDirichletLFIntegrator L2 $\\sigma \\left< u_D, Q \\nabla v \\cdot \\vec{n} \\right> + \\kappa \\left< \\{h^{-1} Q\\} u_D, v \\right>$ DG essential BCs for $u_D$ 1D, 2D, 3D Vector Field Operators Domain Integrators Class Name Space Operator Continuous Op. Dimension VectorDomainLFIntegrator H1, L2 $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 1D, 2D, 3D VectorFEDomainLFIntegrator ND, RT $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 2D, 3D Boundary Integrators Class Name Space Operator Continuous Op. Dimension VectorBoundaryLFIntegrator H1, L2 $( \\vec{f}, \\vec{v} )$ $\\vec{f}$ 1D, 2D, 3D VectorBoundaryFluxLFIntegrator H1, L2 $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 1D, 2D, 3D VectorFEBoundaryFluxLFIntegrator RT $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 2D, 3D VectorFEBoundaryTangentLFIntegrator ND $( \\vec{n} \\times \\vec{f}, \\vec{v} )$ $\\vec{n} \\times \\vec{f}$ 2D, 3D Face Integrators Class Name Space Operator Continuous Op. Dimension DGElasticityDirichletLFIntegrator L2 $\\alpha\\left<\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right> \\\\ + \\kappa\\left< h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right>$ DG essential BCs for $\\vec{u_D}$ 1D, 2D, 3D MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Linear Form Integrators"},{"location":"lininteg/#linear-form-integrators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} $ Linear form integrators are the right-hand side companion to Bilinear Form Integrators that compute the integrals of products of a basis function and a given \"right-hand side\" function (coefficient) $\\,f$ over individual mesh elements (or sometimes over edges or faces). Typically each element is contained in the support of several basis functions, therefore linear integrators simultaneously compute the integrals of all combinations of the relevant basis functions with the given input function $\\,f$. This produces a one dimensional array of results that is arranged into a small vector of integral (dual) values called a local element (load) vector . To put this another way, the LinearForm class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet whereas the LinearFormIntegrator class performs the nested inner loops to compute the local vector, loc_vec . for each elem in elements loc_vec = 0.0 for each pt in quadrature_points for each v_i in elem loc_vec(i) += w(pt) * rhs(pt) v_i(pt) end end glb_vec += loc_vec end There are three types of integrals that typically arise although many other, more exotic, forms are possible: Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$ Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$ Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$ The LinearFormIntegrator classes allow MFEM to produce a wide variety of local element matrices without modifying the LinearForm class. Many of the possible operators are collected below into tables that briefly describe their action and requirements. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None Notation: $$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$ $$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$ For boundary integrators, the integrals are over $\\partial \\Omega$. Face integrators integrate over the interior and boundary faces of mesh elements and are denoted with $\\left<\\cdot,\\cdot\\right>$.","title":"Linear Form Integrators"},{"location":"lininteg/#scalar-field-operators","text":"","title":"Scalar Field Operators"},{"location":"lininteg/#domain-integrators","text":"Class Name Space Operator Continuous Op. Dimension DomainLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D","title":"Domain Integrators"},{"location":"lininteg/#boundary-integrators","text":"Class Name Space Operator Continuous Op. Dimension BoundaryLFIntegrator H1, L2 $(f, v)$ $f$ 1D, 2D, 3D BoundaryNormalLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{n}, v)$ $\\vec{f} \\cdot \\vec{n}$ 1D, 2D, 3D BoundaryTangentialLFIntegrator H1, L2 $(\\vec{f} \\cdot \\vec{\\tau}, v)$ $\\vec{f} \\cdot \\vec{\\tau}$ 2D BoundaryFlowIntegrator H1, L2 $\\frac{\\alpha}{2}\\, \\left< (\\vec{u} \\cdot \\vec{n})\\, f, v \\right> - \\beta\\, \\left<\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right>$ $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$ 1D, 2D, 3D","title":"Boundary Integrators"},{"location":"lininteg/#face-integrators","text":"Class Name Space Operator Continuous Op. Dimension DGDirichletLFIntegrator L2 $\\sigma \\left< u_D, Q \\nabla v \\cdot \\vec{n} \\right> + \\kappa \\left< \\{h^{-1} Q\\} u_D, v \\right>$ DG essential BCs for $u_D$ 1D, 2D, 3D","title":"Face Integrators"},{"location":"lininteg/#vector-field-operators","text":"","title":"Vector Field Operators"},{"location":"lininteg/#domain-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension VectorDomainLFIntegrator H1, L2 $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 1D, 2D, 3D VectorFEDomainLFIntegrator ND, RT $(\\vec{f}, \\vec{v})$ $\\vec{f}$ 2D, 3D","title":"Domain Integrators"},{"location":"lininteg/#boundary-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension VectorBoundaryLFIntegrator H1, L2 $( \\vec{f}, \\vec{v} )$ $\\vec{f}$ 1D, 2D, 3D VectorBoundaryFluxLFIntegrator H1, L2 $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 1D, 2D, 3D VectorFEBoundaryFluxLFIntegrator RT $( f, \\vec{v} \\cdot \\vec{n} )$ $\\vec{f}$ 2D, 3D VectorFEBoundaryTangentLFIntegrator ND $( \\vec{n} \\times \\vec{f}, \\vec{v} )$ $\\vec{n} \\times \\vec{f}$ 2D, 3D","title":"Boundary Integrators"},{"location":"lininteg/#face-integrators_1","text":"Class Name Space Operator Continuous Op. Dimension DGElasticityDirichletLFIntegrator L2 $\\alpha\\left<\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right> \\\\ + \\kappa\\left< h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right>$ DG essential BCs for $\\vec{u_D}$ 1D, 2D, 3D MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Face Integrators"},{"location":"lininterp/","text":"Linear Interpolators $ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Linear interpolators can be very useful for interpolating one discrete representation of a field onto another set of basis functions to produce another representation. However, this must be done with care because different discrete representations are not completely interchangeable. As an example consider a scalar field projected onto either piece-wise linear ($H_1$) or piece-wise constant ($L_2$) basis functions. Interpolating from an $H_1$ representation to an $L_2$ representation should produce a reasonable result because the constant value needed in each element can be computed as a weighted sum of the $H_1$ basis functions in that element. On the other hand, if we try to interpolate from the $L_2$ representation to an $H_1$ representation we don't have enough information to determine reasonable values for the degrees of freedom which are shared between neighboring elements because linear interpolators can only access one element at a time. To accurately compute an $H_1$ representation from an $L_2$ representation requires the type of weighted average of values from neighboring elements that bilinear forms provide but this requires a linear solve and often suitable boundary conditions. The operators produced by the BilinearForm classes involve integrations and therefore they sum the various contributions from neighboring elements to compute a full integral. The DiscreteLinearOperator classes are not performing integrals but rather interpolations and as such they do not combine contributions from different elements in any way. Consequently if the LinearInterpolator s produce different results for entities that are shared between neighboring elements then the resulting representation will depend on the order in which the elements are processed. Such operators are not good candidates for DiscreteLinearOperator s. The sections below will offer some guidance on the appropriate use of these operators. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function Derivative Interpolators The $H(Curl)$ and $H(Div)$ spaces are specifically designed to support these derivative operators by having the necessary inter-element continuity. Other possible derivative operators would not possess the correct continuity and must therefore be implemented in a weak sense. Class Name Domain Range Operator GradientInterpolator H1 ND $\\grad u$ CurlInterpolator ND RT $\\curl\\vec{u}$ DivergenceInterpolator RT L2 $\\div\\vec{u}$ Product Interpolators These operators require a bit more care than the previous set. In order for these operators to produce valid results the product of the coefficient with the domain space must be uniquely representable within the desired range space. Additionally, it may sometimes be desirable for the range space to have a higher order than the domain space if the coefficient is not constant. For example if the domain space and the coefficient are both linear it might be desirable, though not necessary, for the range space to be quadratic. Class Name Domain Range Coef. Operator ScalarProductInterpolator H1,L2 H1,L2 S $\\lambda u$ ScalarVectorProductInterpolator ND,RT ND,RT S $\\lambda\\vec{u}$ VectorScalarProductInterpolator H1,L2 ND,RT V $\\vec{\\lambda}u$ VectorCrossProductInterpolator ND,RT ND,RT V $\\vec{\\lambda}\\times\\vec{u}$ VectorInnerProductInterpolator ND,RT H1,L2 V $\\vec{\\lambda}\\cdot\\vec{u}$ Special Purpose Interpolators Class Name Domain Range Operator IdentityInterpolator H1,L2 H1,L2 $u$ NormalInterpolator H1$^d$ RT_Trace $\\hat{n}\\cdot\\vec{u}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Linear Interpolators"},{"location":"lininterp/#linear-interpolators","text":"$ \\newcommand{\\cross}{\\times} \\newcommand{\\inner}{\\cdot} \\newcommand{\\div}{\\nabla\\cdot} \\newcommand{\\curl}{\\nabla\\times} \\newcommand{\\grad}{\\nabla} \\newcommand{\\ddx}[1]{\\frac{d#1}{dx}} \\newcommand{\\abs}[1]{|#1|} $ Linear interpolators can be very useful for interpolating one discrete representation of a field onto another set of basis functions to produce another representation. However, this must be done with care because different discrete representations are not completely interchangeable. As an example consider a scalar field projected onto either piece-wise linear ($H_1$) or piece-wise constant ($L_2$) basis functions. Interpolating from an $H_1$ representation to an $L_2$ representation should produce a reasonable result because the constant value needed in each element can be computed as a weighted sum of the $H_1$ basis functions in that element. On the other hand, if we try to interpolate from the $L_2$ representation to an $H_1$ representation we don't have enough information to determine reasonable values for the degrees of freedom which are shared between neighboring elements because linear interpolators can only access one element at a time. To accurately compute an $H_1$ representation from an $L_2$ representation requires the type of weighted average of values from neighboring elements that bilinear forms provide but this requires a linear solve and often suitable boundary conditions. The operators produced by the BilinearForm classes involve integrations and therefore they sum the various contributions from neighboring elements to compute a full integral. The DiscreteLinearOperator classes are not performing integrals but rather interpolations and as such they do not combine contributions from different elements in any way. Consequently if the LinearInterpolator s produce different results for entities that are shared between neighboring elements then the resulting representation will depend on the order in which the elements are processed. Such operators are not good candidates for DiscreteLinearOperator s. The sections below will offer some guidance on the appropriate use of these operators. In the tables below the Space column refers to finite element spaces which implement the following methods: Space Operator Derivative Operator H1 CalcShape CalcDShape ND CalcVShape CalcCurlShape RT CalcVShape CalcDivShape L2 CalcShape None The Coef. column refers to the types of coefficients that are available. A boldface coefficient type is required whereas most coefficients are optional. Coef. Type S Scalar Valued Function V Vector Valued Function D Diagonal Matrix Function M General Matrix Function","title":"Linear Interpolators"},{"location":"lininterp/#derivative-interpolators","text":"The $H(Curl)$ and $H(Div)$ spaces are specifically designed to support these derivative operators by having the necessary inter-element continuity. Other possible derivative operators would not possess the correct continuity and must therefore be implemented in a weak sense. Class Name Domain Range Operator GradientInterpolator H1 ND $\\grad u$ CurlInterpolator ND RT $\\curl\\vec{u}$ DivergenceInterpolator RT L2 $\\div\\vec{u}$","title":"Derivative Interpolators"},{"location":"lininterp/#product-interpolators","text":"These operators require a bit more care than the previous set. In order for these operators to produce valid results the product of the coefficient with the domain space must be uniquely representable within the desired range space. Additionally, it may sometimes be desirable for the range space to have a higher order than the domain space if the coefficient is not constant. For example if the domain space and the coefficient are both linear it might be desirable, though not necessary, for the range space to be quadratic. Class Name Domain Range Coef. Operator ScalarProductInterpolator H1,L2 H1,L2 S $\\lambda u$ ScalarVectorProductInterpolator ND,RT ND,RT S $\\lambda\\vec{u}$ VectorScalarProductInterpolator H1,L2 ND,RT V $\\vec{\\lambda}u$ VectorCrossProductInterpolator ND,RT ND,RT V $\\vec{\\lambda}\\times\\vec{u}$ VectorInnerProductInterpolator ND,RT H1,L2 V $\\vec{\\lambda}\\cdot\\vec{u}$","title":"Product Interpolators"},{"location":"lininterp/#special-purpose-interpolators","text":"Class Name Domain Range Operator IdentityInterpolator H1,L2 H1,L2 $u$ NormalInterpolator H1$^d$ RT_Trace $\\hat{n}\\cdot\\vec{u}$ MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Special Purpose Interpolators"},{"location":"mesh-format-v1.x/","text":"General MFEM Mesh Format The MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the nodes of the mesh. For simplicity, in this document we refer to this version of the format as MFEM mesh v1.x . The legacy version for meshes with straight edges we will call MFEM linear mesh format. A mesh in the MFEM mesh v1.x format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the beam-quad.mesh from MFEM's data/ directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments: The original linear mesh version of this file is given in Listing 1 . Topology The topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the vertices are just labels used to imply which elements share a vertex, an edge or a face. Some examples: General version of data/beam-quad.mesh Below is the annotated topological part of the MFEM mesh v1.x format for the beam mesh. The complete file is given in Listing 2 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary # Skipping the 18 boundary segments for simplicity vertices 18 # END Topology Part ... The element format above is: <attribute> <type> <vertex1> ... <vertexN> . Type 3 is quadrilateral, which requires 4 vertex indices. The attribute identify e.g. material sub-domains (2 in this case). NOTE: The topology part of this mesh will be the same, irrespective of the order. Compare e.g. Listing 2 , Listing 3 and Listing 4 . WARNING: The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh nodes not vertices . In particular, while the Mesh object can return vertex coordinates, they are not used an may be incorrect for high-order mesh. Periodic version of data/beam-quad.mesh The topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a cylinder. The complete file is given in Listing 5 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 # Last element uses vertices 0 and 9 # two vertical boundary have been removed boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 16 # END Topology Part ... Compared to the non-periodic version, e.g. Listing 2 , the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9. The difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh. In the periodic case we get: while the solution on the non-periodic mesh looks like: NOTE: Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh. Geometry The geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh nodes as a general finite element (vector) function. In MFEM, finite element functions are objects of type GridFunction which belong to discrete finite element spaces specified by objects FiniteElementSpace and FiniteElementCollection . The actual geometry of each element is obtained by extracting the local degrees of freedom from the global nodes , expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element. An example of a first order geometry is given in Listing 2 : ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # END Geometry Part Here VDim: 2 means that the nodes grid function is a vector field with two components (i.e. the mesh is embedded in R^2); H1_2D_P1 describes the finite element space (H1/continuous finite elements in 2D of order 1); Ordering refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates. Compare the above with the linear mesh vertex coordinates from Listing 1 : vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 In the MFEM mesh v1.x format, the nodes are a regular grid function, just like an other discretized field in a simulation, which has several advantages: The nodes can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation. Mesh optimization problems can be posed directly for the nodes variable. Since the nodes can be any finite element function, a wide variety of meshes are easily supported. As an illustration of the last point, consider the geometry of the periodic version of the mesh in Listing 5 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1 # END Geometry Part ... Note that the space here is L2 , which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions. Finite Element Spaces To fully specify the MFEM mesh v1.x format, we need to describe the degrees of freedom of the nodes finite element space and their global numbering. This is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach... Finite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements. There may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom. For example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points. These are just examples, many choices for the basis are actually possible to be encoded in the FiniteElementCollection string above. In general, based just on the mesh topology and the type of the space, the FiniteElementSpace object can determine a global set of dofs, that will be the values listed for the mesh nodes . The algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows: loop over elements loop over edges and faces inside each element (clock-wise) number currently the edges and faces that have not been numbered yet Here is the result of this numbering for the beam mesh In addition to a number, each edges and face is also given a global orientation. In 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id. In 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the fem/geom.cpp for the definitions of the tetrahedral and hexahedral mappings on the reference element, as well as the Mesh::GenerateFaces method in mesh/mesh.cpp . In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e. orientation here means permutation of vertices. The global numbering of degrees of freedom is now performed as follows: loop over vertices list the dofs associated with each vertex loop over edges list the dofs associated with the interior of the edge, lexicographically with respect to the edge orientation loop over faces list the dofs associated with the interior of the face, lexicographically with respect to the face orientation loop over elements list the dofs associated with the interior of the element An example of this is the quadratic mesh in Listing 3 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 # 18 vertex dofs 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # 25 edge dofs 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 # 8 element dofs 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 # END Geometry Part ... Listings Listing 1 This is the original version of the beam-quad.mesh using the linear mesh format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 Listing 2 This is a MFEM mesh v1.x version of the beam-quad.mesh which is first order. The mesh is identical to the one of Listing 1 , it is just described in a different format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 Listing 3 This is a second order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 Listing 4 This is a third order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P3 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.27639320225002 0 0.72360679774998 0 1 0.27639320225002 1 0.72360679774998 0.27639320225002 1 0.72360679774998 1 0 0.27639320225002 0 0.72360679774998 1.27639320225 0 1.72360679775 0 2 0.27639320225002 2 0.72360679774998 1.27639320225 1 1.72360679775 1 2.27639320225 0 2.72360679775 0 3 0.27639320225002 3 0.72360679774998 2.27639320225 1 2.72360679775 1 3.27639320225 0 3.72360679775 0 4 0.27639320225002 4 0.72360679774998 3.27639320225 1 3.72360679775 1 4.27639320225 0 4.72360679775 0 5 0.27639320225002 5 0.72360679774998 4.27639320225 1 4.72360679775 1 5.27639320225 0 5.72360679775 0 6 0.27639320225002 6 0.72360679774998 5.27639320225 1 5.72360679775 1 6.27639320225 0 6.72360679775 0 7 0.27639320225002 7 0.72360679774998 6.27639320225 1 6.72360679775 1 7.27639320225 0 7.72360679775 0 8 0.27639320225002 8 0.72360679774998 7.27639320225 1 7.72360679775 1 0.27639320225002 0.27639320225002 0.72360679774998 0.27639320225002 0.27639320225002 0.72360679774998 0.72360679774998 0.72360679774998 1.27639320225 0.27639320225002 1.72360679775 0.27639320225002 1.27639320225 0.72360679774998 1.72360679775 0.72360679774998 2.27639320225 0.27639320225002 2.72360679775 0.27639320225002 2.27639320225 0.72360679774998 2.72360679775 0.72360679774998 3.27639320225 0.27639320225002 3.72360679775 0.27639320225002 3.27639320225 0.72360679774998 3.72360679775 0.72360679774998 4.27639320225 0.27639320225002 4.72360679775 0.27639320225002 4.27639320225 0.72360679774998 4.72360679775 0.72360679774998 5.27639320225 0.27639320225002 5.72360679775 0.27639320225002 5.27639320225 0.72360679774998 5.72360679775 0.72360679774998 6.27639320225 0.27639320225002 6.72360679775 0.27639320225002 6.27639320225 0.72360679774998 6.72360679775 0.72360679774998 7.27639320225 0.27639320225002 7.72360679775 0.27639320225002 7.27639320225 0.72360679774998 7.72360679775 0.72360679774998 Listing 5 Periodic version of the first-order mesh from Listing 1 . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 16 nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1","title":"_Mesh Format v1.x"},{"location":"mesh-format-v1.x/#general-mfem-mesh-format","text":"The MFEM mesh v1.x format supports the general description of meshes based on a vector finite element grid function with degrees of freedom in the nodes of the mesh. For simplicity, in this document we refer to this version of the format as MFEM mesh v1.x . The legacy version for meshes with straight edges we will call MFEM linear mesh format. A mesh in the MFEM mesh v1.x format consists of two parts: Topology and Geometry. We illustrate these concepts by comparing with the beam-quad.mesh from MFEM's data/ directory. This is just a simple quadrilateral beam mesh with 8 elements, 18 vertices (numbered 0 to 17) and 18 boundary segments: The original linear mesh version of this file is given in Listing 1 .","title":"General MFEM Mesh Format"},{"location":"mesh-format-v1.x/#topology","text":"The topological part of the mesh describes the relations between the elements in the mesh, in terms of neighborhood implied by shared vertices. Actual coordinates do not play a role in this part, so the vertices are just labels used to imply which elements share a vertex, an edge or a face. Some examples:","title":"Topology"},{"location":"mesh-format-v1.x/#general-version-of-databeam-quadmesh","text":"Below is the annotated topological part of the MFEM mesh v1.x format for the beam mesh. The complete file is given in Listing 2 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary # Skipping the 18 boundary segments for simplicity vertices 18 # END Topology Part ... The element format above is: <attribute> <type> <vertex1> ... <vertexN> . Type 3 is quadrilateral, which requires 4 vertex indices. The attribute identify e.g. material sub-domains (2 in this case). NOTE: The topology part of this mesh will be the same, irrespective of the order. Compare e.g. Listing 2 , Listing 3 and Listing 4 . WARNING: The vertices are used only to imply topology, and so there coordinates are not important. The mesh coordinates are implied by the mesh nodes not vertices . In particular, while the Mesh object can return vertex coordinates, they are not used an may be incorrect for high-order mesh.","title":"General version of data/beam-quad.mesh"},{"location":"mesh-format-v1.x/#periodic-version-of-databeam-quadmesh","text":"The topology part can be used to describe more complicated mesh relations. For example we can identify the two vertical lines of the beam mesh, turning it topologically into a cylinder. The complete file is given in Listing 5 . ... # BEGIN Topology Part dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 # Last element uses vertices 0 and 9 # two vertical boundary have been removed boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 16 # END Topology Part ... Compared to the non-periodic version, e.g. Listing 2 , the main difference above is that we have fused vertices 8 and 0 and vertices 17 and 9. The difference between the two topologies can be illustrated by solving a simple Laplace problem with homogeneous essential boundary conditions on the resulting mesh. In the periodic case we get: while the solution on the non-periodic mesh looks like: NOTE: Meshes with periodic topology allow us to solve problems with periodic boundary conditions without modifying the application to impose them -- we simply run on a different mesh.","title":"Periodic version of data/beam-quad.mesh"},{"location":"mesh-format-v1.x/#geometry","text":"The geometry of the mesh, i.e. the actual position of mesh elements in physical space is described by specifying the mesh nodes as a general finite element (vector) function. In MFEM, finite element functions are objects of type GridFunction which belong to discrete finite element spaces specified by objects FiniteElementSpace and FiniteElementCollection . The actual geometry of each element is obtained by extracting the local degrees of freedom from the global nodes , expanding them in the corresponding (reference element) finite element basis, and using the resulting polynomial vector field to map the reference element. An example of a first order geometry is given in Listing 2 : ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # END Geometry Part Here VDim: 2 means that the nodes grid function is a vector field with two components (i.e. the mesh is embedded in R^2); H1_2D_P1 describes the finite element space (H1/continuous finite elements in 2D of order 1); Ordering refers to how the vector field values are serialized (in this case x,y,x,y,...); and the rest is just the global degrees of freedom representing in this case the vertex coordinates. Compare the above with the linear mesh vertex coordinates from Listing 1 : vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 In the MFEM mesh v1.x format, the nodes are a regular grid function, just like an other discretized field in a simulation, which has several advantages: The nodes can be part of the discretization, and be evolved directly e.g. in a Lagrangian/ALE simulation. Mesh optimization problems can be posed directly for the nodes variable. Since the nodes can be any finite element function, a wide variety of meshes are easily supported. As an illustration of the last point, consider the geometry of the periodic version of the mesh in Listing 5 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1 # END Geometry Part ... Note that the space here is L2 , which means a discontinuous linear vector field, where four vertex coordinates are specified on each element. This allows us to plot the periodic mesh as a regular beam, which is what you'd expect for periodic boundary conditions.","title":"Geometry"},{"location":"mesh-format-v1.x/#finite-element-spaces","text":"To fully specify the MFEM mesh v1.x format, we need to describe the degrees of freedom of the nodes finite element space and their global numbering. This is something that the MFEM team is very interested to discuss and standardize with other high-order projects and applications. Below is a description of our current approach... Finite element spaces have degrees of freedom (dofs) that are associated with the (interiors of the) mesh vertices, edges, faces and elements. There may be multiple dofs associated with the same geometric entity (e.g. vector fields), and different spaces have different sets of degrees of freedom. For example H1/continuous spaces can have degrees of freedom associated with the Gauss-Lobatto points in a quadrilateral, while L2/discontinuous spaces can have degrees of freedom associated with the Gauss-Legendre points. These are just examples, many choices for the basis are actually possible to be encoded in the FiniteElementCollection string above. In general, based just on the mesh topology and the type of the space, the FiniteElementSpace object can determine a global set of dofs, that will be the values listed for the mesh nodes . The algorithm starts with the given numbering of the elements and the vertices, from which a numbering of the edges and the faces is derived as follows: loop over elements loop over edges and faces inside each element (clock-wise) number currently the edges and faces that have not been numbered yet Here is the result of this numbering for the beam mesh In addition to a number, each edges and face is also given a global orientation. In 2D and 3D, an edge is oriented from the vertex with the lower vertex id to the vertex with the higher vertex id. In 3D, a face is oriented according to the face-to-vertex mappings in the first element in which the face is enumerated. See the fem/geom.cpp for the definitions of the tetrahedral and hexahedral mappings on the reference element, as well as the Mesh::GenerateFaces method in mesh/mesh.cpp . In particular, the normal of the face between two elements points from the element with lower number to the element with higher number. Face orientation however includes not just the normal direction, but also any rotation of the vertices compared to the base, i.e. orientation here means permutation of vertices. The global numbering of degrees of freedom is now performed as follows: loop over vertices list the dofs associated with each vertex loop over edges list the dofs associated with the interior of the edge, lexicographically with respect to the edge orientation loop over faces list the dofs associated with the interior of the face, lexicographically with respect to the face orientation loop over elements list the dofs associated with the interior of the element An example of this is the quadratic mesh in Listing 3 ... # BEGIN Geometry Part nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 # 18 vertex dofs 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 # 25 edge dofs 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 # 8 element dofs 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5 # END Geometry Part ...","title":"Finite Element Spaces"},{"location":"mesh-format-v1.x/#listings","text":"","title":"Listings"},{"location":"mesh-format-v1.x/#listing-1","text":"This is the original version of the beam-quad.mesh using the linear mesh format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1","title":"Listing 1"},{"location":"mesh-format-v1.x/#listing-2","text":"This is a MFEM mesh v1.x version of the beam-quad.mesh which is first order. The mesh is identical to the one of Listing 1 , it is just described in a different format. MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1","title":"Listing 2"},{"location":"mesh-format-v1.x/#listing-3","text":"This is a second order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P2 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.5 0 1 0.5 0.5 1 0 0.5 1.5 0 2 0.5 1.5 1 2.5 0 3 0.5 2.5 1 3.5 0 4 0.5 3.5 1 4.5 0 5 0.5 4.5 1 5.5 0 6 0.5 5.5 1 6.5 0 7 0.5 6.5 1 7.5 0 8 0.5 7.5 1 0.5 0.5 1.5 0.5 2.5 0.5 3.5 0.5 4.5 0.5 5.5 0.5 6.5 0.5 7.5 0.5","title":"Listing 3"},{"location":"mesh-format-v1.x/#listing-4","text":"This is a third order version of the beam-quad.mesh . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 8 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 17 16 1 1 9 0 2 1 8 17 vertices 18 nodes FiniteElementSpace FiniteElementCollection: H1_2D_P3 VDim: 2 Ordering: 1 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 0.27639320225002 0 0.72360679774998 0 1 0.27639320225002 1 0.72360679774998 0.27639320225002 1 0.72360679774998 1 0 0.27639320225002 0 0.72360679774998 1.27639320225 0 1.72360679775 0 2 0.27639320225002 2 0.72360679774998 1.27639320225 1 1.72360679775 1 2.27639320225 0 2.72360679775 0 3 0.27639320225002 3 0.72360679774998 2.27639320225 1 2.72360679775 1 3.27639320225 0 3.72360679775 0 4 0.27639320225002 4 0.72360679774998 3.27639320225 1 3.72360679775 1 4.27639320225 0 4.72360679775 0 5 0.27639320225002 5 0.72360679774998 4.27639320225 1 4.72360679775 1 5.27639320225 0 5.72360679775 0 6 0.27639320225002 6 0.72360679774998 5.27639320225 1 5.72360679775 1 6.27639320225 0 6.72360679775 0 7 0.27639320225002 7 0.72360679774998 6.27639320225 1 6.72360679775 1 7.27639320225 0 7.72360679775 0 8 0.27639320225002 8 0.72360679774998 7.27639320225 1 7.72360679775 1 0.27639320225002 0.27639320225002 0.72360679774998 0.27639320225002 0.27639320225002 0.72360679774998 0.72360679774998 0.72360679774998 1.27639320225 0.27639320225002 1.72360679775 0.27639320225002 1.27639320225 0.72360679774998 1.72360679775 0.72360679774998 2.27639320225 0.27639320225002 2.72360679775 0.27639320225002 2.27639320225 0.72360679774998 2.72360679775 0.72360679774998 3.27639320225 0.27639320225002 3.72360679775 0.27639320225002 3.27639320225 0.72360679774998 3.72360679775 0.72360679774998 4.27639320225 0.27639320225002 4.72360679775 0.27639320225002 4.27639320225 0.72360679774998 4.72360679775 0.72360679774998 5.27639320225 0.27639320225002 5.72360679775 0.27639320225002 5.27639320225 0.72360679774998 5.72360679775 0.72360679774998 6.27639320225 0.27639320225002 6.72360679775 0.27639320225002 6.27639320225 0.72360679774998 6.72360679775 0.72360679774998 7.27639320225 0.27639320225002 7.72360679775 0.27639320225002 7.27639320225 0.72360679774998 7.72360679775 0.72360679774998","title":"Listing 4"},{"location":"mesh-format-v1.x/#listing-5","text":"Periodic version of the first-order mesh from Listing 1 . MFEM mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # POINT = 0 # SEGMENT = 1 # TRIANGLE = 2 # SQUARE = 3 # TETRAHEDRON = 4 # CUBE = 5 # dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 0 9 16 boundary 16 3 1 0 1 3 1 1 2 3 1 2 3 3 1 3 4 3 1 4 5 3 1 5 6 3 1 6 7 3 1 7 0 3 1 10 9 3 1 11 10 3 1 12 11 3 1 13 12 3 1 14 13 3 1 15 14 3 1 16 15 3 1 9 16 vertices 16 nodes FiniteElementSpace FiniteElementCollection: L2_T1_2D_P1 VDim: 2 Ordering: 1 0 0 1 0 0 1 1 1 1 0 2 0 1 1 2 1 2 0 3 0 2 1 3 1 3 0 4 0 3 1 4 1 4 0 5 0 4 1 5 1 5 0 6 0 5 1 6 1 6 0 7 0 6 1 7 1 7 0 8 0 7 1 8 1 8 0 9 0 8 1 9 1 9 0 10 0 9 1 10 1","title":"Listing 5"},{"location":"mesh-formats/","text":"Mesh Formats MFEM mesh v1.0 This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes. Straight meshes In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 PRISM = 6 see the comments in this source file for more details. For example, the beam-quad.mesh file from the data directory looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\" Curvilinear and more general meshes The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the General Mesh Format page . MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaoooooooooo**************tt\" we get: Topologically periodic meshes can also be described in this format, see for example the periodic-segment , periodic-square , and periodic-cube meshes in the data directory, as well as Example 9 . MFEM mesh v1.1 This format adds support for non-conforming (AMR) meshes. The sections dimension , elements , and boundary are the same as in MFEM mesh v1.0 and are followed by two new (optional) sections, vertex_parents and coarse_elements : # Vertex hierarchy vertex_parents <number of relations> <vertex index> <parent 1 index> <parent 2 index> ... # Element hierarchy coarse_elements <number of coarse elements> <refinement type> <child index 1> ... <child index n> ... These are followed by the standard sections vertices and nodes of the format MFEM mesh v1.0. The new section vertex_parents identifies all vertices (by their zero-based index) that have been created as new mid-edge vertices by adaptive refinement of elements. Each such vertex has exactly two \"parents\" identified again by two zero-based indices. This information is needed to construct constraining relations in a mesh with hanging nodes. The order the vertex-parent relations are stated in the file is not significant. The second optional section coarse_elements describes the element refinement hierarchy. While the standard section elements lists all leaf elements of the refinement tree, this section describes all elements that have been refined and are no longer active. Each line describes one such virtual element, its refinement type and up to 8 children. Child indices between 0 and N-1 refer to the N active elements in the elements section. A coarse element has an implied index starting with N . A coarse element can refer to another coarse element of index >= N , but only after such child has been defined in the coarse_elements section. The hierarchy is thus represented from the bottom up. The refinement types are: 1=X, 2=Y, 4=Z, 3=XY, 5=XZ, 6=YZ, 7=XYZ, where X, Y, Z refer to one or more splits in the respective axes of the element reference domain. If the entire section is missing, MFEM will not be able to derefine the mesh. The files amr-quad.mesh , amr-hex.mesh and fichera-amr.mesh (above) in the data directory are examples of AMR meshes. NURBS meshes MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after several refinements with the \" i \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Some examples of VTK meshes can be found in MFEM's data directory . Here is one of the 3D NURBS meshes The image above was produced with some refinement (key \" o \") and mouse manipulations from glvis -m pipe-nurbs.mesh Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf Curvilinear VTK meshes MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get: The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g., glvis -m quad.vtk -k \"AemIIiii\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" MFEM and GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaooooo******\"","title":"_Mesh Formats"},{"location":"mesh-formats/#mesh-formats","text":"","title":"Mesh Formats"},{"location":"mesh-formats/#mfem-mesh-v10","text":"This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.","title":"MFEM mesh v1.0"},{"location":"mesh-formats/#straight-meshes","text":"In the simple case of a mesh with straight edges the format looks as follows MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Vertex coordinates vertices <number of vertices> <vdim> <coordinate 1> ... <coordinate <vdim>> ... Lines starting with \"#\" denote comments. The supported geometry types are: POINT = 0 SEGMENT = 1 TRIANGLE = 2 SQUARE = 3 TETRAHEDRON = 4 CUBE = 5 PRISM = 6 see the comments in this source file for more details. For example, the beam-quad.mesh file from the data directory looks like this: MFEM mesh v1.0 dimension 2 elements 8 1 3 0 1 10 9 1 3 1 2 11 10 1 3 2 3 12 11 1 3 3 4 13 12 2 3 4 5 14 13 2 3 5 6 15 14 2 3 6 7 16 15 2 3 7 8 17 16 boundary 18 3 1 1 0 3 1 2 1 3 1 3 2 3 1 4 3 3 1 5 4 3 1 6 5 3 1 7 6 3 1 8 7 3 1 9 10 3 1 10 11 3 1 11 12 3 1 12 13 3 1 13 14 3 1 14 15 3 1 15 16 3 1 16 17 1 1 0 9 2 1 17 8 vertices 18 2 0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 0 1 1 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 which corresponds to the mesh visualized with glvis -m beam-quad.mesh -k \"Ame****\"","title":"Straight meshes"},{"location":"mesh-formats/#curvilinear-and-more-general-meshes","text":"The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh. This general format is described briefly below, and in more details on the General Mesh Format page . MFEM mesh v1.0 # Space dimension: 2 or 3 dimension <dimension> # Mesh elements, e.g. tetrahedrons (4) elements <number of elements> <element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Mesh faces/edges on the boundary, e.g. triangles (2) boundary <number of boundary elements> <boundary element attribute> <geometry type> <vertex index 1> ... <vertex index m> ... # Number of vertices (no coordinates) vertices <number of vertices> # Mesh nodes as degrees of freedom of a finite element grid function nodes FiniteElementSpace FiniteElementCollection: <finite element collection> VDim: <dimension> Ordering: 0 <x-coordinate degrees of freedom> ... <y-coordinate degrees of freedom> ... <z-coordinate degrees of freedom> ... Some possible finite element collection choices are: Linear , Quadratic and Cubic corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in MFEM's source code . For example, the escher-p3.mesh from MFEM's data directory describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with glvis -m escher-p3.mesh -k \"Aaaoooooooooo**************tt\" we get: Topologically periodic meshes can also be described in this format, see for example the periodic-segment , periodic-square , and periodic-cube meshes in the data directory, as well as Example 9 .","title":"Curvilinear and more general meshes"},{"location":"mesh-formats/#mfem-mesh-v11","text":"This format adds support for non-conforming (AMR) meshes. The sections dimension , elements , and boundary are the same as in MFEM mesh v1.0 and are followed by two new (optional) sections, vertex_parents and coarse_elements : # Vertex hierarchy vertex_parents <number of relations> <vertex index> <parent 1 index> <parent 2 index> ... # Element hierarchy coarse_elements <number of coarse elements> <refinement type> <child index 1> ... <child index n> ... These are followed by the standard sections vertices and nodes of the format MFEM mesh v1.0. The new section vertex_parents identifies all vertices (by their zero-based index) that have been created as new mid-edge vertices by adaptive refinement of elements. Each such vertex has exactly two \"parents\" identified again by two zero-based indices. This information is needed to construct constraining relations in a mesh with hanging nodes. The order the vertex-parent relations are stated in the file is not significant. The second optional section coarse_elements describes the element refinement hierarchy. While the standard section elements lists all leaf elements of the refinement tree, this section describes all elements that have been refined and are no longer active. Each line describes one such virtual element, its refinement type and up to 8 children. Child indices between 0 and N-1 refer to the N active elements in the elements section. A coarse element has an implied index starting with N . A coarse element can refer to another coarse element of index >= N , but only after such child has been defined in the coarse_elements section. The hierarchy is thus represented from the bottom up. The refinement types are: 1=X, 2=Y, 4=Z, 3=XY, 5=XZ, 6=YZ, 7=XYZ, where X, Y, Z refer to one or more splits in the respective axes of the element reference domain. If the entire section is missing, MFEM will not be able to derefine the mesh. The files amr-quad.mesh , amr-hex.mesh and fichera-amr.mesh (above) in the data directory are examples of AMR meshes.","title":"MFEM mesh v1.1"},{"location":"mesh-formats/#nurbs-meshes","text":"MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general curvilinear meshes where the NURBS nodes are specified as a grid function at the end of the mesh file. For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.) MFEM NURBS mesh v1.0 # # MFEM Geometry Types (see mesh/geom.hpp): # # SEGMENT = 1 # SQUARE = 3 # CUBE = 5 # dimension 2 elements 4 1 3 0 1 5 4 1 3 1 2 6 5 1 3 2 3 7 6 1 3 3 0 4 7 boundary 8 1 1 0 1 1 1 1 2 1 1 2 3 1 1 3 0 1 1 5 4 1 1 6 5 1 1 7 6 1 1 4 7 edges 12 0 0 1 0 4 5 1 1 2 1 5 6 2 2 3 2 6 7 3 3 0 3 7 4 4 0 4 4 1 5 4 2 6 4 3 7 vertices 8 knotvectors 5 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 2 3 0 0 0 1 1 1 weights 1 1 1 1 1 1 1 1 1 0.707106781 1 0.707106781 1 0.707106781 1 0.707106781 1 1 1 1 0.853553391 0.853553391 0.853553391 0.853553391 FiniteElementSpace FiniteElementCollection: NURBS2 VDim: 2 Ordering: 1 0 0 1 0 1 1 0 1 0.358578644 0.358578644 0.641421356 0.358578644 0.641421356 0.641421356 0.358578644 0.641421356 0.5 0 0.5 0.217157288 1 0.5 0.782842712 0.5 0.5 1 0.5 0.782842712 0 0.5 0.217157288 0.5 0.15 0.15 0.85 0.15 0.85 0.85 0.15 0.85 0.5 0.108578644 0.891421356 0.5 0.5 0.891421356 0.108578644 0.5 This above file, as well as other examples of NURBS meshes, can be found in MFEM's data directory . It can be visualized directly with glvis -m square-disc-nurbs.mesh which after several refinements with the \" i \" key looks like To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the elements and boundary sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices. In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the edges section where the first index in each row refers to the knot vector id (from the following knotvectors section), while the remaining two indexes are the edge vertex numbers. The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding weights section. Some examples of VTK meshes can be found in MFEM's data directory . Here is one of the 3D NURBS meshes The image above was produced with some refinement (key \" o \") and mouse manipulations from glvis -m pipe-nurbs.mesh Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh. glvis -m square-disc-nurbs.mesh -g sol.gf","title":"NURBS meshes"},{"location":"mesh-formats/#curvilinear-vtk-meshes","text":"MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the vtkBiQuadraticQuad and vtkTriQuadraticHexahedron classes. Currently VTK does not support cubic, and higher-order meshes. As an example, consider a simple curved quadrilateral saved in a file quad.vtk : # vtk DataFile Version 3.0 Generated by MFEM ASCII DATASET UNSTRUCTURED_GRID POINTS 9 double 0 0 0 1 0 0 1 1 0 0.1 0.9 0 0.5 -0.05 0 0.9 0.5 0 0.5 1 0 0 0.5 0 0.45 0.55 0 CELLS 1 10 9 0 1 2 3 4 5 6 7 8 CELL_TYPES 1 28 CELL_DATA 1 SCALARS material int LOOKUP_TABLE default 1 Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get: The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g., glvis -m quad.vtk -k \"AemIIiii\" Here is a slightly more complicated quadratic quadrilateral mesh example (the different colors in the GLVis window are used to distinguish neighboring elements): glvis -m star-q2.vtk -k \"Am\" MFEM and GLVis can also handle quadratic triangular meshes: glvis -m square-disc-p2.vtk -k \"Am\" As well as quadratic tetrahedral and quadratic hexahedral VTK meshes: glvis -m escher-p2.vtk -k \"Aaaooooo**************\" glvis -m fichera-q2.vtk -k \"Aaaooooo******\"","title":"Curvilinear VTK meshes"},{"location":"meshing/","text":"Meshing This page provides a brief description of MFEM's mesh formats, meshing mini applications, and related tools. Mesh formats MFEM supports a number of mesh formats, including: MFEM's mesh v1.0 format for straight meshes, MFEM's mesh v1.0 format for arbitrary high-order curvilinear and more general meshes, MFEM's mesh v1.1 format , which adds support for non-conforming (AMR) meshes, MFEM's mesh v1.2 format, which adds support for parallel meshes, MFEM's format for NURBS meshes, The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes, The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats, The TrueGrid hexahedral mesh format. Detailed description of these formats can be found on the mesh formats page. These formats are also supported by MFEM's native visualization tool, GLVis . Meshing miniapps The miniapps/meshing directory contains a collection of meshing-related miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current meshing miniapps are described below. Related tools are listed at the bottom of the page. Mobius Strip This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. Klein Bottle This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. Toroid This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. A wide variety of toroidal meshes can be generated by varying the amount of twist as well as the major and minor radii and other variables. The toroid-wedge and toroid-hex meshes in the data directory were generated with this miniapp. Extruder This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and then in the z-direction. 2D meshes can be triangular, quadrilateral, or contain both element types. Shaper This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material() function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. Mesh Explorer This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality Mesh Optimizer This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. Tools Low-Order Refined Transfer The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Meshing"},{"location":"meshing/#meshing","text":"This page provides a brief description of MFEM's mesh formats, meshing mini applications, and related tools.","title":"Meshing"},{"location":"meshing/#mesh-formats","text":"MFEM supports a number of mesh formats, including: MFEM's mesh v1.0 format for straight meshes, MFEM's mesh v1.0 format for arbitrary high-order curvilinear and more general meshes, MFEM's mesh v1.1 format , which adds support for non-conforming (AMR) meshes, MFEM's mesh v1.2 format, which adds support for parallel meshes, MFEM's format for NURBS meshes, The VTK unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes, The Gmsh ASCII and binary formats for 2D and 3D meshes. The CUBIT meshes through the Genesis (NetCDF) binary format. The NETGEN triangular and tetrahedral mesh formats, The TrueGrid hexahedral mesh format. Detailed description of these formats can be found on the mesh formats page. These formats are also supported by MFEM's native visualization tool, GLVis .","title":"Mesh formats"},{"location":"meshing/#meshing-miniapps","text":"The miniapps/meshing directory contains a collection of meshing-related miniapps based on MFEM. Compared to the example codes , the miniapps are more complex, demonstrating more advanced usage of the library. They are intended to be more representative of MFEM-based application codes. We recommend that new users start with the example codes before moving to the miniapps. The current meshing miniapps are described below. Related tools are listed at the bottom of the page.","title":"Meshing miniapps"},{"location":"meshing/#mobius-strip","text":"This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp.","title":"Mobius Strip"},{"location":"meshing/#klein-bottle","text":"This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp.","title":"Klein Bottle"},{"location":"meshing/#toroid","text":"This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. A wide variety of toroidal meshes can be generated by varying the amount of twist as well as the major and minor radii and other variables. The toroid-wedge and toroid-hex meshes in the data directory were generated with this miniapp.","title":"Toroid"},{"location":"meshing/#extruder","text":"This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D. 1D meshes can be extruded in the y-direction first and then in the z-direction. 2D meshes can be triangular, quadrilateral, or contain both element types.","title":"Extruder"},{"location":"meshing/#shaper","text":"This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material() function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported.","title":"Shaper"},{"location":"meshing/#mesh-explorer","text":"This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality","title":"Mesh Explorer"},{"location":"meshing/#mesh-optimizer","text":"This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $\\sum_T \\int_T \\mu(J(x))$, where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets.","title":"Mesh Optimizer"},{"location":"meshing/#tools","text":"","title":"Tools"},{"location":"meshing/#low-order-refined-transfer","text":"The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Low-Order Refined Transfer"},{"location":"news/","text":"All News Updates May 24, 2019 Version 4.0 released with initial GPU support. Mar 30, 2019 CEED v2.0 and libCEED v0.4 released with MFEM support. Mar 22, 2019 A version of the Laghos miniapp released for use in the second edition of the Commodity Technology Systems procurement process. May 10, 2019 AMR and TMOP papers available on arXiv. Nov 19, 2018 Laghos v2.0 released with CUDA, RAJA, OCCA and AMR versions. Nov 9, 2018 MFEM part of the first release of the Extreme-Scale Scientific Software Stack (E4S) by the Software Technologies focus area of the ECP. Aug 6, 2018 Unstructured technologies presentation at ATPESC18 . May 29, 2018 Version 3.4 released . Apr 2, 2018 MFEM part of OpenHPC , a Linux Foundation project for software components required to deploy and manage HPC Linux clusters. Mar 30, 2018 CEED v1.0 and libCEED v0.2 released with MFEM support. Mar 1, 2018 MFEM highlighted in LLNL's Science & Technology Review magazine, including on the cover . Dec 30, 2017 Initial version of libCEED , the low-level CEED API, released. Nov 10, 2017 Version 3.3.2 released . Nov 7, 2017 ECP article: Co-Design Center Develops Next-Generation Simulation Tools , also in HPCwire . Oct 30, 2017 Laghos part of the ECP Proxy App Suite 1.0 , CORAL-2 Benchmarks and ASC co-design miniapps . Oct 16, 2017 Postdoc position available for electromagnetic simulations with MFEM. Sep 22, 2017 LLNL Newsline: LLNL gears up for next generation of computer-aided design and engineering . Jun 15, 2017 Laghos miniapp and CEED benchmarks released. May 8, 2017 News highlight: Accelerating Simulation Software with Graphics Processing Units . Feb 16, 2017 Moved main development to GitHub. Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Nov 11, 2016 MFEM part of the new ECP co-design Center for Efficient Exascale Discretizations (CEED) . Nov 11, 2016 LLNL Newsline: Lawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem . Oct 6, 2016 Science & Technology Review article: Laying the Groundwork for Extreme-Scale Computing , see also the YouTube preview . Sep 19, 2016 PyMFEM - a Python wrapper for MFEM by Syun'ichi Shiraiwa from MIT's Plasma Science and Fusion Center released. Jun 30, 2016 Version 3.2 released . May 6, 2016 MFEM packages available in homebrew and spack . Mar 9, 2016 VisIt 2.10.1 released with MFEM 3.1 support. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 16, 2016 Version 3.1 released . Feb 5, 2016 MFEM simulation images part of the Art of Science exhibition at the Livermore public library. Jan 6, 2016 News highlight: High-order finite element library provides scientists with access to cutting-edge algorithms . Aug 18, 2015 Moved to GitHub and mfem.org . Jan 26, 2015 Version 3.0 released .","title":"_News"},{"location":"news/#all-news-updates","text":"May 24, 2019 Version 4.0 released with initial GPU support. Mar 30, 2019 CEED v2.0 and libCEED v0.4 released with MFEM support. Mar 22, 2019 A version of the Laghos miniapp released for use in the second edition of the Commodity Technology Systems procurement process. May 10, 2019 AMR and TMOP papers available on arXiv. Nov 19, 2018 Laghos v2.0 released with CUDA, RAJA, OCCA and AMR versions. Nov 9, 2018 MFEM part of the first release of the Extreme-Scale Scientific Software Stack (E4S) by the Software Technologies focus area of the ECP. Aug 6, 2018 Unstructured technologies presentation at ATPESC18 . May 29, 2018 Version 3.4 released . Apr 2, 2018 MFEM part of OpenHPC , a Linux Foundation project for software components required to deploy and manage HPC Linux clusters. Mar 30, 2018 CEED v1.0 and libCEED v0.2 released with MFEM support. Mar 1, 2018 MFEM highlighted in LLNL's Science & Technology Review magazine, including on the cover . Dec 30, 2017 Initial version of libCEED , the low-level CEED API, released. Nov 10, 2017 Version 3.3.2 released . Nov 7, 2017 ECP article: Co-Design Center Develops Next-Generation Simulation Tools , also in HPCwire . Oct 30, 2017 Laghos part of the ECP Proxy App Suite 1.0 , CORAL-2 Benchmarks and ASC co-design miniapps . Oct 16, 2017 Postdoc position available for electromagnetic simulations with MFEM. Sep 22, 2017 LLNL Newsline: LLNL gears up for next generation of computer-aided design and engineering . Jun 15, 2017 Laghos miniapp and CEED benchmarks released. May 8, 2017 News highlight: Accelerating Simulation Software with Graphics Processing Units . Feb 16, 2017 Moved main development to GitHub. Jan 28, 2017 Version 3.3 released . Dec 15, 2016 Postdoc position for exascale computing with MFEM. Nov 11, 2016 MFEM part of the new ECP co-design Center for Efficient Exascale Discretizations (CEED) . Nov 11, 2016 LLNL Newsline: Lawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem . Oct 6, 2016 Science & Technology Review article: Laying the Groundwork for Extreme-Scale Computing , see also the YouTube preview . Sep 19, 2016 PyMFEM - a Python wrapper for MFEM by Syun'ichi Shiraiwa from MIT's Plasma Science and Fusion Center released. Jun 30, 2016 Version 3.2 released . May 6, 2016 MFEM packages available in homebrew and spack . Mar 9, 2016 VisIt 2.10.1 released with MFEM 3.1 support. Mar 4, 2016 New LLNL open-source software Blog and Twitter . Feb 16, 2016 Version 3.1 released . Feb 5, 2016 MFEM simulation images part of the Art of Science exhibition at the Livermore public library. Jan 6, 2016 News highlight: High-order finite element library provides scientists with access to cutting-edge algorithms . Aug 18, 2015 Moved to GitHub and mfem.org . Jan 26, 2015 Version 3.0 released .","title":"All News Updates"},{"location":"parallel-tutorial/","text":"Parallel Tutorial Summary This tutorial illustrates the building and sample use of the following MFEM parallel example codes: Example 1p Example 2p Example 3p An interactive documentation of all example codes is available here . Building Follow the building instructions to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the parallel example codes, type make in MFEM's examples directory: ~/mfem/examples> make mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ... Example 1p This is a parallel version of Example 1 using hypre 's BoomerAMG preconditioner. Run this example as follows: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/square-disc.mesh ... PCG Iterations = 26 Final PCG Relative Residual Norm = 4.30922e-13 If a GLVis server is running, the computed finite element solution combined from all processors , will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . To view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button. To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example was produced by glvis -np 16 -m mesh -g sol -k \"RAjlb\" followed by F9 and scaling/position adjustment with the mouse. Three-dimensional and curvilinear meshes are also supported in parallel: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/escher-p3.mesh ... PCG Iterations = 24 Final PCG Relative Residual Norm = 3.59964e-13 ~/mfem/examples> glvis -np 16 -m mesh -g sol -k \"Aooogtt\" The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments): Example 2p This is a parallel version of Example 2 using the systems version of hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case: ~/mfem/examples> mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1 ... PCG Iterations = 39 Final PCG Relative Residual Norm = 2.91528e-09 To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse: Example 3p This is a parallel version of Example 3 using hypre 's AMS preconditioner. Its use is analogous to the serial case: /mfem/examples> mpirun -np 16 ex3p -m ../data/fichera-q3.mesh ... PCG Iterations = 17 Final PCG Relative Residual Norm = 7.61595e-13 || E_h - E ||_{L^2} = 0.0821685 Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12: One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries: glvis -np 16 -m mesh -g sol -k \"ooottmiEF\"","title":"Parallel Tutorial"},{"location":"parallel-tutorial/#parallel-tutorial","text":"","title":"Parallel Tutorial"},{"location":"parallel-tutorial/#summary","text":"This tutorial illustrates the building and sample use of the following MFEM parallel example codes: Example 1p Example 2p Example 3p An interactive documentation of all example codes is available here .","title":"Summary"},{"location":"parallel-tutorial/#building","text":"Follow the building instructions to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the parallel example codes, type make in MFEM's examples directory: ~/mfem/examples> make mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex1p.cpp -o ex1p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex2p.cpp -o ex2p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex3p.cpp -o ex3p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex4p.cpp -o ex4p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex5p.cpp -o ex5p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex7p.cpp -o ex7p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex8p.cpp -o ex8p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex9p.cpp -o ex9p ... mpicxx -O3 -I.. -I../../hypre/src/hypre/include ex10p.cpp -o ex10p ...","title":"Building"},{"location":"parallel-tutorial/#example-1p","text":"This is a parallel version of Example 1 using hypre 's BoomerAMG preconditioner. Run this example as follows: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/square-disc.mesh ... PCG Iterations = 26 Final PCG Relative Residual Norm = 4.30922e-13 If a GLVis server is running, the computed finite element solution combined from all processors , will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . To view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button. To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example was produced by glvis -np 16 -m mesh -g sol -k \"RAjlb\" followed by F9 and scaling/position adjustment with the mouse. Three-dimensional and curvilinear meshes are also supported in parallel: ~/mfem/examples> mpirun -np 16 ex1p -m ../data/escher-p3.mesh ... PCG Iterations = 24 Final PCG Relative Residual Norm = 3.59964e-13 ~/mfem/examples> glvis -np 16 -m mesh -g sol -k \"Aooogtt\" The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments):","title":"Example 1p"},{"location":"parallel-tutorial/#example-2p","text":"This is a parallel version of Example 2 using the systems version of hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case: ~/mfem/examples> mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1 ... PCG Iterations = 39 Final PCG Relative Residual Norm = 2.91528e-09 To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:","title":"Example 2p"},{"location":"parallel-tutorial/#example-3p","text":"This is a parallel version of Example 3 using hypre 's AMS preconditioner. Its use is analogous to the serial case: /mfem/examples> mpirun -np 16 ex3p -m ../data/fichera-q3.mesh ... PCG Iterations = 17 Final PCG Relative Residual Norm = 7.61595e-13 || E_h - E ||_{L^2} = 0.0821685 Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12: One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries: glvis -np 16 -m mesh -g sol -k \"ooottmiEF\"","title":"Example 3p"},{"location":"performance/","text":"Tensor-Based Operator Assembly and Evaluation Overview The high performance (HPC) versions of the example codes in the miniapps/performance directory use a set of templated classes to efficiently implement the inner-most portion ($B^T D B$) of the fundamental finite element (FE) operator decomposition: We take advantage of the tensor-product structure of both the finite element basis and the quadrature rule to efficiently apply the action of $B$ without necessarily computing its entries. This is generally know as sum factorization . In the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly . Template implementation Below is a short description of the header files that are part of the initial reference implementation of the tensor-based finite element assembly and evaluation algorithms. config/tconfig.hpp Configuration macros including the specification of the template blocking size (currently used in the matrix-matrix multiply). general/tassign.hpp Helper templated function to allow single implementation of multiple assignment operations on tensor entries. linalg/tlayout.hpp Classes describing fixed size tensor layouts. Implemented are standard strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and sub-tensor operations independent of the actual data storage. This header also contains another set of \"vector layout\" classes for converting scalar data indices into multi-component (vector) data indices. They are used to describe the layout of vector GridFunctions on global degrees of freedom (similar to the Ordering class). In the FE operator decomposition, these classes are used by the templated *_FiniteElementSpace classes (see fem/tfespace.hpp below) to implement the actions of $G$ and $G^T$ in the case of vector (multi-component) input and/or output fields. linalg/tmatrix.hpp Small matrix operations, defined by specializations: determinant, adjugate, etc. Matrix-matrix multiply, C = A.B , simple and blocked version. linalg/ttensor.hpp Fixed-size container classes TVector , TMatrix , TTensor3 , TTensor4 for 1D/2D/3D/4D tensors stored in column-major layout. Element-wise tensor operations: A {=,+=,*=} scalar ; A {=,+=,*=} B . The latter allows different input and output layouts. With suitable layouts this can be used to permute (transpose) tensors, extract sub-tensors, etc. The tensor contraction/product operations: Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$ Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$ TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$ TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$ mesh/tmesh.hpp The Mesh object templated by the finite element space and layout of the nodes. Provides MatchesGeometry() and MatchesNodes() functions to verify if compiled and runtime mesh agree. fem/tintrules.hpp Quadrature rules templated by geometry (triangles, quads, etc.) and integration order. fem/tfe.hpp H1 and L2 finite elements templated by geometry and polynomial order. fem/tfespace.hpp Template *_FiniteElementSpace classes providing the mappings between global and local (element) degrees of freedom for H1 continuous and L2 discontinuous spaces. In the FE operator decomposition, these classes provide the element local action of $G$ ( Extract methods) and $G^T$ ( Assemble methods). fem/tcoefficient.hpp Templated versions of classes derived from the abstract class Coefficient . It encapsulates physical quantities like material properties, sources, boundary/initial conditions, etc. Its main functionality is to evaluate the coefficient at all quadrature points in an element, which is then used in the evaluation of the $D$ matrix. fem/teltrans.hpp Element transformation class, templated on a mesh type and an integration rule. It is constructed from a mesh (e.g. class TMesh ) and shape evaluator (e.g. class ShapeEvaluator ) objects. Allows computation of physical coordinates and Jacobian matrices corresponding to the reference integration points. The desired result (a combination of coordinates and/or Jacobian matrices at quadrature points, element attribute and/or element index) is specified through the template sub-class Result and stored in an object of the same type. The idea of this approach is to eliminate unnecessary evaluations if they are not needed. The need is determined based on what the particular \"users\" need. The \"users\" are the templated Coefficient and Kernel (see fem/tbilininteg.hpp below) classes which specify what they need through static constant boolean variables, e.g. uses_coordinates , uses_Jacobians , etc. fem/tevaluator.hpp Classes for evaluating FE basis, ShapeEvaluator , and finite element functions, FieldEvaluator , and their derivatives at quadrature points, templated by a finite element class and an integration rule class. These correspond to the $B$ and $BG$ matrices above. Quads and hexes use the tensor-product structure for fast evaluation. fem/tbilininteg.hpp Kernel classes (e.g. mass, diffusion) that represent the matrix $D$ from the above FE operator decomposition. These classes also specify the type of the local operator that needs to be applied before and after the $D$ matrix - these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product $B^T_{out} D B_{in}$ is the local element matrix, which is the result when using the BilinearFormIntegrator classes. This specifications of the types are given by static constant boolean variables, e.g. in_values and out_values . The Kernel classes provide the following methods: Action : evaluate the action of $D$ without explicitly storing the partially assembled data; this is needed for matrix-free action. Assemble : evaluate the partially assembled data, $D$, which is kernel-specific: e.g., for mass, the data is one scalar per quadrature point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions) per quadrature point. MultAssembled : perform the action of $D$ using the pre-computed partially assembled data. fem/tbilinearform.hpp Bilinear form operator, templated on the mesh, finite element space, integration rule and bilinear form integrator. Corresponds to the $A$ matrix above. Provides various assembly and evaluation schemes: MultUnassembled : matrix-free action using the mesh nodes and the input vector. Assemble , MultAssembled : partial assembly and operator action using the partially assembled data at quadrature points and the input vector. AssembleMatrix(DenseTensor &) : assemble the local element matrices and store them as DenseTensor . AssembleMatrix(SparseMatrix &) : assemble the operator in a global (CSR) SparseMatrix . AssembleBilinearForm(BilinearForm &) : assemble element matrices and add them to the bilinear form. miniapps/performance/makefile By default make builds the example drivers with the compiler used to compile MFEM. If g++ was used, a pseudo-code dump file with the optimized code will be generated (option -fdump-tree-optimized-blocks ). The g++ option --param max-completely-peel-times=3 prevents the compiler from unrolling innermost loops (of size greater than 3), allowing the compiler to vectorize them. Some options for optimization/vectorization with the clang compiler are also included. miniapps/performance/ex*.cpp High-performance templated versions of the corresponding examples/ex*.cpp example codes. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Performance"},{"location":"performance/#tensor-based-operator-assembly-and-evaluation","text":"","title":"Tensor-Based Operator Assembly and Evaluation"},{"location":"performance/#overview","text":"The high performance (HPC) versions of the example codes in the miniapps/performance directory use a set of templated classes to efficiently implement the inner-most portion ($B^T D B$) of the fundamental finite element (FE) operator decomposition: We take advantage of the tensor-product structure of both the finite element basis and the quadrature rule to efficiently apply the action of $B$ without necessarily computing its entries. This is generally know as sum factorization . In the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly .","title":"Overview"},{"location":"performance/#template-implementation","text":"Below is a short description of the header files that are part of the initial reference implementation of the tensor-based finite element assembly and evaluation algorithms.","title":"Template implementation"},{"location":"performance/#configtconfighpp","text":"Configuration macros including the specification of the template blocking size (currently used in the matrix-matrix multiply).","title":"config/tconfig.hpp"},{"location":"performance/#generaltassignhpp","text":"Helper templated function to allow single implementation of multiple assignment operations on tensor entries.","title":"general/tassign.hpp"},{"location":"performance/#linalgtlayouthpp","text":"Classes describing fixed size tensor layouts. Implemented are standard strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and sub-tensor operations independent of the actual data storage. This header also contains another set of \"vector layout\" classes for converting scalar data indices into multi-component (vector) data indices. They are used to describe the layout of vector GridFunctions on global degrees of freedom (similar to the Ordering class). In the FE operator decomposition, these classes are used by the templated *_FiniteElementSpace classes (see fem/tfespace.hpp below) to implement the actions of $G$ and $G^T$ in the case of vector (multi-component) input and/or output fields.","title":"linalg/tlayout.hpp"},{"location":"performance/#linalgtmatrixhpp","text":"Small matrix operations, defined by specializations: determinant, adjugate, etc. Matrix-matrix multiply, C = A.B , simple and blocked version.","title":"linalg/tmatrix.hpp"},{"location":"performance/#linalgttensorhpp","text":"Fixed-size container classes TVector , TMatrix , TTensor3 , TTensor4 for 1D/2D/3D/4D tensors stored in column-major layout. Element-wise tensor operations: A {=,+=,*=} scalar ; A {=,+=,*=} B . The latter allows different input and output layouts. With suitable layouts this can be used to permute (transpose) tensors, extract sub-tensors, etc. The tensor contraction/product operations: Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$ Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$ TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$ TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$","title":"linalg/ttensor.hpp"},{"location":"performance/#meshtmeshhpp","text":"The Mesh object templated by the finite element space and layout of the nodes. Provides MatchesGeometry() and MatchesNodes() functions to verify if compiled and runtime mesh agree.","title":"mesh/tmesh.hpp"},{"location":"performance/#femtintruleshpp","text":"Quadrature rules templated by geometry (triangles, quads, etc.) and integration order.","title":"fem/tintrules.hpp"},{"location":"performance/#femtfehpp","text":"H1 and L2 finite elements templated by geometry and polynomial order.","title":"fem/tfe.hpp"},{"location":"performance/#femtfespacehpp","text":"Template *_FiniteElementSpace classes providing the mappings between global and local (element) degrees of freedom for H1 continuous and L2 discontinuous spaces. In the FE operator decomposition, these classes provide the element local action of $G$ ( Extract methods) and $G^T$ ( Assemble methods).","title":"fem/tfespace.hpp"},{"location":"performance/#femtcoefficienthpp","text":"Templated versions of classes derived from the abstract class Coefficient . It encapsulates physical quantities like material properties, sources, boundary/initial conditions, etc. Its main functionality is to evaluate the coefficient at all quadrature points in an element, which is then used in the evaluation of the $D$ matrix.","title":"fem/tcoefficient.hpp"},{"location":"performance/#femteltranshpp","text":"Element transformation class, templated on a mesh type and an integration rule. It is constructed from a mesh (e.g. class TMesh ) and shape evaluator (e.g. class ShapeEvaluator ) objects. Allows computation of physical coordinates and Jacobian matrices corresponding to the reference integration points. The desired result (a combination of coordinates and/or Jacobian matrices at quadrature points, element attribute and/or element index) is specified through the template sub-class Result and stored in an object of the same type. The idea of this approach is to eliminate unnecessary evaluations if they are not needed. The need is determined based on what the particular \"users\" need. The \"users\" are the templated Coefficient and Kernel (see fem/tbilininteg.hpp below) classes which specify what they need through static constant boolean variables, e.g. uses_coordinates , uses_Jacobians , etc.","title":"fem/teltrans.hpp"},{"location":"performance/#femtevaluatorhpp","text":"Classes for evaluating FE basis, ShapeEvaluator , and finite element functions, FieldEvaluator , and their derivatives at quadrature points, templated by a finite element class and an integration rule class. These correspond to the $B$ and $BG$ matrices above. Quads and hexes use the tensor-product structure for fast evaluation.","title":"fem/tevaluator.hpp"},{"location":"performance/#femtbilininteghpp","text":"Kernel classes (e.g. mass, diffusion) that represent the matrix $D$ from the above FE operator decomposition. These classes also specify the type of the local operator that needs to be applied before and after the $D$ matrix - these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product $B^T_{out} D B_{in}$ is the local element matrix, which is the result when using the BilinearFormIntegrator classes. This specifications of the types are given by static constant boolean variables, e.g. in_values and out_values . The Kernel classes provide the following methods: Action : evaluate the action of $D$ without explicitly storing the partially assembled data; this is needed for matrix-free action. Assemble : evaluate the partially assembled data, $D$, which is kernel-specific: e.g., for mass, the data is one scalar per quadrature point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions) per quadrature point. MultAssembled : perform the action of $D$ using the pre-computed partially assembled data.","title":"fem/tbilininteg.hpp"},{"location":"performance/#femtbilinearformhpp","text":"Bilinear form operator, templated on the mesh, finite element space, integration rule and bilinear form integrator. Corresponds to the $A$ matrix above. Provides various assembly and evaluation schemes: MultUnassembled : matrix-free action using the mesh nodes and the input vector. Assemble , MultAssembled : partial assembly and operator action using the partially assembled data at quadrature points and the input vector. AssembleMatrix(DenseTensor &) : assemble the local element matrices and store them as DenseTensor . AssembleMatrix(SparseMatrix &) : assemble the operator in a global (CSR) SparseMatrix . AssembleBilinearForm(BilinearForm &) : assemble element matrices and add them to the bilinear form.","title":"fem/tbilinearform.hpp"},{"location":"performance/#miniappsperformancemakefile","text":"By default make builds the example drivers with the compiler used to compile MFEM. If g++ was used, a pseudo-code dump file with the optimized code will be generated (option -fdump-tree-optimized-blocks ). The g++ option --param max-completely-peel-times=3 prevents the compiler from unrolling innermost loops (of size greater than 3), allowing the compiler to vectorize them. Some options for optimization/vectorization with the clang compiler are also included.","title":"miniapps/performance/makefile"},{"location":"performance/#miniappsperformanceexcpp","text":"High-performance templated versions of the corresponding examples/ex*.cpp example codes. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"miniapps/performance/ex*.cpp"},{"location":"pri-dual-vec/","text":"Primal and Dual Vectors The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Graphical summary of Primal, Dual, DoF (dofs), and True DoF (tdofs) vectors Primal Vectors The finite element method is based on the notion that a smooth function can be approximated by a sum of piece-wise smooth functions (typically piece-wise polynomilas) called basis functions : $$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$ The support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be a single zone or a collection of zones that share a common vertex, edge, or face. The expansion coefficients, $\\;f_i$, are linear functionals of the field being approximated, $\\;f(\\vec{x})$ in this case. The $\\;f_i$ could be as simple as values of the function at particular points, called interpolation points, e.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over submanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$. There are many possibilities but the expansion coefficients must be linear functionals of $\\;f(\\vec{x})$. The expansion coefficients are often called degrees of freedom , or DoFs for short, though in certain cases they may not be actually independent because of some problem specific constraints. We'll discuss this more in a later section on True DoFs . Once the basis functions are defined, with some unique ordering, the expansion coefficients can be stored in a vector using the same order. Such a vector of coefficients is called a primal vector . The original function, $\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}. In practice this requires not only the primal vector of coefficients but also knowledge of the mesh and the basis functions for each element of the mesh. In MFEM these collections of information are combined into GridFunction objects (or ParGridFunction objects when used in parallel) which represent piece-wise functions belonging to a finite element approximation space. The GridFunction class contains many Get methods which can compute the expansion \\eqref{expan} at particular locations within an element. The primal vector of expansion coefficients can be computed by solving a linear system or by using any of the various Project methods provided by the GridFunction class. These methods compute the degrees of freedom, $\\;f_i$, or some subset of them, from a Coefficient object representing $\\;f(\\vec{x})$. Other methods in this class can be used to compute various measures of the error in the finite element approximation of $\\;f(\\vec{x})$. Dual Vectors Any vector space, such as the space of primal vectors , has a dual space containing co-vectors a.k.a. dual vectors . In this context a dual vector is a linear functional of a primal vector meaning that the action of a dual vector upon a primal vector is a real number. For example, the integral of a field over a domain, $\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the integral is linear with respect to the function being integrated and the result is a real number. Indeed we can derive similar linear functionals using compatible functions, $\\;g(\\vec{x})$, in this way $G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our functional on the finite element basis functions, $$G_i=G(\\phi_i(\\vec{x})) = \\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$ and we collect the results into a vector we call this a dual vector . Integrals such as this often arise when enforcing energy balance in physical systems. For example, if $\\vec{J}$ is a current density describing a flow of charged particles and $\\vec{E}$ is an electric field acting upon those particles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which work is being done by the field on the charged particles. MFEM provides LinearForm objects (or ParLinearForm objects in parallel) which can compute dual vectors from a given function, $\\;g(\\vec{x})$. These objects require not only the mesh, basis functions, and the field $\\;g(\\vec{x})$ but also a LinearFormIntegrator which defines precisely what type of linear functional is being computed. See Linear Form Integrators for more information about MFEM's linear form integrators. A LinearForm objects provide one means for computing dual vectors if you have a Coefficient describing the function $\\;g(\\vec{x})$. If, on the other hand, you have a primal vector , $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a dual vector by multiplying $\\;g_i$ by a bilinear form, see Bilinear Form Integrators for more information on bilinear forms. To understand why this is so, consider inserting the expansion \\eqref{expan} into \\eqref{dualvec}. $$ G_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x} = \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j \\label{dualvecprod}$$ The last integral contains two indices and can therefore be viewed as an entry in a square matrix. Furthermore each dual vector entry, $\\;G_i$, is equivalent to one row of a matrix-vector product between this matrix of basis function integrals and the primal vector $\\;g_i$. This particular matrix, involving only the product of basis functions, is traditionally called a mass matrix . However, the action of any matrix, resulting from a bilinear form, upon a primal vector will produce a dual vector . In general, such dual vectors will have more complicated definitions than \\eqref{dualvec} or \\eqref{dualvecprod} but they will still be linear functionals of primal vectors . True Degree-of-Freedom Vectors Primal vectors contain all of the expansion coefficients needed to compute the finite element approximation of a function in each element of a mesh. When run in parallel, the local portion of a primal vector only contains data for the locally owned elements. Regardless of whether or not the simulation is being run in parallel, some of these coefficients may in fact be redundant or interdependent. Sources of redundancy: In parallel some coefficients must be shared between processors. When using static condensation or hybridization many coefficients will depend upon the coefficients which are associated with the skeleton of the mesh as well as upon other data. When using non-conforming meshes some of the coefficients on the finer side of a non-conforming interface between elements will depend upon those on the coarser side of the interface. For any or all of these reasons primal vectors may not contain the true degrees-of-freedom for describing a finite element approximation of a field. The true set of degrees-of-freedom may in fact be much smaller than the size of the primal vector. When setting up and solving a linear system to determine the finite element approximation of a field, the size of the linear system is determined by the number of true degrees-of-freedom . The details of creating this linear system are mostly hidden within the BilinearForm object. To convert individual bilinear form objects the user can call the BilinearForm::FormSystemMatrix() method, however, the more common task is to form the entire linear system with BilinearForm::FormLinearSystem() . As input, this method requires a primal vector , a dual vector , and an array of Dirichlet boundary degree-of-freedom indices. The degree-of-freedom array contains the true degrees-of-freedom, as obtained from a FiniteElementSpace object, which coincide with the Dirichlet, a.k.a. essential , boundaries. // Given a bilinear form 'a', a primal vector 'x', a dual vector 'b', // and an array of essential boundary true dof indices... SparseMatrix A; Vector B, X; a.FormLinearSystem(ess_tdof_list, x, b, A, X, B); // Solve X = A^{-1}B ... a.RecoverFEMSolution(X, b, x); The primal vector must contain the appropriate values for the solution on the essential boundaries. The interior of the primal vector is ignored by default although it can be used to supply an initial guess when using certain solvers. The dual vector should be an assembled LinearForm object or the product of a GridFunction and a BilinearForm . As output, BilinearForm::FormLinearSystem() produces the objects $A$, $X$, and $B$ in the linear system $A X=B$. Where $A$ is ready to be passed to the appropriate MFEM solver, $X$ is properly initialized, and $B$ has been modified to incorporate the essential boundary conditions. After the linear system has been solved the primal vector representing the solution must be built from $X$ and the original dual vector by calling BilinearForm::RecoverFEMSolution() . Technical Details Constructing Dual Vectors It was mentioned above, in the section on Dual Vectors , that you can create a dual vector by multiplying a primal vector by a bilinear form. But of course if you have a primal vector you can also use a GridFunctionCoefficient to create a dual vector using a LinearForm and an appropriate LinearFormIntegrator . These two choices should produce nearly identical results if the BilinearFormIntegrator and the LinearFormIntegrator use the same integration rule order. The order of the summation might differ between BilinearFormIntegrator and LinearFormIntegrator , potentially resulting in round-off errors differences. When considering to use a BilinearForm or a LinearForm, one must be aware of their different computational and memory costs. A bilinear form must create a sparse matrix which can require a great deal of memory. Integrating a GridFunctionCoefficient in a LinearForm object will require very little memory. On the other hand, computing the integrals inside a LinearForm object can be computationally expensive even in comparison to assembling the bilinear form. Which is the better option? As always, there are trade-offs. The answer depends on many variables; the complexities of the BilinearFormIntegrator and the LinearFormIntegrator , the complexity of other coefficients that may be present, the order of the basis functions, can the bilinear form be reused or is this a one-time calculation, whether the code runs on a CPU or GPU, etc.. On some architectures the motion of data through memory during a matrix-vector multiplication may be expensive enough that using a LinearForm and recomputing the integrals is more efficient. Often the construction of dual vectors is a small portion of the overall compute time so this choice may not be critical. The best choice is to test your application and determine which method is more appropriate for your algorithm on your hardware. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"_Primal and Dual Vectors"},{"location":"pri-dual-vec/#primal-and-dual-vectors","text":"The finite element method uses vectors of data in a variety of ways and the differences can be subtle. MFEM defines GridFunction , LinearForm , and Vector classes which help to distinguish the different roles that vectors of data can play. Graphical summary of Primal, Dual, DoF (dofs), and True DoF (tdofs) vectors","title":"Primal and Dual Vectors"},{"location":"pri-dual-vec/#primal-vectors","text":"The finite element method is based on the notion that a smooth function can be approximated by a sum of piece-wise smooth functions (typically piece-wise polynomilas) called basis functions : $$f(\\vec{x})\\approx\\sum_i f_i \\phi_i(\\vec{x}) \\label{expan}$$ The support of an individual basis function, $\\;\\phi_i(\\vec{x})$, will either be a single zone or a collection of zones that share a common vertex, edge, or face. The expansion coefficients, $\\;f_i$, are linear functionals of the field being approximated, $\\;f(\\vec{x})$ in this case. The $\\;f_i$ could be as simple as values of the function at particular points, called interpolation points, e.g. $\\;f_i=f(\\vec{x}_i)$, or they could be integrals of the field over submanifolds of the domain, e.g. $\\;f_i = \\int_{\\Omega_i}f(\\vec{x})d\\vec{x}$. There are many possibilities but the expansion coefficients must be linear functionals of $\\;f(\\vec{x})$. The expansion coefficients are often called degrees of freedom , or DoFs for short, though in certain cases they may not be actually independent because of some problem specific constraints. We'll discuss this more in a later section on True DoFs . Once the basis functions are defined, with some unique ordering, the expansion coefficients can be stored in a vector using the same order. Such a vector of coefficients is called a primal vector . The original function, $\\;f(\\vec{x})$, can then be approximated using \\eqref{expan}. In practice this requires not only the primal vector of coefficients but also knowledge of the mesh and the basis functions for each element of the mesh. In MFEM these collections of information are combined into GridFunction objects (or ParGridFunction objects when used in parallel) which represent piece-wise functions belonging to a finite element approximation space. The GridFunction class contains many Get methods which can compute the expansion \\eqref{expan} at particular locations within an element. The primal vector of expansion coefficients can be computed by solving a linear system or by using any of the various Project methods provided by the GridFunction class. These methods compute the degrees of freedom, $\\;f_i$, or some subset of them, from a Coefficient object representing $\\;f(\\vec{x})$. Other methods in this class can be used to compute various measures of the error in the finite element approximation of $\\;f(\\vec{x})$.","title":"Primal Vectors"},{"location":"pri-dual-vec/#dual-vectors","text":"Any vector space, such as the space of primal vectors , has a dual space containing co-vectors a.k.a. dual vectors . In this context a dual vector is a linear functional of a primal vector meaning that the action of a dual vector upon a primal vector is a real number. For example, the integral of a field over a domain, $\\;\\alpha=\\int_\\Omega f(\\vec{x})d\\vec{x}$, is a linear functional because the integral is linear with respect to the function being integrated and the result is a real number. Indeed we can derive similar linear functionals using compatible functions, $\\;g(\\vec{x})$, in this way $G(f)=\\int_\\Omega g(\\vec{x})f(\\vec{x})d\\vec{x}$. If we compute the action of our functional on the finite element basis functions, $$G_i=G(\\phi_i(\\vec{x})) = \\int_\\Omega g(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\label{dualvec},$$ and we collect the results into a vector we call this a dual vector . Integrals such as this often arise when enforcing energy balance in physical systems. For example, if $\\vec{J}$ is a current density describing a flow of charged particles and $\\vec{E}$ is an electric field acting upon those particles, then $\\int_\\Omega\\vec{J}\\cdot\\vec{E}\\,d\\vec{x}$ is the rate at which work is being done by the field on the charged particles. MFEM provides LinearForm objects (or ParLinearForm objects in parallel) which can compute dual vectors from a given function, $\\;g(\\vec{x})$. These objects require not only the mesh, basis functions, and the field $\\;g(\\vec{x})$ but also a LinearFormIntegrator which defines precisely what type of linear functional is being computed. See Linear Form Integrators for more information about MFEM's linear form integrators. A LinearForm objects provide one means for computing dual vectors if you have a Coefficient describing the function $\\;g(\\vec{x})$. If, on the other hand, you have a primal vector , $\\;g_i$, representing $\\;g(\\vec{x})$ you can form a dual vector by multiplying $\\;g_i$ by a bilinear form, see Bilinear Form Integrators for more information on bilinear forms. To understand why this is so, consider inserting the expansion \\eqref{expan} into \\eqref{dualvec}. $$ G_i=\\int_\\Omega \\left(\\sum_j g_j \\phi_j(\\vec{x})\\right)\\phi_i(\\vec{x})d\\vec{x} = \\sum_j \\left(\\int_\\Omega \\phi_j(\\vec{x})\\phi_i(\\vec{x})d\\vec{x}\\right)g_j \\label{dualvecprod}$$ The last integral contains two indices and can therefore be viewed as an entry in a square matrix. Furthermore each dual vector entry, $\\;G_i$, is equivalent to one row of a matrix-vector product between this matrix of basis function integrals and the primal vector $\\;g_i$. This particular matrix, involving only the product of basis functions, is traditionally called a mass matrix . However, the action of any matrix, resulting from a bilinear form, upon a primal vector will produce a dual vector . In general, such dual vectors will have more complicated definitions than \\eqref{dualvec} or \\eqref{dualvecprod} but they will still be linear functionals of primal vectors .","title":"Dual Vectors"},{"location":"pri-dual-vec/#true-degree-of-freedom-vectors","text":"Primal vectors contain all of the expansion coefficients needed to compute the finite element approximation of a function in each element of a mesh. When run in parallel, the local portion of a primal vector only contains data for the locally owned elements. Regardless of whether or not the simulation is being run in parallel, some of these coefficients may in fact be redundant or interdependent. Sources of redundancy: In parallel some coefficients must be shared between processors. When using static condensation or hybridization many coefficients will depend upon the coefficients which are associated with the skeleton of the mesh as well as upon other data. When using non-conforming meshes some of the coefficients on the finer side of a non-conforming interface between elements will depend upon those on the coarser side of the interface. For any or all of these reasons primal vectors may not contain the true degrees-of-freedom for describing a finite element approximation of a field. The true set of degrees-of-freedom may in fact be much smaller than the size of the primal vector. When setting up and solving a linear system to determine the finite element approximation of a field, the size of the linear system is determined by the number of true degrees-of-freedom . The details of creating this linear system are mostly hidden within the BilinearForm object. To convert individual bilinear form objects the user can call the BilinearForm::FormSystemMatrix() method, however, the more common task is to form the entire linear system with BilinearForm::FormLinearSystem() . As input, this method requires a primal vector , a dual vector , and an array of Dirichlet boundary degree-of-freedom indices. The degree-of-freedom array contains the true degrees-of-freedom, as obtained from a FiniteElementSpace object, which coincide with the Dirichlet, a.k.a. essential , boundaries. // Given a bilinear form 'a', a primal vector 'x', a dual vector 'b', // and an array of essential boundary true dof indices... SparseMatrix A; Vector B, X; a.FormLinearSystem(ess_tdof_list, x, b, A, X, B); // Solve X = A^{-1}B ... a.RecoverFEMSolution(X, b, x); The primal vector must contain the appropriate values for the solution on the essential boundaries. The interior of the primal vector is ignored by default although it can be used to supply an initial guess when using certain solvers. The dual vector should be an assembled LinearForm object or the product of a GridFunction and a BilinearForm . As output, BilinearForm::FormLinearSystem() produces the objects $A$, $X$, and $B$ in the linear system $A X=B$. Where $A$ is ready to be passed to the appropriate MFEM solver, $X$ is properly initialized, and $B$ has been modified to incorporate the essential boundary conditions. After the linear system has been solved the primal vector representing the solution must be built from $X$ and the original dual vector by calling BilinearForm::RecoverFEMSolution() .","title":"True Degree-of-Freedom Vectors"},{"location":"pri-dual-vec/#technical-details","text":"","title":"Technical Details"},{"location":"pri-dual-vec/#constructing-dual-vectors","text":"It was mentioned above, in the section on Dual Vectors , that you can create a dual vector by multiplying a primal vector by a bilinear form. But of course if you have a primal vector you can also use a GridFunctionCoefficient to create a dual vector using a LinearForm and an appropriate LinearFormIntegrator . These two choices should produce nearly identical results if the BilinearFormIntegrator and the LinearFormIntegrator use the same integration rule order. The order of the summation might differ between BilinearFormIntegrator and LinearFormIntegrator , potentially resulting in round-off errors differences. When considering to use a BilinearForm or a LinearForm, one must be aware of their different computational and memory costs. A bilinear form must create a sparse matrix which can require a great deal of memory. Integrating a GridFunctionCoefficient in a LinearForm object will require very little memory. On the other hand, computing the integrals inside a LinearForm object can be computationally expensive even in comparison to assembling the bilinear form. Which is the better option? As always, there are trade-offs. The answer depends on many variables; the complexities of the BilinearFormIntegrator and the LinearFormIntegrator , the complexity of other coefficients that may be present, the order of the basis functions, can the bilinear form be reused or is this a one-time calculation, whether the code runs on a CPU or GPU, etc.. On some architectures the motion of data through memory during a matrix-vector multiplication may be expensive enough that using a LinearForm and recomputing the integrals is more efficient. Often the construction of dual vectors is a small portion of the overall compute time so this choice may not be critical. The best choice is to test your application and determine which method is more appropriate for your algorithm on your hardware. MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Constructing Dual Vectors"},{"location":"publications/","text":"Publications Google Scholar Citations Recent All time Selected Publications R. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerverny, J. Dahm, V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, D. Medina, W. Pazner, M. Stowell, V. Tomov, and S. Zampini, MFEM: A Modular Finite Element Library , in preparation, 2019 . P. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown, Running Faster in HPC Applications , submitted, 2019 . H. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall, Matrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT , Comp. Meth. Appl. Mech. Eng. , in press, 2019 . D. White, Y. Choit, and J. Kudo, A dual mesh method with adaptivity for stress constrained topology optimization , Structural and Multidisciplinary Optimization , in press, 2019 . S. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White, Simple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design , Structural and Multidisciplinary Optimization , in press, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov, Towards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm , 27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque , Lecture Notes in Computational Science and Engineering, vol 127., pp. 285-302, 2019 . J. Cerverny, V. Dobrev, and Tz. Kolev, Non-Conforming Mesh Refinement For High-Order Finite Elements , SIAM Journal on Scientific Computing , 41(4):C367\u2013C392, 2019 . D. White, W. Arrighi, J. Kudo, and S. Watts, Multiscale topology optimization using neural network surrogate models , Comp. Meth. Appl. Mech. Eng. , 346, pp.1118-1135, 2019 . V. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski, Algebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning , SIAM Journal on Scientific Computing , 41(3):B425\u2013B447, 2019 . D. White, and A. Voronin, A computational study of symmetry and well-posedness of structural topology optimization , Structural and Multidisciplinary Optimization , 59(3), pp. 759-766, 2019 . T. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey, An Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes , Nuclear Science and Engineering , 2019 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, The Target-Matrix Optimization Paradigm For High-Order Meshes , SIAM Journal on Scientific Computing , 41(1):B50-B68, 2019 . T. L. Horvath and S. Rhebergen, A locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains , International Journal for Numerical Methods in Fluids , pp. 1-14, 2019 . K. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen, Analysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains , arXiv:1812.00216 , 2018 . S. Rhebergen and G. N. Wells, An embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations , arXiv:1811.09194 , 2018 . H. Auten, The High Value of Open Source Software , Science & Technology Review , January/February 2018, pp. 5-11, 2018 . R. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, High-Order Multi-Material ALE Hydrodynamics , SIAM Journal on Scientific Computing , 40(1), pp. B32-B58, 2018 . A. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev, A scalable preconditioner for a primal discontinuous Petrov-Galerkin method , SIAM Journal on Scientific Computing , 40(2), pp. A1187\u2013A1203, 2018 . V. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov, Sequential limiting in continuous and discontinuous Galerkin methods for the Euler equations , Journal of Computational Physics , 356, pp. 372 - 390, 2018 . M. Reberol and B. L\u00e9vy, Computing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU , SIAM Journal on Scientific Computing , 40(1), pp. C131-C155, 2018 . A. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore, Stress estimation in reservoirs using an integrated inverse method , Computers & Geosciences , 114, pp. 30 - 40, 2018 . D. A. White, M. Stowell, and D. A. Tortorelli, Topological optimization of structures using Fourier representations , Structural and Multidisciplinary Optimization , pp. 1-16, Apr. 2018 . R. Li, Y. Xi, L. Erlandson, and Y. Saad, The Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software , arXiv:1802.05215 , Feb. 2018 . S. Rhebergen and G. N. Wells, Preconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations , Journal of Scientific Computing , 77(3), pp. 1936-1501, 2018 . T. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey, An Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes , American Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA , 2018 . A. S\u00e1nchez-Villar and M. Merino, Advances in Wave-Plasma Modelling in ECR Thrusters , 2018 Space Propulsion Conference, May 14-18, Seville, Spain , 2018 . S. Osborn, P. S. Vassilevski, and U. Villa, A Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields , SIAM Journal on Scientific Computing , 39(5), pp. S543-S562, Oct. 2017 . R. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder, Multigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study , SIAM Journal on Scientific Computing , 39(5), pp. S298-S322, Oct. 2017 . T. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth, A Root-Node Based Algebraic Multigrid Method , SIAM Journal on Scientific Computing , 39(5), pp. S723-S756, Oct. 2017 . A. T. Barker, C. S. Lee, and P. S. Vassilevski, Spectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation , SIAM Journal on Scientific Computing , 39(5), pp. S323-S346, Oct. 2017 . V. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder, Two-level Convergence Theory For Multigrid Reduction In Time (MGRIT) , SIAM Journal on Scientific Computing , 39(5), pp. S501-S527, Oct. 2017 . R. E. Bank, P. S. Vassilevski, and L. T. Zikatanov, Arbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations , Journal of Computational and Applied Mathematics , 310, pp. 19-31, 2017 . S. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski, Scalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes , Numerical Linear Algebra with Applications , 25, pp. e2146, Dec. 2017 . J. H. Adler, I. Lashuk, and S. P. MacLachlan, Composite-grid multigrid for diffusion on the sphere , Numerical Linear Algebra with Applications , 25(1), pp. e2115, 2017 . J. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski, The auxiliary space preconditioner for the de Rham complex , arXiv:1710.07840 , Oct. 2017 . S. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev, Balancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order , Domain Decomposition Methods in Science and Engineering XXIV , 2017 . M. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison, The ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman , ISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization , Nov. 2017 . J. Wright and S. Shiraiwa, Antenna to Core: A New Approach to RF Modelling , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . S. Shiraiwa, J. C. Wright, P. T. Bonoli, Tz. Kolev, and M. Stowell, RF wave simulation for cold edge plasmas using the MFEM library , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . C. Hofer, U. Langer, M. Neum\u00fcller, and I. Toulopoulos, Time-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems , RICAM-Report 2017-26 , 2017 . J. Billings, A. McCaskey, G. Vallee, and G. Watson, Will humans even write code in 2040 and what would that mean for extreme heterogeneity in computing? , arXiv:1712.00676 , Dec. 2017 . M. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski, Numerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach , SIAM Journal on Scientific Computing , 39(1), pp. B102-B137, Feb. 2017 . R. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov, High-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation , Journal of Computational Physics , 334, pp. 102-124, Apr. 2017 . R. Li and Y. Saad, Low-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners , SIAM Journal on Matrix Analysis and Applications , 38(3), pp. 807-828, Aug. 2017 . D. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski, Upscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method , SIAM Journal on Scientific Computing , 38(5), pp. A2912\u2013A2933, Sep. 2016 . V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, Multi-material closure model for high-order finite element Lagrangian hydrodynamics , International Journal for Numerical Methods in Fluids , 82(10), pp. 689-706, 2016 . J. Guermond, B. Popov, and V. Tomov, Entropy-viscosity method for the single material Euler equations in Lagrangian frame , Computer Methods in Applied Mechanics and Engineering , 300, pp. 402 - 426, Mar. 2016 . M. Holec, J. Limpouch, R. Liska, and S. Weber, High-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics , International Journal for Numerical Methods in Fluids , 83(10), pp. 779-797, 2016 . Tz. V. Kolev, J. Xu, and Y. Zhu, Multilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients , Journal of Scientific Computing , 67(1), pp. 324--350, Apr. 2016 . M. Reberol and B. L\u00e9vy, Low-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes , CoRR , abs/1605.02626, 2016 . O. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev, Tuning the Coarse Space Construction in a Spectral AMG Solver , Procedia Computer Science , 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA, 2016 . J. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev, Data-Driven Performance Modeling of Linear Solvers for Sparse Matrices , 2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS) , Nov. 2016 . D. Osei-Kuffuor, R. Li, and Y. Saad, Matrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning , SIAM Journal on Scientific Computing , 37(1), pp. A391-A419, Feb. 2015 . R. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben, Monotonicity in high-order curvilinear finite element ALE remap , Int. J. Numer. Meth. Fluids , 77(5), pp. 249\u2013273, 2014 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics , J. Comp. Phys. , (257B), pp. 1062\u20131080, 2014 . P. Vassilevski and U. Villa, A mixed formulation for the Brinkman problem , SIAM Journal on Numerical Analysis , 52-1, pp. 258-281, 2014 . J. H. Adler and P. S. Vassilevski, Error Analysis for Constrained First-Order System Least-Squares Finite-Element Methods , SIAM Journal on Scientific Computing , 36(3), pp. A1071-A1088, 2014 . A. Aposporidis, P. S. Vassilevski, and A. Veneziani, Multigrid preconditioning of the non-regularized augmented Bingham fluid problem , ETNA. Electronic Transactions on Numerical Analysis , 41, Jan. 2014 . P. S. Vassilevski and U. M. Yang, Reducing communication in algebraic multigrid using additive variants , Numerical Linear Algebra with Applications , 21(2), pp. 275-296, 2014 . T. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra, A Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU , 2014 IEEE 28th International Parallel and Distributed Processing Symposium , May 2014 . P. Vassilevski and U. Villa, A block-diagonal algebraic multigrid preconditioner for the Brinkman problem , SIAM Journal on Scientific Computing , 35-5, pp. S3-S17, 2013 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics , Computers and Fluids , pp. 58-69, 2013 . D. Kalchev, C. Ketelsen, and P. S. Vassilevski, Two-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients , SIAM Journal on Scientific Computing , 35(6), pp. B1215-B1234, Nov. 2013 . P. D'Ambra and P. S. Vassilevski, Adaptive AMG with coarsening based on compatible weighted matching , Computing and Visualization in Science , 16(2), pp. 59--76, Apr. 2013 . T. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till, Preserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion , International Conference on Mathematics and Computational Methods Applied to Nuclear Science & Engineering , 2013 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG solver for H(div) problems , SIAM Journal on Scientific Computing , 34, pp. A3079\u2013A3098, 2012 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for Lagrangian hydrodynamics , SIAM Journal on Scientific Computing , 34, pp. B606\u2013B641, 2012 . I. Lashuk and P.Vassilevski, Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties , Numerical Linear Algebra with Applications , 19, pp. 414-426, 2012 . D. Kalchev, Adaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients , LLNL Tech. Report , LLNL-TR-553254, 2012 . A. Aposporidis, P. Vassilevski, and A. Veneziani, A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables , LLNL Tech. Report , LLNL-JRNL-600372, 2012 . P. Knupp, Introducing the target-matrix paradigm for mesh optimization by node movement , Engineering with Computers , 28(4), pp. 419--429, 2012 . T. A. Brunner, Mulard: A Multigroup Thermal Radiation Diffusion Mini-Application , DOE Exascale Research Conference, Portland, Oregon , 2012 . A. Baker, R. Falgout, T. Kolev, and U. Yang, Multigrid smoothers for ultra-parallel computing , SIAM Journal on Scientific Computing , 33(5), pp. 2864-2887, Oct. 2011 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, Curvilinear finite elements for Lagrangian hydrodynamics , Int. J. Numer. Meth. Fluids , 65, pp. 1295\u20131310, 2011 . V. Dobrev, J.-L. Guermond, and B. Popov, Surface reconstruction and image enhancement via L1-minimization , SIAM Journal on Scientific Computing , 32 (3), pp. 1591-1616, 2010 . J. Brannick and R. Falgout, Compatible relaxation and coarsening in algebraic multigrid , SIAM Journal on Scientific Computing , 32, pp. 1393-1416, 2010 . A. Baker, Tz. Kolev, and U. M. Yang, Improving algebraic multigrid interpolation operators for linear elasticity problems , Numerical Linear Algebra with Applications , 17, pp. 495-517, 2010 . U. M. Yang, On long-range interpolation operators for aggressive coarsening , Numerical Linear Algebra with Applications , 17, pp. 453\u2013472, 2010 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG for H(curl) problems , Journal of Computational Mathematics , 27, pp. 604-623, 2009 . Tz. V. Kolev and R. N. Rieben, A tensor artificial viscosity using a finite element approach , Journal of Computational Physics , 228(22), pp. 8336 - 8366, 2009 . A. Baker, E. Jessup, and Tz. Kolev, A simple strategy for varying the restart parameter in GMRES(m) , J. Comp. Appl. Math. , 230, pp. 751-761, 2009 . Tz. Kolev, J. Pasciak, and P. Vassilevski, H(curl) auxiliary mesh preconditioning , Numerical Linear Algebra with Applications , 15, pp. 455\u2013471, 2008 . H. De Sterck, R. Falgout, J. Nolting, and U. M. Yang, Distance-two interpolation for parallel algebraic multigrid , Numerical Linear Algebra with Applications , 15, pp. 115\u2013139, Apr. 2008 . V. Dobrev, R. Lazarov, and L. Zikatanov, Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, 2008 . D. Alber and L. Olson, Parallel coarse grid selection , Numerical Linear Algebra with Applications , 14, pp. 611-643, 2007 . V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations , Numerical Linear Algebra with Applications , 13 (9), pp. 753-770, 2006 . Tz. Kolev and P. Vassilevski, AMG by element agglomeration and constrained energy minimization interpolation , Numerical Linear Algebra with Applications , 13, pp. 771\u2013788, 2006 . J. Bramble, Tz. Kolev, and J. Pasciak, A least-squares approximation method for the time-harmonic Maxwell equations , Journal of Numerical Mathematics , 13(4), pp. 237-263, 2005 . P. Vassilevski, Sparse matrix element topology with application to AMG(e) and preconditioning , Numerical Linear Algebra with Applications , 9, pp. 429--444, 2002 . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Publications"},{"location":"publications/#publications","text":"","title":"Publications"},{"location":"publications/#google-scholar-citations","text":"Recent All time","title":"Google Scholar Citations"},{"location":"publications/#selected-publications","text":"R. Anderson, J. Andrej, A. Barker, J. Bramwell, J.-S. Camier, J. Cerverny, J. Dahm, V. Dobrev, Y. Dudouit, A. Fisher, Tz. Kolev, D. Medina, W. Pazner, M. Stowell, V. Tomov, and S. Zampini, MFEM: A Modular Finite Element Library , in preparation, 2019 . P. Fischer, M. Min, T. Rathanayake, S. Dutta, Tz. Kolev, V. Dobrev, J.S. Camier, M. Kronbichler, T. Warburton, K. Swirydowicz, and J. Brown, Running Faster in HPC Applications , submitted, 2019 . H. Hajduk, D. Kuzmin, Tz. Kolev, and R. Abgrall, Matrix-free subcell residual distribution for Bernstein finite elements: Low-order schemes and FCT , Comp. Meth. Appl. Mech. Eng. , in press, 2019 . D. White, Y. Choit, and J. Kudo, A dual mesh method with adaptivity for stress constrained topology optimization , Structural and Multidisciplinary Optimization , in press, 2019 . S. Watts, W. Arrighi, J. Kudo, D. A. Tortorelli, and D. A. White, Simple, accurate surrogate models of the elastic response of three-dimensional open truss micro-architectures with applications to multiscale topology design , Structural and Multidisciplinary Optimization , in press, 2019 . V. Dobrev, P. Knupp, Tz. Kolev, and V. Tomov, Towards Simulation-Driven Optimization of High-Order Meshes by the Target-Matrix Optimization Paradigm , 27th International Meshing Roundtable, Oct 1-8, 2018, Albuquerque , Lecture Notes in Computational Science and Engineering, vol 127., pp. 285-302, 2019 . J. Cerverny, V. Dobrev, and Tz. Kolev, Non-Conforming Mesh Refinement For High-Order Finite Elements , SIAM Journal on Scientific Computing , 41(4):C367\u2013C392, 2019 . D. White, W. Arrighi, J. Kudo, and S. Watts, Multiscale topology optimization using neural network surrogate models , Comp. Meth. Appl. Mech. Eng. , 346, pp.1118-1135, 2019 . V. A. Dobrev, T. V. Kolev, C. S. Lee, V. Z. Tomov, and P. S. Vassilevski, Algebraic Hybridization and Static Condensation with Application to Scalable H(div) Preconditioning , SIAM Journal on Scientific Computing , 41(3):B425\u2013B447, 2019 . D. White, and A. Voronin, A computational study of symmetry and well-posedness of structural topology optimization , Structural and Multidisciplinary Optimization , 59(3), pp. 759-766, 2019 . T. Haut, P. Maginot, V. Tomov, B. Southworth, T. Brunner and T. Bailey, An Efficient Sweep-Based Solver for the SN Equations on High-Order Meshes , Nuclear Science and Engineering , 2019 . V. Dobrev, P. Knupp, Tz. Kolev, K. Mittal, and V. Tomov, The Target-Matrix Optimization Paradigm For High-Order Meshes , SIAM Journal on Scientific Computing , 41(1):B50-B68, 2019 . T. L. Horvath and S. Rhebergen, A locally conservative and energy-stable finite element method for the Navier-Stokes problem on time-dependent domains , International Journal for Numerical Methods in Fluids , pp. 1-14, 2019 . K. L. A. Kirk, T. L. Horvath, A. Cesmelioglu and S. Rhebergen, Analysis of a space-time hybridizable discontinuous Galerkin method for the advection-diffusion problem on time-dependent domains , arXiv:1812.00216 , 2018 . S. Rhebergen and G. N. Wells, An embedded-hybridized discontinuous Galerkin finite element method for the Stokes equations , arXiv:1811.09194 , 2018 . H. Auten, The High Value of Open Source Software , Science & Technology Review , January/February 2018, pp. 5-11, 2018 . R. W. Anderson, V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, High-Order Multi-Material ALE Hydrodynamics , SIAM Journal on Scientific Computing , 40(1), pp. B32-B58, 2018 . A. T. Barker, V. Dobrev, J. Gopalakrishnan, and Tz. Kolev, A scalable preconditioner for a primal discontinuous Petrov-Galerkin method , SIAM Journal on Scientific Computing , 40(2), pp. A1187\u2013A1203, 2018 . V. Dobrev, T. Kolev, D. Kuzmin, R. Rieben, and V. Tomov, Sequential limiting in continuous and discontinuous Galerkin methods for the Euler equations , Journal of Computational Physics , 356, pp. 372 - 390, 2018 . M. Reberol and B. L\u00e9vy, Computing the Distance between Two Finite Element Solutions Defined on Different 3D Meshes on a GPU , SIAM Journal on Scientific Computing , 40(1), pp. C131-C155, 2018 . A. Mazuyer, P. Cupillard, R. Giot, M. Conin, Y. Leroy, and P. Thore, Stress estimation in reservoirs using an integrated inverse method , Computers & Geosciences , 114, pp. 30 - 40, 2018 . D. A. White, M. Stowell, and D. A. Tortorelli, Topological optimization of structures using Fourier representations , Structural and Multidisciplinary Optimization , pp. 1-16, Apr. 2018 . R. Li, Y. Xi, L. Erlandson, and Y. Saad, The Eigenvalues Slicing Library (EVSL): Algorithms, Implementation, and Software , arXiv:1802.05215 , Feb. 2018 . S. Rhebergen and G. N. Wells, Preconditioning of a hybridized discontinuous Galerkin finite element method for the Stokes equations , Journal of Scientific Computing , 77(3), pp. 1936-1501, 2018 . T. S. Haut, P. G. Maginot, V. Z. Tomov, T. A. Brunner, and T. S. Bailey, An Efficient Sweep-based Solver for the $S_N$ Equations on High-Order Meshes , American Nuclear Society 2018 Annual Meeting, June 14-21, Philadelphia, PA , 2018 . A. S\u00e1nchez-Villar and M. Merino, Advances in Wave-Plasma Modelling in ECR Thrusters , 2018 Space Propulsion Conference, May 14-18, Seville, Spain , 2018 . S. Osborn, P. S. Vassilevski, and U. Villa, A Multilevel, Hierarchical Sampling Technique for Spatially Correlated Random Fields , SIAM Journal on Scientific Computing , 39(5), pp. S543-S562, Oct. 2017 . R. D. Falgout, T. A. Manteuffel, B. O'Neill, and J. B. Schroder, Multigrid Reduction In Time For Nonlinear Parabolic Problems: A Case Study , SIAM Journal on Scientific Computing , 39(5), pp. S298-S322, Oct. 2017 . T. A. Manteuffel, L. N. Olson, J. B. Schroder, and B. S. Southworth, A Root-Node Based Algebraic Multigrid Method , SIAM Journal on Scientific Computing , 39(5), pp. S723-S756, Oct. 2017 . A. T. Barker, C. S. Lee, and P. S. Vassilevski, Spectral Upscaling for Graph Laplacian Problems with Application to Reservoir Simulation , SIAM Journal on Scientific Computing , 39(5), pp. S323-S346, Oct. 2017 . V. A. Dobrev, Tz. Kolev, N. A. Peterson, and J. B. Schroder, Two-level Convergence Theory For Multigrid Reduction In Time (MGRIT) , SIAM Journal on Scientific Computing , 39(5), pp. S501-S527, Oct. 2017 . R. E. Bank, P. S. Vassilevski, and L. T. Zikatanov, Arbitrary Dimension Convection-Diffusion Schemes For Space-Time Discretizations , Journal of Computational and Applied Mathematics , 310, pp. 19-31, 2017 . S. Osborn, P. Zulian, T. Benson, U. Villa, R. Krause, and P. S. Vassilevski, Scalable hierarchical PDE sampler for generating spatially correlated random fields using non-matching meshes , Numerical Linear Algebra with Applications , 25, pp. e2146, Dec. 2017 . J. H. Adler, I. Lashuk, and S. P. MacLachlan, Composite-grid multigrid for diffusion on the sphere , Numerical Linear Algebra with Applications , 25(1), pp. e2115, 2017 . J. Gopalakrishnan, M. Neum\u00fcller, and P. Vassilevski, The auxiliary space preconditioner for the de Rham complex , arXiv:1710.07840 , Oct. 2017 . S. Zampini, P. S. Vassilevski, V. Dobrev, and T. Kolev, Balancing Domain Decomposition by Constraints Algorithms for Curl-conforming Spaces of Arbitrary Order , Domain Decomposition Methods in Science and Engineering XXIV , 2017 . M. Larsen, J. Ahrens, U. Ayachit, E. Brugger, H. Childs, B. Geveci, and C. Harrison, The ALPINE In Situ Infrastructure: Ascending from the Ashes of Strawman , ISAV 2017: In Situ Infrastructures for Enabling Extreme-scale Analysis and Visualization , Nov. 2017 . J. Wright and S. Shiraiwa, Antenna to Core: A New Approach to RF Modelling , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . S. Shiraiwa, J. C. Wright, P. T. Bonoli, Tz. Kolev, and M. Stowell, RF wave simulation for cold edge plasmas using the MFEM library , 22 Topical Conference on Radio-Frequency Power in Plasmas , 2017 . C. Hofer, U. Langer, M. Neum\u00fcller, and I. Toulopoulos, Time-Multipatch Discontinuous Galerkin Space-Time Isogeometric Analysis of Parabolic Evolution Problems , RICAM-Report 2017-26 , 2017 . J. Billings, A. McCaskey, G. Vallee, and G. Watson, Will humans even write code in 2040 and what would that mean for extreme heterogeneity in computing? , arXiv:1712.00676 , Dec. 2017 . M. L. C. Christensen, U. Villa, A. Engsig-Karup, and P. S. Vassilevski, Numerical Multilevel Upscaling For Incompressible Flow in Reservoir Simulation: An Element-Based Algebraic Multigrid (AMGe) Approach , SIAM Journal on Scientific Computing , 39(1), pp. B102-B137, Feb. 2017 . R. Anderson, V. Dobrev, Tz. Kolev, D. Kuzmin, M. Q. de Luna, R. Rieben, and V. Tomov, High-order local maximum principle preserving (MPP) discontinuous Galerkin finite element method for the transport equation , Journal of Computational Physics , 334, pp. 102-124, Apr. 2017 . R. Li and Y. Saad, Low-Rank Correction Methods for Algebraic Domain Decomposition Preconditioners , SIAM Journal on Matrix Analysis and Applications , 38(3), pp. 807-828, Aug. 2017 . D. Z. Kalchev, C. S. Lee, U. Villa, Y. Efendiev, and P. S. Vassilevski, Upscaling of Mixed Finite Element Discretization Problems by the Spectral AMGe Method , SIAM Journal on Scientific Computing , 38(5), pp. A2912\u2013A2933, Sep. 2016 . V. A. Dobrev, Tz. V. Kolev, R. N. Rieben, and V. Z. Tomov, Multi-material closure model for high-order finite element Lagrangian hydrodynamics , International Journal for Numerical Methods in Fluids , 82(10), pp. 689-706, 2016 . J. Guermond, B. Popov, and V. Tomov, Entropy-viscosity method for the single material Euler equations in Lagrangian frame , Computer Methods in Applied Mechanics and Engineering , 300, pp. 402 - 426, Mar. 2016 . M. Holec, J. Limpouch, R. Liska, and S. Weber, High-order discontinuous Galerkin nonlocal transport and energy equations scheme for radiation hydrodynamics , International Journal for Numerical Methods in Fluids , 83(10), pp. 779-797, 2016 . Tz. V. Kolev, J. Xu, and Y. Zhu, Multilevel Preconditioners for Reaction-Diffusion Problems with Discontinuous Coefficients , Journal of Scientific Computing , 67(1), pp. 324--350, Apr. 2016 . M. Reberol and B. L\u00e9vy, Low-order continuous finite element spaces on hybrid non-conforming hexahedral-tetrahedral meshes , CoRR , abs/1605.02626, 2016 . O. Marques, A. Druinsky, X. S. Li, A. T. Barker, P. Vassilevski, and D. Kalchev, Tuning the Coarse Space Construction in a Spectral AMG Solver , Procedia Computer Science , 80, pp. 212 - 221, International Conference on Computational Science 2016, ICCS 2016, 6-8 June 2016, San Diego, California, USA, 2016 . J. S. Yeom, J. J. Thiagarajan, A. Bhatele, G. Bronevetsky, and T. Kolev, Data-Driven Performance Modeling of Linear Solvers for Sparse Matrices , 2016 7th International Workshop on Performance Modeling, Benchmarking and Simulation of High Performance Computer Systems (PMBS) , Nov. 2016 . D. Osei-Kuffuor, R. Li, and Y. Saad, Matrix Reordering Using Multilevel Graph Coarsening for ILU Preconditioning , SIAM Journal on Scientific Computing , 37(1), pp. A391-A419, Feb. 2015 . R. Anderson, V. Dobrev, Tz. Kolev, and R. Rieben, Monotonicity in high-order curvilinear finite element ALE remap , Int. J. Numer. Meth. Fluids , 77(5), pp. 249\u2013273, 2014 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics , J. Comp. Phys. , (257B), pp. 1062\u20131080, 2014 . P. Vassilevski and U. Villa, A mixed formulation for the Brinkman problem , SIAM Journal on Numerical Analysis , 52-1, pp. 258-281, 2014 . J. H. Adler and P. S. Vassilevski, Error Analysis for Constrained First-Order System Least-Squares Finite-Element Methods , SIAM Journal on Scientific Computing , 36(3), pp. A1071-A1088, 2014 . A. Aposporidis, P. S. Vassilevski, and A. Veneziani, Multigrid preconditioning of the non-regularized augmented Bingham fluid problem , ETNA. Electronic Transactions on Numerical Analysis , 41, Jan. 2014 . P. S. Vassilevski and U. M. Yang, Reducing communication in algebraic multigrid using additive variants , Numerical Linear Algebra with Applications , 21(2), pp. 275-296, 2014 . T. Dong, V. Dobrev, T. Kolev, R. Rieben, S. Tomov, and J. Dongarra, A Step towards Energy Efficient Computing: Redesigning a Hydrodynamic Application on CPU-GPU , 2014 IEEE 28th International Parallel and Distributed Processing Symposium , May 2014 . P. Vassilevski and U. Villa, A block-diagonal algebraic multigrid preconditioner for the Brinkman problem , SIAM Journal on Scientific Computing , 35-5, pp. S3-S17, 2013 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics , Computers and Fluids , pp. 58-69, 2013 . D. Kalchev, C. Ketelsen, and P. S. Vassilevski, Two-level adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients , SIAM Journal on Scientific Computing , 35(6), pp. B1215-B1234, Nov. 2013 . P. D'Ambra and P. S. Vassilevski, Adaptive AMG with coarsening based on compatible weighted matching , Computing and Visualization in Science , 16(2), pp. 59--76, Apr. 2013 . T. A. Brunner, T. V. Kolev, T. S. Bailey, and A. T. Till, Preserving Spherical Symmetry in Axisymmetric Coordinates for Diffusion , International Conference on Mathematics and Computational Methods Applied to Nuclear Science & Engineering , 2013 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG solver for H(div) problems , SIAM Journal on Scientific Computing , 34, pp. A3079\u2013A3098, 2012 . V. Dobrev, Tz. Kolev, and R. Rieben, High-order curvilinear finite element methods for Lagrangian hydrodynamics , SIAM Journal on Scientific Computing , 34, pp. B606\u2013B641, 2012 . I. Lashuk and P.Vassilevski, Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties , Numerical Linear Algebra with Applications , 19, pp. 414-426, 2012 . D. Kalchev, Adaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients , LLNL Tech. Report , LLNL-TR-553254, 2012 . A. Aposporidis, P. Vassilevski, and A. Veneziani, A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables , LLNL Tech. Report , LLNL-JRNL-600372, 2012 . P. Knupp, Introducing the target-matrix paradigm for mesh optimization by node movement , Engineering with Computers , 28(4), pp. 419--429, 2012 . T. A. Brunner, Mulard: A Multigroup Thermal Radiation Diffusion Mini-Application , DOE Exascale Research Conference, Portland, Oregon , 2012 . A. Baker, R. Falgout, T. Kolev, and U. Yang, Multigrid smoothers for ultra-parallel computing , SIAM Journal on Scientific Computing , 33(5), pp. 2864-2887, Oct. 2011 . V. Dobrev, T. Ellis, Tz. Kolev, and R. Rieben, Curvilinear finite elements for Lagrangian hydrodynamics , Int. J. Numer. Meth. Fluids , 65, pp. 1295\u20131310, 2011 . V. Dobrev, J.-L. Guermond, and B. Popov, Surface reconstruction and image enhancement via L1-minimization , SIAM Journal on Scientific Computing , 32 (3), pp. 1591-1616, 2010 . J. Brannick and R. Falgout, Compatible relaxation and coarsening in algebraic multigrid , SIAM Journal on Scientific Computing , 32, pp. 1393-1416, 2010 . A. Baker, Tz. Kolev, and U. M. Yang, Improving algebraic multigrid interpolation operators for linear elasticity problems , Numerical Linear Algebra with Applications , 17, pp. 495-517, 2010 . U. M. Yang, On long-range interpolation operators for aggressive coarsening , Numerical Linear Algebra with Applications , 17, pp. 453\u2013472, 2010 . Tz. Kolev and P. Vassilevski, Parallel auxiliary space AMG for H(curl) problems , Journal of Computational Mathematics , 27, pp. 604-623, 2009 . Tz. V. Kolev and R. N. Rieben, A tensor artificial viscosity using a finite element approach , Journal of Computational Physics , 228(22), pp. 8336 - 8366, 2009 . A. Baker, E. Jessup, and Tz. Kolev, A simple strategy for varying the restart parameter in GMRES(m) , J. Comp. Appl. Math. , 230, pp. 751-761, 2009 . Tz. Kolev, J. Pasciak, and P. Vassilevski, H(curl) auxiliary mesh preconditioning , Numerical Linear Algebra with Applications , 15, pp. 455\u2013471, 2008 . H. De Sterck, R. Falgout, J. Nolting, and U. M. Yang, Distance-two interpolation for parallel algebraic multigrid , Numerical Linear Algebra with Applications , 15, pp. 115\u2013139, Apr. 2008 . V. Dobrev, R. Lazarov, and L. Zikatanov, Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, 2008 . D. Alber and L. Olson, Parallel coarse grid selection , Numerical Linear Algebra with Applications , 14, pp. 611-643, 2007 . V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations , Numerical Linear Algebra with Applications , 13 (9), pp. 753-770, 2006 . Tz. Kolev and P. Vassilevski, AMG by element agglomeration and constrained energy minimization interpolation , Numerical Linear Algebra with Applications , 13, pp. 771\u2013788, 2006 . J. Bramble, Tz. Kolev, and J. Pasciak, A least-squares approximation method for the time-harmonic Maxwell equations , Journal of Numerical Mathematics , 13(4), pp. 237-263, 2005 . P. Vassilevski, Sparse matrix element topology with application to AMG(e) and preconditioning , Numerical Linear Algebra with Applications , 9, pp. 429--444, 2002 . MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Selected Publications"},{"location":"serial-tutorial/","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Serial Tutorial Summary This tutorial illustrates the building and sample use of the following MFEM serial example codes: Example 1 Example 2 Example 3 An interactive documentation of all example codes is available here . Building Follow the serial instructions to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the serial example codes, type make in MFEM's examples directory: ~/mfem/examples> make g++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem g++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem g++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem g++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem g++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem g++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem g++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem g++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem g++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem g++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem Example 1 This example code demonstrates the use of MFEM to define a simple linear finite element discretization of the Laplace problem $-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements): ~/mfem/examples> ex1 -m ../data/star.mesh Iteration : 0 (B r, r) = 0.00111712 Iteration : 1 (B r, r) = 0.00674088 Iteration : 2 (B r, r) = 0.0123008 ... Iteration : 88 (B r, r) = 5.28955e-15 Iteration : 89 (B r, r) = 1.99155e-15 Iteration : 90 (B r, r) = 9.91309e-16 Average reduction factor = 0.857127 If a GLVis server is running, the computed finite element solution will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . Pressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines: This example saves two files called refined.mesh and sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with glvis -m refined.mesh -g sol.gf as discussed here . Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g., ~/mfem/examples> ex1 -m ../data/fichera-q2.vtk Iteration : 0 (B r, r) = 0.0235996 Iteration : 1 (B r, r) = 0.0476694 Iteration : 2 (B r, r) = 0.0200109 ... Iteration : 27 (B r, r) = 7.77888e-14 Iteration : 28 (B r, r) = 2.36255e-14 Iteration : 29 (B r, r) = 8.56679e-15 Average reduction factor = 0.610261 The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \". Example 2 This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below: +----------+----------+ boundary --->| material | material |<--- boundary attribute 1 | 1 | 2 | attribute 2 (fixed) +----------+----------+ (pull down) The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options: ~/mfem/examples> ex2 -m ../data/beam-quad.mesh -o 2 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 1.88755e-06 Iteration : 1 (B r, r) = 8.2357e-07 Iteration : 2 (B r, r) = 9.9098e-07 ... Iteration : 498 (B r, r) = 2.78279e-11 Iteration : 499 (B r, r) = 3.75298e-11 Iteration : 500 (B r, r) = 4.95682e-11 PCG: No convergence! (B r_0, r_0) = 1.88755e-06 (B r_N, r_N) = 4.95682e-11 Number of PCG iterations: 500 Average reduction factor = 0.989508 The output shows the (curved) displaced mesh together with the inverse displacement vector field: The above plot can be alternatively produced with: glvis -m displaced.mesh -g sol.gf -k \"RfjliiiiimmAbb\" Example 2 also works in 3D: ~/mfem/examples> ex2 -m ../data/beam-tet.mesh -o 3 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 2.7147e-06 Iteration : 1 (B r, r) = 1.95756e-06 Iteration : 2 (B r, r) = 2.24159e-06 ... Iteration : 426 (B r, r) = 3.37563e-14 Iteration : 427 (B r, r) = 3.06198e-14 Iteration : 428 (B r, r) = 2.5706e-14 Average reduction factor = 0.978648 One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse: Example 3 This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh: ~/mfem/examples> ex3 -m ../data/fichera.mesh Iteration : 0 (B r, r) = 121.209 Iteration : 1 (B r, r) = 21.1137 Iteration : 2 (B r, r) = 12.6503 ... Iteration : 149 (B r, r) = 2.40571e-10 Iteration : 150 (B r, r) = 1.39788e-10 Iteration : 151 (B r, r) = 9.43635e-11 Average reduction factor = 0.911811 || E_h - E ||_{L^2} = 0.00976655 To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ): Curved meshes are also supported: ~/mfem/examples> ex3 -m ../data/fichera-q3.mesh Iteration : 0 (B r, r) = 135.613 Iteration : 1 (B r, r) = 22.3785 Iteration : 2 (B r, r) = 12.5215 ... Iteration : 168 (B r, r) = 4.95911e-10 Iteration : 169 (B r, r) = 2.23499e-10 Iteration : 170 (B r, r) = 1.25714e-10 Average reduction factor = 0.921741 || E_h - E ||_{L^2} = 0.0821686 To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \": Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example: ~/mfem/examples> ex3 -m ../data/escher.mesh Iteration : 0 (B r, r) = 348.797 Iteration : 1 (B r, r) = 32.0699 Iteration : 2 (B r, r) = 14.902 ... Iteration : 159 (B r, r) = 4.16076e-10 Iteration : 160 (B r, r) = 3.50907e-10 Iteration : 161 (B r, r) = 3.22923e-10 Average reduction factor = 0.917548 || E_h - E ||_{L^2} = 0.36541 ~/mfem/examples> glvis -m refined.mesh -g sol.gf -gc 0 -k \"gooottF\" The discontinuity of the Nedelec functions is clearly seen in the above plot.","title":"Serial Tutorial"},{"location":"serial-tutorial/#serial-tutorial","text":"","title":"Serial Tutorial"},{"location":"serial-tutorial/#summary","text":"This tutorial illustrates the building and sample use of the following MFEM serial example codes: Example 1 Example 2 Example 3 An interactive documentation of all example codes is available here .","title":"Summary"},{"location":"serial-tutorial/#building","text":"Follow the serial instructions to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional). To build the serial example codes, type make in MFEM's examples directory: ~/mfem/examples> make g++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem g++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem g++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem g++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem g++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem g++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem g++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem g++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem g++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem g++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem","title":"Building"},{"location":"serial-tutorial/#example-1","text":"This example code demonstrates the use of MFEM to define a simple linear finite element discretization of the Laplace problem $-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements): ~/mfem/examples> ex1 -m ../data/star.mesh Iteration : 0 (B r, r) = 0.00111712 Iteration : 1 (B r, r) = 0.00674088 Iteration : 2 (B r, r) = 0.0123008 ... Iteration : 88 (B r, r) = 5.28955e-15 Iteration : 89 (B r, r) = 1.99155e-15 Iteration : 90 (B r, r) = 9.91309e-16 Average reduction factor = 0.857127 If a GLVis server is running, the computed finite element solution will appear in an interactive window: You can examine the solution using the mouse and the GLVis command keystrokes . Pressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines: This example saves two files called refined.mesh and sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with glvis -m refined.mesh -g sol.gf as discussed here . Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g., ~/mfem/examples> ex1 -m ../data/fichera-q2.vtk Iteration : 0 (B r, r) = 0.0235996 Iteration : 1 (B r, r) = 0.0476694 Iteration : 2 (B r, r) = 0.0200109 ... Iteration : 27 (B r, r) = 7.77888e-14 Iteration : 28 (B r, r) = 2.36255e-14 Iteration : 29 (B r, r) = 8.56679e-15 Average reduction factor = 0.610261 The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \".","title":"Example 1"},{"location":"serial-tutorial/#example-2","text":"This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below: +----------+----------+ boundary --->| material | material |<--- boundary attribute 1 | 1 | 2 | attribute 2 (fixed) +----------+----------+ (pull down) The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options: ~/mfem/examples> ex2 -m ../data/beam-quad.mesh -o 2 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 1.88755e-06 Iteration : 1 (B r, r) = 8.2357e-07 Iteration : 2 (B r, r) = 9.9098e-07 ... Iteration : 498 (B r, r) = 2.78279e-11 Iteration : 499 (B r, r) = 3.75298e-11 Iteration : 500 (B r, r) = 4.95682e-11 PCG: No convergence! (B r_0, r_0) = 1.88755e-06 (B r_N, r_N) = 4.95682e-11 Number of PCG iterations: 500 Average reduction factor = 0.989508 The output shows the (curved) displaced mesh together with the inverse displacement vector field: The above plot can be alternatively produced with: glvis -m displaced.mesh -g sol.gf -k \"RfjliiiiimmAbb\" Example 2 also works in 3D: ~/mfem/examples> ex2 -m ../data/beam-tet.mesh -o 3 Assembling: r.h.s. ... matrix ... done. Iteration : 0 (B r, r) = 2.7147e-06 Iteration : 1 (B r, r) = 1.95756e-06 Iteration : 2 (B r, r) = 2.24159e-06 ... Iteration : 426 (B r, r) = 3.37563e-14 Iteration : 427 (B r, r) = 3.06198e-14 Iteration : 428 (B r, r) = 2.5706e-14 Average reduction factor = 0.978648 One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse:","title":"Example 2"},{"location":"serial-tutorial/#example-3","text":"This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh: ~/mfem/examples> ex3 -m ../data/fichera.mesh Iteration : 0 (B r, r) = 121.209 Iteration : 1 (B r, r) = 21.1137 Iteration : 2 (B r, r) = 12.6503 ... Iteration : 149 (B r, r) = 2.40571e-10 Iteration : 150 (B r, r) = 1.39788e-10 Iteration : 151 (B r, r) = 9.43635e-11 Average reduction factor = 0.911811 || E_h - E ||_{L^2} = 0.00976655 To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ): Curved meshes are also supported: ~/mfem/examples> ex3 -m ../data/fichera-q3.mesh Iteration : 0 (B r, r) = 135.613 Iteration : 1 (B r, r) = 22.3785 Iteration : 2 (B r, r) = 12.5215 ... Iteration : 168 (B r, r) = 4.95911e-10 Iteration : 169 (B r, r) = 2.23499e-10 Iteration : 170 (B r, r) = 1.25714e-10 Average reduction factor = 0.921741 || E_h - E ||_{L^2} = 0.0821686 To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \": Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example: ~/mfem/examples> ex3 -m ../data/escher.mesh Iteration : 0 (B r, r) = 348.797 Iteration : 1 (B r, r) = 32.0699 Iteration : 2 (B r, r) = 14.902 ... Iteration : 159 (B r, r) = 4.16076e-10 Iteration : 160 (B r, r) = 3.50907e-10 Iteration : 161 (B r, r) = 3.22923e-10 Average reduction factor = 0.917548 || E_h - E ||_{L^2} = 0.36541 ~/mfem/examples> glvis -m refined.mesh -g sol.gf -gc 0 -k \"gooottF\" The discontinuity of the Nedelec functions is clearly seen in the above plot.","title":"Example 3"}]}